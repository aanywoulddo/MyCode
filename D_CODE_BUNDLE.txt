====================================================================
FILE: D/export_chat.js
====================================================================
// Make ExportChat globally available
window.ExportChat = class ExportChat {
    constructor() {
        this.exportSettings = {
            format: 'pdf',
            fileName: 'gemini-chat-export',
            pdfTheme: 'auto',
            orientation: 'portrait',
            compression: false
        };
        this.selectedChat = null;
    }

    init() {
        this.loadSettings();
        this.setupEventListeners();
    }

    loadSettings() {
        try {
            const saved = localStorage.getItem('gemini-export-settings');
            if (saved) {
                this.exportSettings = { ...this.exportSettings, ...JSON.parse(saved) };
            }
        } catch (error) {
            console.error('Error loading export settings:', error);
        }
    }

    saveSettings() {
        try {
            localStorage.setItem('gemini-export-settings', JSON.stringify(this.exportSettings));
        } catch (error) {
            console.error('Error saving export settings:', error);
        }
    }

    setupEventListeners() {
        // This will be called from the main injector
    }

    showExportModal() {
        // First show chat selection
        this.showChatSelectionModal();
    }

    showChatSelectionModal() {
        const modalHTML = this.getChatSelectionHTML();
        this.openModal("chat-selection-modal", "Select Chat to Export", modalHTML, 800);
    }

    showExportOptionsModal(selectedChatId, selectedChatTitle) {
        const modalHTML = this.getExportModalHTML(selectedChatId, selectedChatTitle);
        this.openModal("export-options-modal", "Export Chat", modalHTML, 700);
    }

    getChatSelectionHTML() {
        const isDark = this.detectTheme() === 'dark';
        const themeClass = isDark ? 'dark-theme' : 'light-theme';
        
        return `
            <div class="chat-selection-content ${themeClass}">
                <div class="chat-selection-section">
                    <h3>Select a Chat to Export</h3>
                    <div class="chat-search-container">
                        <input type="text" id="chat-search-input" placeholder="Search chats..." class="chat-search-input">
                    </div>
                    <div class="chat-list-container">
                        <div id="chat-list" class="chat-list">
                            <!-- Chat list will be populated here -->
                        </div>
                    </div>
                </div>
                
                <div class="chat-selection-actions">
                    <button class="btn-secondary" id="cancel-chat-selection">Cancel</button>
                    <button class="btn-primary" id="select-chat-btn" disabled>Select Chat</button>
                </div>
            </div>
        `;
    }

    getExportModalHTML(selectedChatId = null, selectedChatTitle = null) {
        const isDark = this.detectTheme() === 'dark';
        const themeClass = isDark ? 'dark-theme' : 'light-theme';
        
        const selectedChatInfo = selectedChatTitle ? 
            `<div class="selected-chat-info">
                <span class="selected-chat-label">Selected Chat:</span>
                <span class="selected-chat-title">${selectedChatTitle}</span>
            </div>` : '';
        
        return `
            <div class="export-modal-content ${themeClass}">
                ${selectedChatInfo}
                
                <div class="export-section">
                    <h3>Export Options</h3>
                    <div class="export-format-grid">
                        <div class="format-option" data-format="pdf">
                            <div class="format-icon">üìÑ</div>
                            <div class="format-info">
                                <div class="format-name">PDF</div>
                                <div class="format-desc">High-quality document</div>
                            </div>
                        </div>
                        <div class="format-option" data-format="html">
                            <div class="format-icon">üåê</div>
                            <div class="format-info">
                                <div class="format-name">HTML</div>
                                <div class="format-desc">Web page format</div>
                            </div>
                        </div>
                        <div class="format-option" data-format="md">
                            <div class="format-icon">üìù</div>
                            <div class="format-info">
                                <div class="format-name">Markdown</div>
                                <div class="format-desc">Plain text with formatting</div>
                            </div>
                        </div>
                        <div class="format-option" data-format="json">
                            <div class="format-icon">üìä</div>
                            <div class="format-info">
                                <div class="format-name">JSON</div>
                                <div class="format-desc">Structured data</div>
                            </div>
                        </div>
                        <div class="format-option" data-format="txt">
                            <div class="format-icon">üìÑ</div>
                            <div class="format-info">
                                <div class="format-name">Text</div>
                                <div class="format-desc">Plain text file</div>
                            </div>
                        </div>
                        <div class="format-option" data-format="csv">
                            <div class="format-icon">üìä</div>
                            <div class="format-info">
                                <div class="format-name">CSV</div>
                                <div class="format-desc">Spreadsheet format</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="export-section">
                    <h3>Settings</h3>
                    <div class="setting-group">
                        <label for="export-filename">File Name:</label>
                        <input type="text" id="export-filename" value="${this.exportSettings.fileName}" placeholder="Enter file name">
                    </div>
                    
                    <div class="setting-group">
                        <label>Theme:</label>
                        <div class="theme-options">
                            <label class="radio-option">
                                <input type="radio" name="theme" value="light" ${this.exportSettings.pdfTheme === 'light' ? 'checked' : ''}>
                                <span>Light</span>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="theme" value="dark" ${this.exportSettings.pdfTheme === 'dark' ? 'checked' : ''}>
                                <span>Dark</span>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="theme" value="auto" ${this.exportSettings.pdfTheme === 'auto' ? 'checked' : ''}>
                                <span>Auto</span>
                            </label>
                        </div>
                    </div>

                    <div class="setting-group">
                        <label>Orientation:</label>
                        <div class="orientation-options">
                            <label class="radio-option">
                                <input type="radio" name="orientation" value="portrait" ${this.exportSettings.orientation === 'portrait' ? 'checked' : ''}>
                                <span>Portrait</span>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="orientation" value="landscape" ${this.exportSettings.orientation === 'landscape' ? 'checked' : ''}>
                                <span>Landscape</span>
                            </label>
                        </div>
                    </div>

                    <div class="setting-group">
                        <label class="checkbox-option">
                            <input type="checkbox" id="compression-toggle" ${this.exportSettings.compression ? 'checked' : ''}>
                            <span>Enable compression (smaller file size)</span>
                        </label>
                    </div>
                </div>

                <div class="export-section">
                    <h3>Export Range</h3>
                    <div class="export-range-options">
                        <label class="radio-option">
                            <input type="radio" name="export-range" value="current" checked>
                            <span>Current conversation</span>
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="export-range" value="selected">
                            <span>Selected messages</span>
                        </label>
                    </div>
                </div>

                <div class="export-actions">
                    <button class="btn-secondary" id="cancel-export">Cancel</button>
                    <button class="btn-primary" id="start-export">Export Chat</button>
                </div>
            </div>
        `;
    }

    openModal(id, title, contentHTML, width = 600) {
        // Create a properly centered modal
        const modal = document.createElement('div');
        modal.id = id;
        modal.className = 'export-modal';
        modal.innerHTML = `
            <div class="modal-backdrop"></div>
            <div class="modal-container" style="max-width: ${width}px;">
                <div class="modal-header">
                    <h2>${title}</h2>
                    <button class="close-btn" id="close-export-modal">√ó</button>
                </div>
                <div class="modal-body">
                    ${contentHTML}
                </div>
            </div>
        `;

        document.body.appendChild(modal);
        
        // Ensure modal is properly centered and visible
        setTimeout(() => {
            modal.style.display = 'flex';
            modal.classList.add('show');
        }, 10);
        
        this.setupModalEventListeners(modal);
    }

    setupModalEventListeners(modal) {
        const modalId = modal.id;
        
        if (modalId === 'chat-selection-modal') {
            this.setupChatSelectionListeners(modal);
        } else if (modalId === 'export-options-modal') {
            this.setupExportOptionsListeners(modal);
        }
    }

    setupChatSelectionListeners(modal) {
        // Load chat list
        this.loadChatList(modal);
        
        // Search functionality
        const searchInput = modal.querySelector('#chat-search-input');
        searchInput.addEventListener('input', () => {
            this.filterChatList(modal, searchInput.value);
        });

        // Select chat button
        const selectBtn = modal.querySelector('#select-chat-btn');
        selectBtn.addEventListener('click', () => {
            const selectedChat = modal.querySelector('.chat-item.selected');
            if (selectedChat) {
                const chatId = selectedChat.dataset.chatId;
                const chatTitle = selectedChat.querySelector('.chat-title').textContent;
                this.closeModal(modal);
                this.navigateToChatAndExport(chatId, chatTitle);
            }
        });

        // Cancel button
        const cancelBtn = modal.querySelector('#cancel-chat-selection');
        cancelBtn.addEventListener('click', () => {
            this.closeModal(modal);
        });

        // Close button
        const closeBtn = modal.querySelector('#close-export-modal');
        closeBtn.addEventListener('click', () => {
            this.closeModal(modal);
        });

        // Backdrop click
        const backdrop = modal.querySelector('.modal-backdrop');
        backdrop.addEventListener('click', () => {
            this.closeModal(modal);
        });
    }

    setupExportOptionsListeners(modal) {
        // Format selection
        modal.querySelectorAll('.format-option').forEach(option => {
            option.addEventListener('click', () => {
                modal.querySelectorAll('.format-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                this.exportSettings.format = option.dataset.format;
            });
        });

        // Theme selection
        modal.querySelectorAll('input[name="theme"]').forEach(radio => {
            radio.addEventListener('change', () => {
                this.exportSettings.pdfTheme = radio.value;
            });
        });

        // Orientation selection
        modal.querySelectorAll('input[name="orientation"]').forEach(radio => {
            radio.addEventListener('change', () => {
                this.exportSettings.orientation = radio.value;
            });
        });

        // Compression toggle
        const compressionToggle = modal.querySelector('#compression-toggle');
        compressionToggle.addEventListener('change', () => {
            this.exportSettings.compression = compressionToggle.checked;
        });

        // Filename input
        const filenameInput = modal.querySelector('#export-filename');
        filenameInput.addEventListener('input', () => {
            this.exportSettings.fileName = filenameInput.value.trim();
        });

        // Export button
        const exportBtn = modal.querySelector('#start-export');
        exportBtn.addEventListener('click', () => {
            this.performExport(modal);
        });

        // Cancel button
        const cancelBtn = modal.querySelector('#cancel-export');
        cancelBtn.addEventListener('click', () => {
            this.closeModal(modal);
        });

        // Close button
        const closeBtn = modal.querySelector('#close-export-modal');
        closeBtn.addEventListener('click', () => {
            this.closeModal(modal);
        });

        // Backdrop click
        const backdrop = modal.querySelector('.modal-backdrop');
        backdrop.addEventListener('click', () => {
            this.closeModal(modal);
        });

        // Set initial selected format
        const currentFormatOption = modal.querySelector(`[data-format="${this.exportSettings.format}"]`);
        if (currentFormatOption) {
            currentFormatOption.classList.add('selected');
        }
    }

    loadChatList(modal) {
        const chatList = modal.querySelector('#chat-list');
        const conversations = this.getAllConversations();
        
        if (conversations.length === 0) {
            chatList.innerHTML = `
                <div class="no-chats-message">
                    <p>No conversations found. Please start a conversation first.</p>
                </div>
            `;
            return;
        }

        const chatListHTML = conversations.map(chat => `
            <div class="chat-item" data-chat-id="${chat.id}">
                <div class="chat-icon">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div class="chat-info">
                    <div class="chat-title">${chat.title}</div>
                    <div class="chat-preview">${chat.preview}</div>
                </div>
                <div class="chat-date">${chat.date}</div>
            </div>
        `).join('');

        chatList.innerHTML = chatListHTML;

        // Add click listeners to chat items
        chatList.querySelectorAll('.chat-item').forEach(item => {
            item.addEventListener('click', () => {
                chatList.querySelectorAll('.chat-item').forEach(chat => chat.classList.remove('selected'));
                item.classList.add('selected');
                modal.querySelector('#select-chat-btn').disabled = false;
            });
        });
    }

    filterChatList(modal, searchTerm) {
        const chatItems = modal.querySelectorAll('.chat-item');
        const searchLower = searchTerm.toLowerCase();

        chatItems.forEach(item => {
            const title = item.querySelector('.chat-title').textContent.toLowerCase();
            const preview = item.querySelector('.chat-preview').textContent.toLowerCase();
            
            if (title.includes(searchLower) || preview.includes(searchLower)) {
                item.style.display = 'flex';
            } else {
                item.style.display = 'none';
            }
        });
    }

    getAllConversations() {
        const conversations = [];
        
        // Get all conversation elements from the sidebar
        const conversationElements = document.querySelectorAll('conversations-list div[data-test-id="conversation"], conversations-list .conversation-item, [data-test-id="conversation"], .conversation-item');
        
        conversationElements.forEach((element, index) => {
            const titleElement = element.querySelector('.conversation-title, .title, h3, h4, [data-test-id="conversation-title"]');
            const previewElement = element.querySelector('.conversation-preview, .preview, p, [data-test-id="conversation-preview"]');
            const dateElement = element.querySelector('.conversation-date, .date, time, [data-test-id="conversation-date"]');
            
            const title = titleElement ? titleElement.textContent.trim() : `Conversation ${index + 1}`;
            const preview = previewElement ? previewElement.textContent.trim() : 'No preview available';
            const date = dateElement ? dateElement.textContent.trim() : '';
            
            // Generate a unique ID for the conversation
            const chatId = this.generateChatId(element, index);
            
            conversations.push({
                id: chatId,
                title: title,
                preview: preview.length > 100 ? preview.substring(0, 100) + '...' : preview,
                date: date,
                element: element
            });
        });

        return conversations;
    }

    generateChatId(element, index) {
        // Try to get existing ID from element
        const existingId = element.getAttribute('data-conversation-id') || 
                          element.getAttribute('data-chat-id') || 
                          element.id;
        
        if (existingId) {
            return existingId;
        }
        
        // Generate a new ID based on title and index
        const titleElement = element.querySelector('.conversation-title, .title, h3, h4');
        const title = titleElement ? titleElement.textContent.trim() : `conversation-${index}`;
        const sanitizedTitle = title.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
        
        return `chat-${sanitizedTitle}-${index}`;
    }

    async navigateToChatAndExport(chatId, chatTitle) {
        try {
            // Find the conversation element
            const conversationElement = document.querySelector(`[data-conversation-id="${chatId}"], [data-chat-id="${chatId}"], #${chatId}`);
            
            if (conversationElement) {
                // Click on the conversation to navigate to it
                conversationElement.click();
                
                // Wait for the conversation to load
                await this.waitForConversationLoad();
                
                // Show export options modal
                this.showExportOptionsModal(chatId, chatTitle);
            } else {
                // If we can't find the specific element, try to find by title
                const conversations = this.getAllConversations();
                const targetConversation = conversations.find(conv => conv.title === chatTitle);
                
                if (targetConversation && targetConversation.element) {
                    targetConversation.element.click();
                    await this.waitForConversationLoad();
                    this.showExportOptionsModal(chatId, chatTitle);
                } else {
                    // Fallback: show export options for current conversation
                    this.showExportOptionsModal(null, 'Current Conversation');
                }
            }
        } catch (error) {
            console.error('Error navigating to chat:', error);
            // Fallback: show export options for current conversation
            this.showExportOptionsModal(null, 'Current Conversation');
        }
    }

    async waitForConversationLoad() {
        return new Promise((resolve) => {
            // Wait for conversation content to load
            const checkForContent = () => {
                const conversationContent = document.querySelector('div.conversation-container, message-content, user-query, [data-test-id="conversation-content"]');
                if (conversationContent) {
                    resolve();
                } else {
                    setTimeout(checkForContent, 100);
                }
            };
            
            checkForContent();
        });
    }

    closeModal(modal) {
        modal.classList.remove('show');
        setTimeout(() => {
            if (modal.parentNode) {
                modal.parentNode.removeChild(modal);
            }
        }, 300);
    }

    performExport(modal) {
        const format = this.exportSettings.format;
        const fileName = this.exportSettings.fileName || 'gemini-chat-export';
        
        try {
            const chatContent = this.extractChatContent();
            const exportData = this.formatExportData(chatContent, format);
            
            this.downloadFile(exportData, fileName, format);
            this.showSuccessNotification();
            this.saveSettings();
            this.closeModal(modal);
        } catch (error) {
            console.error('Export failed:', error);
            this.showErrorNotification('Export failed. Please try again.');
        }
    }

    extractChatContent() {
        const messages = [];
        const messageElements = document.querySelectorAll('message-content, user-query, [data-test-id="message"], .message');
        
        messageElements.forEach((element, index) => {
            const role = this.determineMessageRole(element);
            const content = this.extractMessageContent(element);
            
            if (content) {
                messages.push({
                    role: role,
                    content: content,
                    timestamp: new Date().toISOString(),
                    index: index
                });
            }
        });
        
        return {
            title: this.getConversationTitle(),
            messages: messages,
            exportDate: new Date().toISOString(),
            totalMessages: messages.length
        };
    }

    determineMessageRole(element) {
        const classes = element.className.toLowerCase();
        const testId = element.getAttribute('data-test-id') || '';
        
        if (classes.includes('user') || testId.includes('user') || element.querySelector('.user-message')) {
            return 'user';
        } else if (classes.includes('assistant') || testId.includes('assistant') || element.querySelector('.assistant-message')) {
            return 'assistant';
        } else {
            // Default to assistant if we can't determine
            return 'assistant';
        }
    }

    extractMessageContent(element) {
        // Try multiple selectors to find the message content
        const contentSelectors = [
            '.message-content',
            '.content',
            'p',
            'div',
            '[data-test-id="message-content"]'
        ];
        
        for (const selector of contentSelectors) {
            const contentElement = element.querySelector(selector);
            if (contentElement && contentElement.textContent.trim()) {
                return contentElement.textContent.trim();
            }
        }
        
        // Fallback to the element's own text content
        return element.textContent.trim();
    }

    getConversationTitle() {
        const titleElement = document.querySelector('.conversation-title, .title, h1, h2, [data-test-id="conversation-title"]');
        return titleElement ? titleElement.textContent.trim() : 'Gemini Chat Export';
    }

    formatExportData(chatContent, format) {
        switch (format) {
            case 'pdf':
                return this.formatAsPDF(chatContent);
            case 'html':
                return this.formatAsHTML(chatContent);
            case 'md':
                return this.formatAsMarkdown(chatContent);
            case 'json':
                return this.formatAsJSON(chatContent);
            case 'txt':
                return this.formatAsText(chatContent);
            case 'csv':
                return this.formatAsCSV(chatContent);
            default:
                return this.formatAsText(chatContent);
        }
    }

    formatAsPDF(chatContent) {
        const html = this.formatAsHTML(chatContent);
        return html; // For now, return HTML that can be converted to PDF
    }

    formatAsHTML(chatContent) {
        const theme = this.exportSettings.pdfTheme === 'auto' ? this.detectTheme() : this.exportSettings.pdfTheme;
        const isDark = theme === 'dark';
        
        return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${chatContent.title}</title>
    <style>
        body {
            font-family: 'Google Sans', 'Roboto', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: ${isDark ? '#1a1a1a' : '#ffffff'};
            color: ${isDark ? '#ffffff' : '#000000'};
        }
        .chat-container {
            max-width: 800px;
            margin: 0 auto;
        }
        .chat-header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid ${isDark ? '#333' : '#e0e0e0'};
        }
        .chat-title {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 10px;
        }
        .chat-meta {
            font-size: 14px;
            color: ${isDark ? '#888' : '#666'};
        }
        .message {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid;
        }
        .message.user {
            background: ${isDark ? '#2a2a2a' : '#f8f9fa'};
            border-left-color: #4285f4;
        }
        .message.assistant {
            background: ${isDark ? '#333' : '#ffffff'};
            border-left-color: #34a853;
            border: 1px solid ${isDark ? '#444' : '#e0e0e0'};
        }
        .message-role {
            font-weight: 500;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 8px;
            color: ${isDark ? '#888' : '#666'};
        }
        .message-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .export-footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid ${isDark ? '#333' : '#e0e0e0'};
            text-align: center;
            font-size: 12px;
            color: ${isDark ? '#888' : '#666'};
        }
        @media print {
            body { margin: 0; }
            .chat-container { max-width: none; }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <div class="chat-title">${chatContent.title}</div>
            <div class="chat-meta">
                Exported on ${new Date(chatContent.exportDate).toLocaleString()} | 
                ${chatContent.totalMessages} messages
            </div>
        </div>
        
        ${chatContent.messages.map(message => `
            <div class="message ${message.role}">
                <div class="message-role">${message.role}</div>
                <div class="message-content">${this.escapeHtml(message.content)}</div>
            </div>
        `).join('')}
        
        <div class="export-footer">
            Exported using Gemini Toolbox Export Chat Feature
        </div>
    </div>
</body>
</html>`;
    }

    formatAsMarkdown(chatContent) {
        let markdown = `# ${chatContent.title}\n\n`;
        markdown += `**Exported on:** ${new Date(chatContent.exportDate).toLocaleString()}\n`;
        markdown += `**Total messages:** ${chatContent.totalMessages}\n\n`;
        markdown += `---\n\n`;
        
        chatContent.messages.forEach(message => {
            markdown += `### ${message.role.charAt(0).toUpperCase() + message.role.slice(1)}\n\n`;
            markdown += `${message.content}\n\n`;
            markdown += `---\n\n`;
        });
        
        return markdown;
    }

    formatAsJSON(chatContent) {
        return JSON.stringify(chatContent, null, 2);
    }

    formatAsText(chatContent) {
        let text = `${chatContent.title}\n`;
        text += `Exported on: ${new Date(chatContent.exportDate).toLocaleString()}\n`;
        text += `Total messages: ${chatContent.totalMessages}\n\n`;
        text += `==========================================\n\n`;
        
        chatContent.messages.forEach(message => {
            text += `${message.role.toUpperCase()}:\n`;
            text += `${message.content}\n\n`;
            text += `------------------------------------------\n\n`;
        });
        
        return text;
    }

    formatAsCSV(chatContent) {
        let csv = 'Role,Content,Timestamp\n';
        
        chatContent.messages.forEach(message => {
            const escapedContent = `"${message.content.replace(/"/g, '""')}"`;
            csv += `${message.role},${escapedContent},${message.timestamp}\n`;
        });
        
        return csv;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    downloadFile(content, fileName, format) {
        const blob = new Blob([content], { 
            type: this.getMimeType(format) 
        });
        
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${fileName}.${format}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    getMimeType(format) {
        const mimeTypes = {
            'pdf': 'application/pdf',
            'html': 'text/html',
            'md': 'text/markdown',
            'json': 'application/json',
            'txt': 'text/plain',
            'csv': 'text/csv'
        };
        return mimeTypes[format] || 'text/plain';
    }

    showSuccessNotification() {
        const notification = document.createElement('div');
        notification.className = 'export-success-notification';
        notification.innerHTML = `
            <span>‚úÖ</span>
            <span>Chat exported successfully!</span>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }

    showErrorNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'export-success-notification';
        notification.style.background = '#f44336';
        notification.innerHTML = `
            <span>‚ùå</span>
            <span>${message}</span>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }

    detectTheme() {
        const body = document.body;
        if (body.classList.contains('dark-theme') || body.classList.contains('dark_mode_toggled')) {
            return 'dark';
        }
        
        const htmlTheme = document.documentElement.getAttribute('data-theme');
        if (htmlTheme === 'dark') {
            return 'dark';
        }
        
        const bodyBgColor = window.getComputedStyle(body).backgroundColor;
        if (bodyBgColor) {
            const rgb = bodyBgColor.match(/\d+/g);
            if (rgb && rgb.length >= 3) {
                const brightness = (parseInt(rgb[0]) * 299 + parseInt(rgb[1]) * 587 + parseInt(rgb[2]) * 114) / 1000;
                return brightness < 128 ? 'dark' : 'light';
            }
        }
        
        return 'light';
    }
}

====================================================================
FILE: D/export_chat.css
====================================================================
/* Export Chat Modal Styles */
.export-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Google Sans', 'Roboto', sans-serif;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.export-modal.show {
    opacity: 1;
}

.export-modal .modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
}

.export-modal .modal-container {
    background: var(--gf-bg-primary);
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid var(--gf-border-color);
    max-height: 90vh;
    overflow: hidden;
    position: relative;
    animation: modalSlideIn 0.3s ease-out;
    transform: scale(0.95);
    transition: transform 0.3s ease;
}

.export-modal.show .modal-container {
    transform: scale(1);
}

@keyframes modalSlideIn {
    from {
        opacity: 0;
        transform: translateY(-20px) scale(0.95);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.export-modal .modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 20px 24px 16px 24px;
    border-bottom: 1px solid var(--gf-border-color);
}

.export-modal .modal-header h2 {
    margin: 0;
    font-size: 20px;
    font-weight: 500;
    color: var(--gf-text-primary);
}

.export-modal .close-btn {
    background: none;
    border: none;
    color: var(--gf-text-secondary);
    font-size: 24px;
    cursor: pointer;
    padding: 4px;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.export-modal .close-btn:hover {
    background-color: var(--gf-hover-bg);
    color: var(--gf-text-primary);
}

.export-modal .modal-body {
    padding: 24px;
    overflow-y: auto;
    max-height: calc(90vh - 120px);
}

/* Export Modal Content */
.export-modal-content {
    color: var(--gf-text-primary);
}

.export-modal-content .export-section {
    margin-bottom: 24px;
}

.export-modal-content .export-section:last-child {
    margin-bottom: 0;
}

.export-modal-content h3 {
    margin: 0 0 16px 0;
    font-size: 16px;
    font-weight: 500;
    color: var(--gf-text-primary);
}

/* Chat Selection Styles */
.chat-selection-content {
    color: var(--gf-text-primary);
}

.chat-selection-section {
    margin-bottom: 24px;
}

.chat-search-container {
    margin-bottom: 16px;
}

.chat-search-input {
    width: 100%;
    padding: 12px 16px;
    border: 1px solid var(--gf-border-color);
    border-radius: 8px;
    background: var(--gf-bg-primary);
    color: var(--gf-text-primary);
    font-size: 14px;
    font-family: inherit;
    transition: border-color 0.2s ease;
    box-sizing: border-box;
}

.chat-search-input:focus {
    outline: none;
    border-color: var(--gf-blue-accent);
    box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
}

.chat-search-input::placeholder {
    color: var(--gf-text-secondary);
}

.chat-list-container {
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid var(--gf-border-color);
    border-radius: 8px;
    background: var(--gf-bg-primary);
}

.chat-list {
    padding: 0;
    margin: 0;
}

.chat-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px;
    border-bottom: 1px solid var(--gf-border-color);
    cursor: pointer;
    transition: all 0.2s ease;
    background: var(--gf-bg-primary);
}

.chat-item:last-child {
    border-bottom: none;
}

.chat-item:hover {
    background: var(--gf-hover-bg);
}

.chat-item.selected {
    background: rgba(26, 115, 232, 0.08);
    border-left: 3px solid var(--gf-blue-accent);
}

.chat-icon {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--gf-bg-secondary);
    border-radius: 8px;
    color: var(--gf-text-secondary);
}

.chat-info {
    flex: 1;
    min-width: 0;
}

.chat-title {
    font-weight: 500;
    font-size: 14px;
    color: var(--gf-text-primary);
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.chat-preview {
    font-size: 12px;
    color: var(--gf-text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.chat-date {
    font-size: 12px;
    color: var(--gf-text-secondary);
    white-space: nowrap;
}

.no-chats-message {
    padding: 32px 16px;
    text-align: center;
    color: var(--gf-text-secondary);
}

.no-chats-message p {
    margin: 0;
    font-size: 14px;
}

.chat-selection-actions {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
    padding-top: 16px;
    border-top: 1px solid var(--gf-border-color);
}

.selected-chat-info {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    background: var(--gf-bg-secondary);
    border-radius: 8px;
    margin-bottom: 16px;
    border: 1px solid var(--gf-border-color);
}

.selected-chat-label {
    font-size: 14px;
    font-weight: 500;
    color: var(--gf-text-secondary);
}

.selected-chat-title {
    font-size: 14px;
    font-weight: 500;
    color: var(--gf-text-primary);
}

/* Format Grid */
.export-format-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
}

.format-option {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px;
    border: 2px solid var(--gf-border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    background: var(--gf-bg-primary);
}

.format-option:hover {
    border-color: var(--gf-blue-accent);
    background: var(--gf-hover-bg);
}

.format-option.selected {
    border-color: var(--gf-blue-accent);
    background: rgba(26, 115, 232, 0.08);
}

.format-icon {
    font-size: 24px;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--gf-bg-secondary);
    border-radius: 8px;
}

.format-info {
    flex: 1;
}

.format-name {
    font-weight: 500;
    font-size: 14px;
    color: var(--gf-text-primary);
    margin-bottom: 2px;
}

.format-desc {
    font-size: 12px;
    color: var(--gf-text-secondary);
}

/* Settings Groups */
.setting-group {
    margin-bottom: 16px;
}

.setting-group:last-child {
    margin-bottom: 0;
}

.setting-group label {
    display: block;
    font-size: 14px;
    font-weight: 500;
    color: var(--gf-text-primary);
    margin-bottom: 8px;
}

.setting-group input[type="text"] {
    width: 100%;
    padding: 12px 16px;
    border: 1px solid var(--gf-border-color);
    border-radius: 8px;
    background: var(--gf-bg-primary);
    color: var(--gf-text-primary);
    font-size: 14px;
    font-family: inherit;
    transition: border-color 0.2s ease;
    box-sizing: border-box;
}

.setting-group input[type="text"]:focus {
    outline: none;
    border-color: var(--gf-blue-accent);
    box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
}

.setting-group input[type="text"]::placeholder {
    color: var(--gf-text-secondary);
}

/* Radio Options */
.theme-options,
.orientation-options,
.export-range-options {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    font-size: 14px;
    color: var(--gf-text-primary);
}

.radio-option input[type="radio"] {
    margin: 0;
    accent-color: var(--gf-blue-accent);
}

.radio-option span {
    font-size: 14px;
}

/* Checkbox Option */
.checkbox-option {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    font-size: 14px;
    color: var(--gf-text-primary);
}

.checkbox-option input[type="checkbox"] {
    margin: 0;
    accent-color: var(--gf-blue-accent);
}

.checkbox-option span {
    font-size: 14px;
}

/* Export Actions */
.export-actions {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
    padding-top: 16px;
    border-top: 1px solid var(--gf-border-color);
}

.btn-primary,
.btn-secondary {
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    border: none;
    font-family: inherit;
}

.btn-primary {
    background: var(--gf-blue-accent);
    color: white;
}

.btn-primary:hover:not(:disabled) {
    background: #1a5fdb;
    transform: translateY(-1px);
}

.btn-primary:disabled {
    background: var(--gf-text-secondary);
    cursor: not-allowed;
    transform: none;
}

.btn-secondary {
    background: var(--gf-bg-secondary);
    color: var(--gf-text-primary);
    border: 1px solid var(--gf-border-color);
}

.btn-secondary:hover {
    background: var(--gf-hover-bg);
}

/* Success Notification */
.export-success-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: #4caf50;
    color: white;
    padding: 16px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 10001;
    animation: notificationSlideIn 0.3s ease-out;
    display: flex;
    align-items: center;
    gap: 8px;
}

@keyframes notificationSlideIn {
    from {
        opacity: 0;
        transform: translateX(100%);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* Dark Theme Overrides */
.dark-theme .export-modal .modal-container {
    background: #1a1a1a;
    border-color: #333;
}

.dark-theme .format-option {
    background: #2a2a2a;
    border-color: #444;
}

.dark-theme .format-option:hover {
    background: #333;
}

.dark-theme .format-option.selected {
    background: rgba(26, 115, 232, 0.15);
}

.dark-theme .format-icon {
    background: #333;
}

.dark-theme .setting-group input[type="text"] {
    background: #2a2a2a;
    border-color: #444;
    color: #fff;
}

.dark-theme .setting-group input[type="text"]:focus {
    border-color: var(--gf-blue-accent);
}

.dark-theme .btn-secondary {
    background: #2a2a2a;
    border-color: #444;
    color: #fff;
}

.dark-theme .btn-secondary:hover {
    background: #333;
}

/* Responsive Design */
@media (max-width: 768px) {
    .export-modal .modal-container {
        width: 95%;
        margin: 20px;
    }

    .export-format-grid {
        grid-template-columns: 1fr;
    }

    .theme-options,
    .orientation-options,
    .export-range-options {
        flex-direction: column;
        gap: 8px;
    }

    .export-actions {
        flex-direction: column;
    }

    .btn-primary,
    .btn-secondary {
        width: 100%;
        text-align: center;
    }
}

/* Scrollbar Styling */
.export-modal .modal-body::-webkit-scrollbar {
    width: 6px;
}

.export-modal .modal-body::-webkit-scrollbar-track {
    background: transparent;
}

.export-modal .modal-body::-webkit-scrollbar-thumb {
    background: var(--gf-border-color);
    border-radius: 3px;
}

.export-modal .modal-body::-webkit-scrollbar-thumb:hover {
    background: var(--gf-text-secondary);
}

====================================================================
FILE: D/injector.js
====================================================================
// Gemini Folders - REFACTORED injector.js
(function() {
    'use strict';

    // --- CONSTANTS AND STATE ---
    const INJECTOR_HOST_ID = 'gemini-folders-injector-host';
    const STORAGE_KEY = 'geminiFoldersData';

    // Selectors for the deletion logic, adapted from the source extension
    const DELETE_BUTTON_SELECTORS = ['button[data-test-id="delete-button"]', 'button[aria-label*="delete"]', 'button:contains("Delete")', "button.delete-btn"];
    const CONFIRM_BUTTON_SELECTORS = ['button[data-test-id="confirm-button"]', 'button:contains("Delete")', 'button:contains("Confirm")', 'button[aria-label*="confirm"]', "button.confirm-btn"];
    const ACTIONS_MENU_SELECTORS = ['button[data-test-id="actions-menu-button"]', 'button[aria-label*="actions"]', 'button[aria-label*="menu"]', "button.menu-button", "button.actions-button"];
    const OVERLAY_CONTAINER_SELECTORS = ["div.cdk-overlay-container", '[role="dialog"]', ".modal-container", ".overlay-container"];

    let hostElement = null;
    let shadow = null;
    let currentTheme = 'light';
    let isModalOpen = false;
    let promptLibraryInstance;
    let voiceModeInstance;
    let chatExporterInstance;

    // State object to hold dynamic data, similar to the target's storage module.
    let state = {
        folders: [],
        settings: {
            hideFolderedChats: false
        },
        selectedItems: [],
        modalType: null, // e.g., 'MANAGE_FOLDERS', 'ADD_FOLDER'
    };

    // --- ORIGINAL UTILITY FUNCTIONS (Unchanged) ---
    function generateUUID() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }
    function delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    // --- NEW HELPER FUNCTIONS (for Bulk Delete) ---
    function delayMs(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function findElement(selectors, parent = document) {
        if (!parent) return null;
        for (const selector of selectors) {
            try {
                const element = parent.querySelector(selector);
                if (element) return element;
            } catch (e) {
                console.warn(`[Gemini Toolbox] Invalid selector "${selector}":`, e);
            }
        }
        return null;
    }

    function waitForElement(selectors, parent = document, timeout = 7000) {
        return new Promise((resolve, reject) => {
            const element = findElement(selectors, parent);
            // Check if element is not only present but also visible and interactive
            if (element && element.offsetParent !== null && !element.disabled) {
                return resolve(element);
            }

            let elapsedTime = 0;
            const interval = 150;
            const timer = setInterval(() => {
                elapsedTime += interval;
                const foundElement = findElement(selectors, parent);
                if (foundElement && foundElement.offsetParent !== null && !foundElement.disabled) {
                    clearInterval(timer);
                    resolve(foundElement);
                } else if (elapsedTime >= timeout) {
                    clearInterval(timer);
                    console.error(`[Gemini Toolbox] Element not actionable within ${timeout}ms. Tried selectors:`, selectors);
                    reject(new Error(`Element not actionable within ${timeout}ms`));
                }
            }, interval);
        });
    }


    async function loadData() {
        try {
            const result = await chrome.storage.local.get(STORAGE_KEY);
            // Initialize with default structure if it doesn't exist
            state.folders = result[STORAGE_KEY]?.folders || [];
            state.settings = result[STORAGE_KEY]?.settings || { hideFolderedChats: false };
        } catch (error) {
            console.error("Gemini Folders: Error loading data", error);
            state.folders = [];
            state.settings = { hideFolderedChats: false };
        }
    }

    async function saveData() {
        try {
            // Only save the necessary parts of the state
            const dataToSave = { 
                folders: state.folders,
                settings: state.settings 
            };
            await chrome.storage.local.set({ [STORAGE_KEY]: dataToSave });
        } catch (error) {
            console.error("Gemini Folders: Error saving data", error);
        }
    }
    
    function getChatIdFromElement(chatElement) {
        if (!chatElement) return null;
        const jslog = chatElement.getAttribute('jslog');
        if (jslog) {
            const match = jslog.match(/BardVeMetadataKey:\[[^\]]*\["([^"]+)"/);
            if (match && match[1]) {
                return match[1];
            }
        }
        const testId = chatElement.getAttribute('data-test-id');
        if (testId && testId.startsWith('conversation_c_')) {
            return testId.substring('conversation_'.length);
        }
        return null;
    }

    function getAllConversationElements() {
        return Array.from(document.querySelectorAll('conversations-list div[data-test-id="conversation"]'));
    }

    function getTextColorForBackground(hexColor) {
        if (!hexColor || hexColor.length < 7) return 'var(--gf-text-primary)'; // Default if invalid

        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);

        // Formula for perceived brightness (YIQ)
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;

        // Return black for light backgrounds, white for dark backgrounds
        return brightness > 155 ? '#000000' : '#FFFFFF';
    }

    // --- THEME & STYLING (Slightly modified to use a single CSS block) ---
    function detectTheme() {
        const body = document.body;
        if (body.classList.contains('dark-theme') || body.classList.contains('dark_mode_toggled')) return 'dark';
        const htmlTheme = document.documentElement.getAttribute('data-theme');
        if (htmlTheme === 'dark') return 'dark';
        const bodyBgColor = window.getComputedStyle(body).backgroundColor;
        if (bodyBgColor) {
            const rgb = bodyBgColor.match(/\d+/g);
            if (rgb && rgb.length >= 3) {
                const brightness = (parseInt(rgb[0]) * 299 + parseInt(rgb[1]) * 587 + parseInt(rgb[2]) * 114) / 1000;
                return brightness < 128 ? 'dark' : 'light';
            }
        }
        return 'light';
    }

    function createGlobalStyles() {
        if (!shadow) return;
        const styleElement = document.createElement('style');
        // REFACTORED: We'll use a single, large CSS block that contains all styles
        // for the modals, lists, buttons, etc., mimicking the target UI.
        styleElement.textContent = `
            :host { 
                /* Light Theme */
                --gf-bg-primary-light: #FFFFFF;
                --gf-text-primary-light: #202124;
                --gf-danger-light: #d93025;
                --gf-border-light: #dadce0;
                --gf-hover-light: #f1f3f4;
                --gf-blue-light: #1a73e8;
                --gf-bg-secondary-light: #f0f4f9;
                --gf-border-color-light: #dadce0;
                --gf-text-primary-light: #1f1f1f;
                --gf-text-secondary-light: #5f6368;
                --gf-accent-primary-light: #1a73e8;
                --gf-accent-danger-light: #d93025;
                --gf-bg-input-light: #ffffff;

                /* Dark Theme */
                --gf-bg-primary-dark: #131314;
                --gf-bg-secondary-dark: #2d2d2f;
                --gf-border-color-dark: #5f6368;
                --gf-text-primary-dark: #e3e3e3;
                --gf-text-secondary-dark: #9aa0a6;
                --gf-accent-primary-dark: #8ab4f8;
                --gf-accent-danger-dark: #f28b82;
                --gf-bg-input-dark: #2d2d2f;

                /* Default to dark theme from screenshot */
                --gf-text-primary: var(--gf-text-primary-dark);
                --gf-text-secondary: #969ba1;
                --gf-bg-primary: var(--gf-bg-primary-dark);
                --gf-hover-bg: var(--gf-hover-dark);
                --gf-border-color: var(--gf-border-dark);
                --gf-danger: var(--gf-danger-dark);
                --gf-blue-accent: var(--gf-blue-dark);
            }
            .sidebar-tab { 
                display: flex; align-items: center; gap: 12px;
                padding: 10px; margin: 4px 0; border-radius: 8px;
                cursor: pointer; font-size: 14px; color: var(--gf-text-primary);
                position: relative;
            }
            .sidebar-tab:hover { background-color: var(--gf-hover-bg); }

            /* Gemini Toolbox Button and Dropdown */
            .toolbox-button {
                display: flex; align-items: center; gap: 8px;
                width: 100%; padding: 0; border: none; background: none;
                cursor: pointer; font-size: 14px; color: var(--gf-text-primary);
            }
            .toolbox-button:hover { background-color: var(--gf-hover-bg); }

            .dropdown-arrow {
                margin-left: auto;
                transition: transform 0.2s ease;
            }
            .dropdown-arrow.rotated {
                transform: rotate(180deg);
            }

            .toolbox-dropdown {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background-color: var(--gf-bg-primary);
                border: 1px solid var(--gf-border-color);
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 1000;
                overflow: hidden;
            }

            .dropdown-item {
                display: flex; align-items: center; gap: 8px;
                padding: 12px; cursor: pointer;
                color: var(--gf-text-primary);
                font-size: 14px;
                transition: background-color 0.2s ease;
            }
            .dropdown-item:hover {
                background-color: var(--gf-hover-bg);
            }

            /* Modal Backdrop */
            .infi-chatgpt-modal {
                position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
                background-color: rgba(0,0,0,0.65); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            }
            /* Modal Content Box */
            .modal-content {
                width: 600px;
                background-color: var(--gf-bg-primary);
                border-radius: 12px; border: 1px solid var(--gf-border-color);
                box-shadow: 0 5px 20px rgba(0,0,0,0.4);
                color: var(--gf-text-primary);
                display: flex; flex-direction: column;
                max-height: 80vh;
            }
            .modal-header {
                display: flex; justify-content: space-between; align-items: center;
                padding: 20px;
            }
            .modal-header h2 { margin: 0; font-size: 20px; font-weight: 500; }
            .modal-body { 
                padding: 0 20px 20px 20px; 
                display: flex; flex-direction: column;
                flex-grow: 1;
                overflow-y: hidden;
            }
             .infi-chatgpt-manageTabs-content {
                display: flex; flex-direction: column;
                height: 100%;
            }
            #folder-list-container {
                flex-grow: 1;
                overflow-y: auto;
                margin-top: 16px;
            }
             .infi-chatgpt-manageTabs-buttonsContainer {
                margin-top: auto; /* Pushes to the bottom */
                padding-top: 16px;
                text-align: right;
            }
            /* Buttons */
            .button {
                border: none; border-radius: 6px; padding: 8px 14px;
                font-size: 14px; cursor: pointer;
            }
            .primary { background-color: #8AB4F8; color: #202124; }
            .secondary { background-color: var(--gf-hover-bg); color: var(--gf-text-primary); }
            .danger { background-color: var(--gf-danger); color: #202124; }
            .icon-btn { background: none; border: none; cursor: pointer; color: var(--gf-text-secondary); }

            /* Form & List Styles */
            input[type="text"], input[type="search"] {
                width: 100%;
                padding: 8px 12px;
                background-color: var(--gf-bg-input);
                border: 1px solid var(--gf-border-color);
                color: var(--gf-text-primary);
                border-radius: 6px;
                box-sizing: border-box; /* Important */
                font-size: 14px;
            }
            .list-item {
                display: flex; align-items: center; gap: 10px;
                padding: 8px; border-radius: 6px; margin-bottom: 4px;
            }
            .list-item:hover { background-color: var(--gf-hover-bg); }
            .list-item .item-title {
                flex-grow: 1;
                cursor: pointer;
            }

            .list-item .item-controls {
                display: flex;
                align-items: center;
                gap: 8px;
                color: var(--gf-text-secondary);
            }
            
            .list-item .add-subfolder-btn {
                opacity: 0;
                transition: opacity 0.2s ease-in-out;
            }
            
            .list-item:hover .add-subfolder-btn {
                opacity: 1;
            }

            .icon-btn {
                background: none;
                border: none;
                cursor: pointer;
                color: var(--gf-text-secondary);
            }

            /* --- NEW: Bulk Delete Modal Specific Styles --- */
            #bulk-delete-list {
                margin-top: 16px;
                max-height: 400px;
                overflow-y: auto;
                padding-right: 10px; /* For scrollbar */
            }
            .bulk-delete-item {
                display: flex;
                align-items: center;
                padding: 8px;
                border-radius: 6px;
                margin-bottom: 4px;
            }
             .bulk-delete-item:hover {
                background-color: var(--gf-hover-bg);
            }
            .bulk-delete-item input[type="checkbox"] {
                margin-right: 12px;
                width: 18px;
                height: 18px;
            }
            .bulk-delete-item label {
                font-size: 14px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
             #bulk-delete-controls {
                padding-top: 16px;
                border-top: 1px solid var(--gf-border-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            #bulk-delete-select-all-container {
                display: flex;
                align-items: center;
            }
             #bulk-delete-status {
                font-size: 14px;
                color: var(--gf-text-secondary);
            }

            .light-theme {
                --gf-bg-primary: var(--gf-bg-primary-light);
                --gf-text-primary: var(--gf-text-primary-light);
                --gf-text-secondary: var(--gf-text-secondary-light);
                --gf-accent-primary: var(--gf-accent-primary-light);
                --gf-accent-danger: var(--gf-accent-danger-light);
                --gf-bg-input: var(--gf-bg-input-light);
            }
            .dark-theme {
                --gf-bg-primary: var(--gf-bg-primary-dark);
                --gf-bg-secondary: var(--gf-bg-secondary-dark);
                --gf-border-color: var(--gf-border-color-dark);
                --gf-text-primary: var(--gf-text-primary-dark);
                --gf-text-secondary: var(--gf-text-secondary-dark);
                --gf-accent-primary: var(--gf-accent-primary-dark);
                --gf-accent-danger: var(--gf-accent-danger-dark);
                --gf-bg-input: var(--gf-bg-input-dark);
            }
            .dark-theme .danger {
                background-color: var(--gf-accent-danger-dark);
                color: #202124;
            }

            /* Chat Exporter Styles */
            .gemini-modal-backdrop {
                position: fixed;
                z-index: 2000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(4px);
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .gemini-modal-content {
                background-color: var(--gf-bg-primary);
                color: var(--gf-text-primary);
                border: 1px solid var(--gf-border-color);
                width: 90%;
                max-width: 600px;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                display: flex;
                flex-direction: column;
                max-height: 80vh;
            }

            .gemini-modal-header {
                padding: 16px 24px;
                border-bottom: 1px solid var(--gf-border-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-shrink: 0;
            }

            .gemini-modal-header h2 {
                margin: 0;
                font-size: 20px;
                font-weight: 500;
            }

            .gemini-modal-close-btn {
                background: none;
                border: none;
                color: var(--gf-text-secondary);
                font-size: 28px;
                font-weight: 300;
                cursor: pointer;
                line-height: 1;
                padding: 4px;
                border-radius: 50%;
                transition: all 0.2s;
            }
            .gemini-modal-close-btn:hover {
                background-color: var(--gf-hover-bg);
                color: var(--gf-text-primary);
            }

            .gemini-modal-body {
                padding: 16px 24px;
                overflow-y: auto;
                flex-grow: 1;
            }

            .gemini-modal-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .gemini-modal-list-item {
                padding: 12px 16px;
                background-color: var(--gf-bg-secondary);
                border-radius: 8px;
                cursor: pointer;
                transition: background-color 0.2s;
                font-size: 14px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .gemini-modal-list-item:hover {
                background-color: var(--gf-hover-bg);
            }

            .gemini-modal-empty-state, .gemini-modal-loader {
                text-align: center;
                padding: 40px;
                color: var(--gf-text-secondary);
                font-style: italic;
            }

            .format-selector {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 12px;
            }

            .format-btn {
                padding: 12px;
                font-size: 14px;
                font-weight: 500;
                border-radius: 8px;
                cursor: pointer;
                background-color: var(--gf-bg-secondary);
                color: var(--gf-text-primary);
                border: 1px solid var(--gf-border-color);
                transition: all 0.2s;
            }
            .format-btn:hover {
                background-color: var(--gf-accent-primary);
                color: var(--gf-bg-primary);
                border-color: var(--gf-accent-primary);
            }

            #exporter-overlay {
                position: fixed;
                top: 0; left: 0; width: 100vw; height: 100vh;
                background-color: rgba(0,0,0,0.75);
                z-index: 2147483647;
                display: flex;
                justify-content: center;
                align-items: center;
                color: #fff;
                font-family: 'Google Sans', sans-serif;
            }
            .exporter-overlay-content {
                text-align: center;
            }
            .exporter-spinner {
                border: 4px solid rgba(255, 255, 255, 0.2);
                border-top: 4px solid #fff;
                border-radius: 50%;
                width: 50px;
                height: 50px;
                animation: spin 1s linear infinite;
                margin: 0 auto 20px auto;
            }
            .exporter-message {
                font-size: 18px;
                font-weight: 500;
            }

            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        `;
        shadow.appendChild(styleElement);
        applyThemeStyles();
    }

    function applyThemeStyles() {
        if (!hostElement) return;
        currentTheme = detectTheme();
        const isDark = currentTheme === 'dark';

        hostElement.style.setProperty('--gf-bg-primary', isDark ? 'var(--gf-bg-primary-dark)' : 'var(--gf-bg-primary-light)');
        hostElement.style.setProperty('--gf-text-primary', isDark ? 'var(--gf-text-primary-dark)' : 'var(--gf-text-primary-light)');
        hostElement.style.setProperty('--gf-danger', isDark ? 'var(--gf-danger-dark)' : 'var(--gf-danger-light)');
        hostElement.style.setProperty('--gf-border-color', isDark ? 'var(--gf-border-dark)' : 'var(--gf-border-light)');
        hostElement.style.setProperty('--gf-hover-bg', isDark ? 'var(--gf-hover-dark)' : 'var(--gf-hover-light)');
        hostElement.style.setProperty('--gf-blue-accent', isDark ? 'var(--gf-blue-dark)' : 'var(--gf-blue-light)');
        hostElement.style.setProperty('--gf-text-secondary', isDark ? 'var(--gf-text-secondary-dark)' : 'var(--gf-text-secondary-light)');
        hostElement.style.setProperty('--gf-accent-primary', isDark ? 'var(--gf-accent-primary-dark)' : 'var(--gf-accent-primary-light)');
        hostElement.style.setProperty('--gf-accent-danger', isDark ? 'var(--gf-accent-danger-dark)' : 'var(--gf-accent-danger-light)');
        hostElement.style.setProperty('--gf-bg-input', isDark ? 'var(--gf-bg-input-dark)' : 'var(--gf-bg-input-light)');
    }

    // --- NEW: UI COMPONENT GENERATION (HTML Templates) ---
    // These functions replicate the HTML structure from our target UI analysis.

    function getSidebarTabHTML() {
        return `
            <div id="gemini-toolbox-container" class="sidebar-tab">
                <div id="gemini-toolbox-btn" class="toolbox-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10 4H4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H20C21.1046 20 22 19.1046 22 18V8C22 6.89543 21.1046 6 20 6H12L10 4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                    <span>Gemini Toolbox</span>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="dropdown-arrow">
                        <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div id="gemini-toolbox-dropdown" class="toolbox-dropdown" style="display: none;">
                    <div id="manage-folders-link" class="dropdown-item">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M10 4H4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H20C21.1046 20 22 19.1046 22 18V8C22 6.89543 21.1046 6 20 6H12L10 4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Manage Folders</span>
                    </div>
                    <div id="prompt-library-link" class="dropdown-item">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M4 19.5A2.5 2.5 0 0 1 1.5 17V7A2.5 2.5 0 0 1 4 4.5h16A2.5 2.5 0 0 1 22.5 7v10a2.5 2.5 0 0 1-2.5 2.5H4z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M8 10h8M8 14h5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Prompt Library</span>
                    </div>
                    <div id="word-counter-link" class="dropdown-item">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" stroke="currentColor" stroke-width="2"/>
                            <polyline points="14,2 14,8 20,8" stroke="currentColor" stroke-width="2"/>
                            <line x1="16" y1="13" x2="8" y2="13" stroke="currentColor" stroke-width="2"/>
                            <line x1="16" y1="17" x2="8" y2="17" stroke="currentColor" stroke-width="2"/>
                            <polyline points="10,9 9,9 8,9" stroke="currentColor" stroke-width="2"/>
                        </svg>
                        <span>Word Counter</span>
                    </div>
                    <div id="voice-mode-link" class="dropdown-item">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3zm6 9v2a7 7 0 0 1-14 0v-2H3v2a8 8 0 0 0 7 7.93V21h2v-2.07A8 8 0 0 0 21 12v-2h-3z" fill="currentColor"/>
                        </svg>
                        <span>Voice Mode</span>
                    </div>
                    <div id="voice-settings-link" class="dropdown-item">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="2"/>
                            <path d="M12 1v6m0 6v6m11-5l-6-3.5 6-3.5M1 12l6 3.5L1 15.5" stroke="currentColor" stroke-width="2"/>
                        </svg>
                        <span>Voice Settings</span>
                    </div>
                    <div id="bulk-delete-link" class="dropdown-item">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0v12m4-12v12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Bulk Delete</span>
                    </div>
                    <div id="export-chat-link" class="dropdown-item">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M14 2H6C4.89543 2 4 2.89543 4 4V20C4 21.1046 4.89543 22 6 22H18C19.1046 22 20 21.1046 20 20V8L14 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M14 2V8H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M10.5 15.5C10.5 16.3284 9.82843 17 9 17H7.5C6.67157 17 6 16.3284 6 15.5V12.5C6 11.6716 6.67157 11 7.5 11H9C9.82843 11 10.5 11.6716 10.5 12.5V13" stroke="currentColor" stroke-width="2"/>
                            <path d="M13.5 17V11H15.5C16.3284 11 17 11.6716 17 12.5V14.5C17 15.3284 16.3284 16 15.5 16H13.5" stroke="currentColor" stroke-width="2"/>
                            <path d="M17 13.5H13.5" stroke="currentColor" stroke-width="2"/>
                        </svg>
                        <span>Export Chat</span>
                    </div>
                </div>
            </div>
        `;
    }

    function getManageFoldersModalHTML() {
        const folderTreeHTML = renderFolderTree(null, 0);

        function renderFolderTree(parentId, level) {
            let html = '';
            const children = state.folders.filter(f => f.parentId === parentId);
    
            children.forEach(folder => {
                html += `
                    <div class="list-item" data-folder-id="${folder.id}" style="margin-left: ${level * 20}px;">
                        <span class="folder-icon"></span>
                        <span class="item-title">${folder.name}</span>
                        <div class="item-controls">
                            <span>(${folder.chatIds?.length || 0})</span>
                             <button class="icon-btn add-chats-btn" data-folder-id="${folder.id}" title="Add Chats">+</button>
                             <button class="icon-btn add-subfolder-btn" data-parent-id="${folder.id}" title="Add Subfolder">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder-plus"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line></svg>
                            </button>
                             <button class="icon-btn delete-folder-btn" data-folder-id="${folder.id}" title="Delete Folder">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-trash-2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                        </div>
                    </div>
                `;
                // Recursive call for children
                html += renderFolderTree(folder.id, level + 1);
            });
            return html;
        }
    
        return `
            <div class="modal-header">
                <h2>Manage Folders</h2>
                <button class="icon-btn" id="close-modal-btn">√ó</button>
            </div>
            <div class="modal-body">
                <div class="infi-chatgpt-manageTabs-content">
                    <div style="display: flex; gap: 8px;">
                        <button class="button primary" id="add-folder-btn">Add Folder</button>
                        <input type="search" id="search-folders-input" placeholder="Search folders..." style="flex-grow: 1;">
                </div>
                <div id="folder-list-container">
                        ${renderFolderTree(null, 0)}
                </div>
                    <div class="infi-chatgpt-manageTabs-buttonsContainer">
                         <div style="display: flex; align-items: center; justify-content: flex-end; gap: 8px;">
                            <label for="hide-foldered-toggle">Hide Foldered Chats</label>
                            <input type="checkbox" id="hide-foldered-toggle" ${state.settings.hideFolderedChats ? 'checked' : ''} />
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function getFolderItemHTML(folder) {
        const selected = state.selectedItems.includes(folder.id);
        return `
            <div class="list-item folder-item" data-id="${folder.id}">
                <input type="checkbox" class="item-checkbox" data-id="${folder.id}" ${selected ? 'checked' : ''}>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 4H4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H20C21.1046 20 22 19.1046 22 18V8C22 6.89543 21.1046 6 20 6H12L10 4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                <span class="item-title">${folder.name}</span>
                <span class="item-count" style="margin-left: auto; color: var(--gf-text-secondary);">(${folder.chatIds.length})</span>
                <button class="add-chats-btn icon-btn" data-folder-id="${folder.id}" title="Add chats to folder">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 5V19M5 12H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
            </div>
        `;
    }

    function getAddFolderModalHTML(isEdit = false, folderName = '') {
        const title = isEdit ? 'Edit Folder Name' : 'Add New Folder';
        const buttonText = isEdit ? 'Save Changes' : 'Create Folder';
        return `
            <form id="add-folder-form" style="display: flex; flex-direction: column; gap: 16px;">
                <input type="text" id="folder-name-input" value="${folderName}" placeholder="Enter folder name" required>
                <div style="display: flex; justify-content: flex-end; gap: 8px;">
                    <button type="button" id="cancel-folder-btn" class="button secondary">Cancel</button>
                    <button type="button" id="save-folder-btn" class="button primary">${buttonText}</button>
                </div>
            </form>
        `;
    }
    
    function getConfirmDeleteModalHTML() {
        return `<p>Are you sure you want to delete this folder and all its contents? This action cannot be undone.</p>`;
    }

    function getBulkDeleteModalHTML() {
        // Recursive function to render deletable tree
        function renderDeletableTree(parentId, level) {
            let html = '';
            const children = state.folders.filter(f => f.parentId === parentId);
            
            children.forEach(folder => {
                const chatCount = folder.chatIds?.length || 0;
                html += `
                    <div class="bulk-delete-item" style="margin-left: ${level * 20}px;">
                        <input type="checkbox" id="del-folder-${folder.id}" class="bulk-delete-checkbox" data-type="folder" data-id="${folder.id}">
                        <label for="del-folder-${folder.id}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 8px;">
                                <path d="M10 4H4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H20C21.1046 20 22 19.1046 22 18V8C22 6.89543 21.1046 6 20 6H12L10 4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            ${folder.name} (${chatCount} chats)
                        </label>
                    </div>
                `;
                
                // Recursively render subfolders
                html += renderDeletableTree(folder.id, level + 1);
            });
            
            return html;
        }

        // Render folder tree
        const folderTreeHTML = renderDeletableTree(null, 0);
        
        // Get unassigned chats
        const assignedChatIds = new Set();
        state.folders.forEach(folder => {
            folder.chatIds?.forEach(chatId => assignedChatIds.add(chatId));
        });
        
        const conversations = getAllConversationElements();
        const unassignedChatsHTML = conversations.map((conv, index) => {
            const titleElement = conv.querySelector('.conversation-title');
            const title = titleElement ? titleElement.textContent.trim() : `Conversation ${index + 1}`;
            const chatId = getChatIdFromElement(conv) || `chat-index-${index}`;
            
            // Only include unassigned chats
            if (chatId && assignedChatIds.has(chatId)) {
                return '';
            }
            
        return `
                <div class="bulk-delete-item">
                    <input type="checkbox" id="del-check-${chatId}" class="bulk-delete-checkbox" data-type="chat" data-chat-id="${chatId}">
                    <label for="del-check-${chatId}">${title}</label>
                </div>
            `;
        }).filter(html => html !== '').join('');

        const listHTML = folderTreeHTML + (unassignedChatsHTML ? `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--gf-border-color);">
                <h4 style="margin: 0 0 8px 0; color: var(--gf-text-secondary);">Unassigned Chats</h4>
                ${unassignedChatsHTML}
            </div>
        ` : '');

        return `
            <div id="bulk-delete-list">
                ${listHTML || '<p>No folders or conversations found.</p>'}
            </div>
            <div id="bulk-delete-controls">
                <div id="bulk-delete-select-all-container">
                    <input type="checkbox" id="bulk-delete-select-all">
                    <label for="bulk-delete-select-all" style="margin-left: 8px;">Select All</label>
                </div>
                <span id="bulk-delete-status"></span>
                <button id="start-bulk-delete-btn" class="button danger">Start Bulk Delete</button>
            </div>
        `;
    }

    // --- NEW: HTML Generator for the Add Chats Modal ---
    function getAddChatsModalHTML(folder, unassignedChats) {
        let chatListHTML = '';
        if (unassignedChats.length > 0) {
            chatListHTML = unassignedChats.map(chat => `
                <div class="list-item chat-item">
                    <input type="checkbox" class="chat-select-checkbox" data-chat-id="${chat.id}">
                    <span class="item-title">${chat.title}</span>
                </div>
            `).join('');
        } else {
            chatListHTML = '<p style="color: var(--gf-text-secondary); text-align: center; margin-top: 20px;">No available chats to add.</p>';
        }

        return `
            <div id="add-chats-list-container" style="max-height: 40vh; overflow-y: auto;">
                ${chatListHTML}
            </div>
            <div class="modal-buttons">
                <button type="button" id="cancel-add-chats" class="button secondary">Cancel</button>
                <button type="button" id="save-add-chats" class="button primary">Add Selected</button>
            </div>
        `;
    }

    // --- NEW: MODAL MANAGEMENT SYSTEM ---

    function openModal(id, title, contentHTML, width = 600) {
        if (isModalOpen) {
            closeModal();
        }

        hostElement = document.createElement('div');
        hostElement.id = INJECTOR_HOST_ID;
        document.body.appendChild(hostElement);
        shadow = hostElement.attachShadow({ mode: 'open' });
        
        const modalContainer = document.createElement('div');
        modalContainer.className = 'infi-chatgpt-modal';
        modalContainer.id = id;

        let finalHTML = contentHTML;

        // Check if the provided HTML already contains a header.
        // This is a simple check; could be made more robust.
        if (!contentHTML.includes('modal-header')) {
             finalHTML = `
                <div class="modal-header">
                    <h2>${title}</h2>
                    <button class="icon-btn" id="close-modal-btn">√ó</button>
                </div>
                <div class="modal-body">
                    ${contentHTML}
            </div>
        `;
        }
        
        modalContainer.innerHTML = `
            <div class="modal-content" style="width: ${width}px;">
               ${finalHTML}
            </div>
        `;

        shadow.appendChild(modalContainer);
        createGlobalStyles(); // Apply styles AFTER content is added
        
        const closeBtn = shadow.getElementById('close-modal-btn');
        if(closeBtn) {
            closeBtn.addEventListener('click', closeModal);
        }

        isModalOpen = true;
    }

    function closeModal() {
        const modal = shadow.querySelector('.infi-chatgpt-modal');
        if (modal) {
            modal.remove();
        }
        isModalOpen = false;
        state.modalType = null;
    }

    // --- NEW & REFACTORED: LOGIC CONTROLLERS ---

    async function renderFolderList() {
        const listContainer = shadow.getElementById('folder-list-container');
        if (!listContainer) return;
        
        listContainer.innerHTML = '';
        const folders = state.folders;
        
        if (folders.length === 0) {
            listContainer.innerHTML = `<p>No folders yet. Click "Add Folder" to create one.</p>`;
            return;
        }

        folders.forEach(folder => {
            const itemHTML = getFolderItemHTML(folder);
            listContainer.innerHTML += itemHTML;
        });

        // Attach event listeners to newly rendered items
        attachFolderItemListeners();
    }
    
    function attachFolderItemListeners() {
        shadow.querySelectorAll('.folder-item').forEach(item => {
            item.addEventListener('click', handleFolderItemClick);
        });
        shadow.querySelectorAll('.item-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', handleCheckboxChange);
        });
        // --- NEW: Attach listener for the new Add Chats button ---
        shadow.querySelectorAll('.add-chats-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent folder navigation click
                const folderId = e.currentTarget.dataset.folderId;
                showAddChatsModal(folderId);
            });
        });
    }
    
    function handleFolderItemClick(e) {
        if (e.target.type === 'checkbox') return; // Don't trigger if checkbox was clicked
        const folderId = e.currentTarget.dataset.id;
        // --- REPLACED CONSOLE.LOG WITH ACTUAL NAVIGATION ---
        showManageSingleFolderModal(folderId);
    }

    function handleCheckboxChange(e) {
        const folderId = e.target.dataset.folderId;
        if (e.target.checked) {
            if (!state.selectedItems.includes(folderId)) {
                state.selectedItems.push(folderId);
            }
        } else {
            state.selectedItems = state.selectedItems.filter(id => id !== folderId);
        }
        updateRemoveButtonState();
    }
    
    function updateRemoveButtonState() {
        const removeBtn = shadow.querySelector('#remove-selected-btn');
        if (removeBtn) {
            removeBtn.disabled = state.selectedItems.length === 0;
        }
    }
    

    async function handleManageFoldersLogic() {
        const modalContent = shadow.querySelector('.modal-content');
        if (!modalContent) return;

        // Using event delegation on the modal content
        modalContent.addEventListener('click', (e) => {
            const target = e.target;

            if (target.closest('#close-modal-btn')) {
                closeModal();
            } else if (target.closest('#add-folder-btn')) {
                showAddFolderModal();
            } else if (target.closest('.add-subfolder-btn')) {
                const parentId = target.closest('.add-subfolder-btn').dataset.parentId;
                showAddFolderModal(false, null, parentId);
            } else if (target.closest('.add-chats-btn')) {
                const folderId = target.closest('.add-chats-btn').dataset.folderId;
                showAddChatsModal(folderId);
            } else if (target.closest('.delete-folder-btn')) {
                const folderId = target.closest('.delete-folder-btn').dataset.folderId;
                showConfirmDeleteModal(folderId);
            } else if (target.closest('#remove-selected-btn')) {
                showConfirmDeleteModal();
            } else if (target.closest('.item-title')) {
                const folderId = target.closest('.list-item').dataset.folderId;
                showManageSingleFolderModal(folderId);
            }
        });

        modalContent.addEventListener('change', (e) => {
            if (e.target.classList.contains('folder-checkbox')) {
                handleCheckboxChange(e);
            } else if (e.target.matches('#hide-foldered-toggle')) {
                state.settings.hideFolderedChats = e.target.checked;
                saveData();
                updateChatVisibility();
            }
        });

        const searchInput = shadow.querySelector('#search-folders-input');
        if (searchInput) {
        searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const folderItems = shadow.querySelectorAll('.list-item');
                folderItems.forEach(item => {
                const title = item.querySelector('.item-title').textContent.toLowerCase();
                    item.style.display = title.includes(searchTerm) ? 'flex' : 'none';
            });
        });
        }
        updateRemoveButtonState();
    }


    function handleAddFolderLogic(isEdit = false, folderId = null, parentId = null) {
        const form = shadow.querySelector('#add-folder-form');
        const input = shadow.querySelector('#folder-name-input');
        const saveBtn = shadow.querySelector('#save-folder-btn');
        const cancelBtn = shadow.querySelector('#cancel-folder-btn');

        if (!form || !input || !saveBtn || !cancelBtn) return;

        const handleFormSubmit = (e) => {
            e.preventDefault(); // Prevent default form submission which violates CSP
            e.stopPropagation(); // Stop the event from bubbling up

            const folderName = input.value.trim();
            if (!folderName) return;

            if (isEdit) {
                const folder = state.folders.find(f => f.id === folderId);
                if (folder) {
                    folder.name = folderName;
                }
            } else {
                state.folders.push({
                    id: generateUUID(),
                    name: folderName,
                    chatIds: [],
                    parentId: parentId || null // Use the passed parentId
                });
            }
            saveData();
            closeModal();
            showManageFoldersModal(); // Refresh main modal
        };

        form.addEventListener('submit', handleFormSubmit);
        saveBtn.addEventListener('click', handleFormSubmit);
        cancelBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeModal();
        });
        input.focus();
    }
    

    function handleAddChatsLogic(folderId) {
        const saveBtn = shadow.getElementById('save-add-chats');
        const cancelBtn = shadow.getElementById('cancel-add-chats');

        saveBtn.addEventListener('click', async () => {
            const selectedCheckboxes = shadow.querySelectorAll('.chat-select-checkbox:checked');
            const chatIdsToAdd = Array.from(selectedCheckboxes).map(cb => cb.dataset.chatId);

            if (chatIdsToAdd.length > 0) {
                const folder = state.folders.find(f => f.id === folderId);
                if (folder) {
                    const newChatIds = chatIdsToAdd.filter(id => !folder.chatIds.includes(id));
                    folder.chatIds.push(...newChatIds);
                    await saveData();
                }
            }
            closeModal();
            showManageFoldersModal(); // Re-open the main modal to show updates
        });

        cancelBtn.addEventListener('click', () => {
            closeModal();
            showManageFoldersModal(); // Go back to the main modal
        });
    }

    // --- NEW: Utility to find chats not yet in a folder ---
    async function getUnassignedChats() {
        // This function will find all chats that are not currently in ANY folder.
        const allChatElements = getAllConversationElements();
        const allChatIdsAndTitles = allChatElements.map(el => ({
            id: getChatIdFromElement(el),
            title: el.textContent.trim()
        }));

        const assignedChatIds = new Set();
        state.folders.forEach(folder => {
            folder.chatIds.forEach(chatId => assignedChatIds.add(chatId));
        });

        return allChatIdsAndTitles.filter(chat => chat.id && !assignedChatIds.has(chat.id));
    }

    // --- NEW: Get all chat IDs in a folder and its subfolders ---
    function getAllChatIdsInFolder(folderId) {
        const result = [];
        const folder = state.folders.find(f => f.id === folderId);
        
        if (folder && folder.chatIds) {
            result.push(...folder.chatIds);
        }
        
        // Recursively get chat IDs from subfolders
        const subfolders = state.folders.filter(f => f.parentId === folderId);
        subfolders.forEach(subfolder => {
            result.push(...getAllChatIdsInFolder(subfolder.id));
        });
        
        return result;
    }

    // --- NEW: Remove folders and their descendants from state ---
    function removeFolders(folderIds) {
        const foldersToRemove = new Set(folderIds);
        
        // Recursively add all descendant folders
        function addDescendants(parentId) {
            const children = state.folders.filter(f => f.parentId === parentId);
            children.forEach(child => {
                foldersToRemove.add(child.id);
                addDescendants(child.id);
            });
        }
        
        folderIds.forEach(folderId => {
            addDescendants(folderId);
        });
        
        // Filter out all folders to be removed
        state.folders = state.folders.filter(f => !foldersToRemove.has(f.id));
    }

    // --- NEW: MODAL TRIGGER FUNCTIONS ---

    function showManageFoldersModal() {
        openModal('manage-folders-modal', 'Manage Folders', getManageFoldersModalHTML());
        handleManageFoldersLogic();
    }
    
    function showAddFolderModal(isEdit = false, folderId = null, parentId = null) {
        const folder = isEdit ? state.folders.find(f => f.id === folderId) : null;
        const modalTitle = isEdit ? 'Edit Folder' : (parentId ? 'Add Subfolder' : 'Add Folder');
        openModal(
            'add-folder-modal',
             modalTitle,
             getAddFolderModalHTML(isEdit, folder ? folder.name : ''),
             400
        );
        handleAddFolderLogic(isEdit, folderId, parentId);
    }
    
    // --- NEW: Trigger for the Add Chats Modal ---
    async function showAddChatsModal(folderId) {
        const folder = state.folders.find(f => f.id === folderId);
        if (!folder) return;

        const unassignedChats = await getUnassignedChats();

        openModal(
            'add-chats-modal',
            `Add Chats to "${folder.name}"`,
            getAddChatsModalHTML(folder, unassignedChats),
            500
        );
        handleAddChatsLogic(folderId);
    }
    
    // --- NEW: Trigger for Single Folder View ---
    function showManageSingleFolderModal(folderId) {
        const folder = state.folders.find(f => f.id === folderId);
        if (!folder) return;

        openModal(
            'manage-single-folder-modal',
            `Manage "${folder.name}"`,
            getManageSingleFolderModalHTML(folder),
            500
        );
        handleManageSingleFolderLogic(folderId);
    }

    function showConfirmDeleteModal(folderId) {
        openModal(
            'confirm-delete-modal',
            'Confirm Deletion',
            getConfirmDeleteModalHTML(),
            400
        );

        const confirmBtn = shadow.querySelector('#confirm-delete-btn');
        const cancelBtn = shadow.querySelector('#cancel-delete-btn');

        confirmBtn.addEventListener('click', () => {
            const foldersToDelete = new Set([folderId]);

            // Recursive function to find all children
            function getAllChildFolderIds(parentId) {
                const children = state.folders.filter(f => f.parentId === parentId);
                children.forEach(child => {
                    foldersToDelete.add(child.id);
                    getAllChildFolderIds(child.id);
                });
            }

            // Populate the set with all nested children
            getAllChildFolderIds(folderId);

            // Filter out the folders to be deleted
            state.folders = state.folders.filter(f => !foldersToDelete.has(f.id));
            
            saveData();
            closeModal();
            showManageFoldersModal();
        });

        cancelBtn.addEventListener('click', closeModal);
    }

    function showBulkDeleteModal() {
        openModal(
            'bulk-delete-modal',
            'Bulk Delete',
            getBulkDeleteModalHTML(),
            500
        );
        handleBulkDeleteLogic(); // Attach listeners after modal is created
    }

    // --- NEW: CHAT EXPORT MODAL LOGIC ---
    function showChatExportModal() {
        // Check if modal already exists, remove if it does
        let modal = shadow.querySelector('#chat-exporter-modal');
        if (modal) modal.remove();

        // Create modal structure
        modal = document.createElement('div');
        modal.id = 'chat-exporter-modal';
        modal.className = 'gemini-modal-backdrop';
        
        modal.innerHTML = `
            <div class="gemini-modal-content">
                <div class="gemini-modal-header">
                    <h2>Select a Chat to Export</h2>
                    <button class="gemini-modal-close-btn">&times;</button>
                </div>
                <div class="gemini-modal-body">
                    <div id="chat-exporter-list" class="gemini-modal-list">
                        <div class="gemini-modal-loader">Loading chats...</div>
                    </div>
                </div>
            </div>
        `;

        shadow.appendChild(modal);

        // Populate chats
        const chatListContainer = modal.querySelector('#chat-exporter-list');
        const conversations = getAllConversationElements();
        
        if (conversations.length > 0) {
            chatListContainer.innerHTML = ''; // Clear loader
            conversations.forEach(chatEl => {
                const chatId = getChatIdFromElement(chatEl);
                // Find the title element - try multiple selectors
                const titleElement = chatEl.querySelector('.conversation-title, .title-text, .mat-button-wrapper, [data-testid="conversation-title"]');
                const titleText = titleElement?.textContent?.trim();

                if (chatId && titleText) {
                    const chatItem = document.createElement('div');
                    chatItem.className = 'gemini-modal-list-item';
                    chatItem.textContent = titleText;
                    chatItem.dataset.chatId = chatId;
                    chatListContainer.appendChild(chatItem);
                }
            });
        } else {
            chatListContainer.innerHTML = '<div class="gemini-modal-empty-state">No recent chats found.</div>';
        }

        // Add event listeners
        modal.querySelector('.gemini-modal-close-btn').onclick = () => modal.remove();
        modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        
        modal.querySelectorAll('.gemini-modal-list-item').forEach(item => {
            item.onclick = () => {
                const chatId = item.dataset.chatId;
                const chatTitle = item.textContent;
                modal.remove(); // Close this modal
                // Hand off to the exporter instance
                if (chatExporterInstance) {
                    chatExporterInstance.showFormatSelection(chatId, chatTitle);
                }
            };
        });
    }

    // --- NEW: Core Bulk Deletion Logic ---
    async function deleteSingleConversation(conversationItem, abortSignal) {
        try {
            if (abortSignal?.aborted) throw new Error("Operation aborted by user.");

            // Following the original working logic from C/scripts/delete-conversations.js
            // The conversation item is the parent element, we need to find the next sibling
            // that contains the actions menu
            const actionsWrapper = conversationItem.nextElementSibling;
            if (!actionsWrapper) {
                throw new Error("Actions wrapper (sibling to conversation item) not found.");
            }

            // Look for the three-dot menu button in the actions wrapper
            let menuButton = findElement(ACTIONS_MENU_SELECTORS, actionsWrapper);
            if (!menuButton) {
                // Fallback: try to find any button in the wrapper
                menuButton = actionsWrapper.querySelector("button");
            }
            
            if (!menuButton) {
                throw new Error("Three-dot button not found in actions wrapper.");
            }
            
            menuButton.click();
            await delayMs(150); // Wait for menu to open
            if (abortSignal?.aborted) throw new Error("Operation aborted by user.");

            // The menu appears in a global overlay container
            const overlayContainer = findElement(OVERLAY_CONTAINER_SELECTORS);
            if (!overlayContainer) {
                throw new Error("Overlay container for delete menu not found.");
            }

            // Wait for and click the main delete button inside the menu
            const deleteButton = await waitForElement(DELETE_BUTTON_SELECTORS, overlayContainer, 7000);
            if (!deleteButton) {
                throw new Error("Delete button not found in menu");
            }
            deleteButton.click();
            await delayMs(150); // Wait for confirmation dialog
            if (abortSignal?.aborted) throw new Error("Operation aborted by user.");

            // Wait for and click the final confirmation button in the dialog
            const confirmButton = await waitForElement(CONFIRM_BUTTON_SELECTORS, overlayContainer, 7000);
            if (!confirmButton) {
                throw new Error("Confirm button not found in dialog");
            }
            confirmButton.click();

            // Wait for the conversation element to be removed from the DOM
            await waitForElementToDisappear(conversationItem, 15000);

            return { status: 'success' };
        } catch (error) {
            if (error.message.includes("aborted")) {
                console.log("Deletion cancelled by user.");
            } else {
                console.error("Error during single conversation deletion:", error, "on item:", conversationItem);
            }
            // Attempt to close any lingering modals by pressing Escape
            const escapeEvent = new KeyboardEvent('keydown', { key: 'Escape', code: 'Escape', keyCode: 27, bubbles: true, cancelable: true });
            document.body.dispatchEvent(escapeEvent);
            await delayMs(100);
            return { status: 'error', error: error.message };
        }
    }

    // Helper function to wait for element to disappear (similar to original)
    function waitForElementToDisappear(element, timeout = 15000) {
        return new Promise((resolve, reject) => {
            if (!element || !document.body.contains(element)) {
                return resolve();
            }
            
            let elapsedTime = 0;
            const interval = 100;
            const timer = setInterval(() => {
                elapsedTime += interval;
                if (!document.body.contains(element) || element.offsetParent === null) {
                    clearInterval(timer);
                    resolve();
                } else if (elapsedTime >= timeout) {
                    clearInterval(timer);
                    console.error("Element did not disappear within timeout:", element);
                    reject(new Error("Element did not disappear within timeout."));
                }
            }, interval);
        });
    }


    function updateChatVisibility() {
        const allChatElements = getAllConversationElements();
        const assignedChatIds = new Set();
        
        if (state.settings.hideFolderedChats) {
            state.folders.forEach(folder => {
                folder.chatIds.forEach(chatId => assignedChatIds.add(chatId));
            });
        }

        allChatElements.forEach(el => {
            const chatId = getChatIdFromElement(el);
            if (chatId && assignedChatIds.has(chatId)) {
                el.style.display = 'none';
            } else {
                el.style.display = '';
            }
        });
    }

    function getManageSingleFolderModalHTML(folder) {
        const chatListHTML = folder.chatIds.map(chatId => {
            const chatElement = getAllConversationElements().find(el => getChatIdFromElement(el) === chatId);
            const title = chatElement ? chatElement.textContent.trim() : 'Chat not found';
            return `
                <div class="list-item chat-item" data-chat-id="${chatId}">
                    <span class="item-title">${title}</span>
                    <button class="icon-btn remove-from-folder-btn" data-chat-id="${chatId}" title="Remove from folder">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x-circle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                    </button>
                </div>
            `;
        }).join('');

        return `
            <div class="modal-header">
                <button class="icon-btn" id="back-to-folders-btn">‚Üê Back</button>
                <h2>${folder.name}</h2>
                <button class="icon-btn" id="close-modal-btn">√ó</button>
                </div>
            <div class="modal-body">
                ${chatListHTML || '<p>No chats in this folder yet.</p>'}
            </div>
        `;
    }


    function handleManageSingleFolderLogic(folderId) {
        const modalContent = shadow.querySelector('.modal-content');
        if (!modalContent) return;

        modalContent.addEventListener('click', (e) => {
            if (e.target.closest('#back-to-folders-btn')) {
                closeModal();
                showManageFoldersModal();
            } else if (e.target.closest('#close-modal-btn')) {
                closeModal();
            } else if (e.target.closest('.remove-from-folder-btn')) {
                const chatId = e.target.closest('.remove-from-folder-btn').dataset.chatId;
                const folder = state.folders.find(f => f.id === folderId);
                if (folder) {
                    folder.chatIds = folder.chatIds.filter(id => id !== chatId);
                    saveData();
                    updateChatVisibility(); // Update visibility after removing
                    // Refresh the modal
                    closeModal();
                    showManageSingleFolderModal(folderId);
                }
            } else if (e.target.closest('.chat-item')) {
                const chatId = e.target.closest('.chat-item').dataset.chatId;
                const chatElement = getAllConversationElements().find(el => getChatIdFromElement(el) === chatId);
                if (chatElement) {
                    chatElement.click();
                    closeModal();
                } else {
                    alert('Could not find the chat element to click.');
                }
            }
        });
    }

    // --- NEW: Bulk Delete Modal Event Handling ---
    function handleBulkDeleteLogic() {
        const modal = shadow.getElementById('bulk-delete-modal');
        if (!modal) return;

        const selectAllCheckbox = modal.querySelector('#bulk-delete-select-all');
        const allCheckboxes = modal.querySelectorAll('.bulk-delete-checkbox');
        const startButton = modal.querySelector('#start-bulk-delete-btn');
        const statusEl = modal.querySelector('#bulk-delete-status');

        if (!selectAllCheckbox || !startButton || !statusEl) {
            console.error("Bulk delete modal elements not found.");
            return;
        }

        // --- Event Listener for "Select All" ---
        selectAllCheckbox.addEventListener('change', () => {
            allCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
        });

        // --- Event Listener for "Start Bulk Delete" button ---
        startButton.addEventListener('click', async () => {
            const selectedCheckboxes = Array.from(allCheckboxes).filter(cb => cb.checked);
            
            if (selectedCheckboxes.length === 0) {
                statusEl.textContent = "No items selected.";
                return;
            }

            // --- NEW: Gather selections and create master chat ID list ---
            const selectedChatIds = [];
            const selectedFolderIds = [];
            
            selectedCheckboxes.forEach(checkbox => {
                if (checkbox.dataset.type === 'folder') {
                    selectedFolderIds.push(checkbox.dataset.id);
                } else if (checkbox.dataset.type === 'chat') {
                    selectedChatIds.push(checkbox.dataset.chatId);
                }
            });

            // Create master set of all chat IDs to delete
            const allChatIdsToDelete = new Set(selectedChatIds);
            
            // Add all chat IDs from selected folders and their subfolders
            selectedFolderIds.forEach(folderId => {
                const chatIds = getAllChatIdsInFolder(folderId);
                chatIds.forEach(chatId => allChatIdsToDelete.add(chatId));
            });

            const totalToDelete = allChatIdsToDelete.size;
            
            if (totalToDelete === 0) {
                statusEl.textContent = "No chats to delete.";
                return;
            }

            // --- NEW: Ensure all chats are visible before deletion ---
            const allConversations = getAllConversationElements();
            allChatIdsToDelete.forEach(chatId => {
                const chatElement = allConversations.find(el => getChatIdFromElement(el) === chatId);
                if (chatElement && chatElement.style.display === 'none') {
                    chatElement.style.display = '';
                }
            });

            // --- Set up and show the full-screen overlay ---
            closeModal(); // Close the small modal first
            createBulkDeleteOverlayStyles();
            const overlayWrapper = document.createElement('div');
            overlayWrapper.innerHTML = getBulkDeleteOverlayHTML();
            shadow.appendChild(overlayWrapper);
            
            const overlay = shadow.getElementById('gemini-delete-all-overlay');
            const overlayMessage = overlay.querySelector('.message');
            const progressStatus = overlay.querySelector('#progress-status');
            const progressCounter = overlay.querySelector('#progress-counter');
            const progressBarInner = overlay.querySelector('.progress-bar-inner');
            const cancelButton = overlay.querySelector('.cancel-button');
            const spinner = overlay.querySelector('.spinner');
            const completionTick = overlay.querySelector('.completion-tick');
            
            let wasCancelled = false;
            const cancellationController = new AbortController();

            cancelButton.addEventListener('click', () => {
                wasCancelled = true;
                cancellationController.abort();
                overlayMessage.textContent = 'Cancelling...';
            });

            // --- Execute deletion loop ---
            let deletedCount = 0;
            let errorCount = 0;
            const chatIdsArray = Array.from(allChatIdsToDelete);

            for (let i = 0; i < chatIdsArray.length; i++) {
                if (wasCancelled) break;

                const chatId = chatIdsArray[i];

                // Update overlay progress
                progressStatus.textContent = `Deleting chat ${i + 1} of ${totalToDelete}...`;
                progressCounter.textContent = `${i} / ${totalToDelete}`;
                progressBarInner.style.width = `${(i / totalToDelete) * 100}%`;
                
                const conversationElement = allConversations.find(el => getChatIdFromElement(el) === chatId);

                if (conversationElement) {
                    const result = await deleteSingleConversation(conversationElement, cancellationController.signal);
                    if (result.status === 'success') {
                        deletedCount++;
                    } else {
                        errorCount++;
                    }
                } else {
                    console.warn(`Could not find conversation element for chat ID: ${chatId}`);
                    errorCount++;
                }

                await delayMs(250);
            }

            // --- Remove selected folders from state ---
            if (selectedFolderIds.length > 0) {
                removeFolders(selectedFolderIds);
                await saveData();
            }
            
            // --- Finalize and hide overlay ---
            spinner.style.display = 'none';
            completionTick.style.display = 'block';
            progressBarInner.style.width = '100%';
            progressCounter.textContent = `${deletedCount} / ${totalToDelete}`;

            if (wasCancelled) {
                overlayMessage.textContent = 'Deletion cancelled.';
            } else if (errorCount > 0) {
                overlayMessage.textContent = `Finished. Deleted ${deletedCount}, failed ${errorCount}.`;
            } else {
                overlayMessage.textContent = 'All selected items deleted!';
            }
            
            setTimeout(() => {
                overlay.classList.add('hidden');
                overlay.addEventListener('transitionend', () => {
                    overlay.remove();
                }, { once: true });
            }, 3000);
        });
    }

    // --- NEW: Full-screen Loading Overlay Logic (from extension C) ---
    
    function getBulkDeleteOverlayHTML() {
        return `
            <div id="gemini-delete-all-overlay" class="visible">
                <div class="spinner"></div>
                <svg class="completion-tick" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
                    <circle class="tick-circle" cx="26" cy="26" r="25" fill="none"/>
                    <path class="tick-path" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
                </svg>
                <div class="message">Deleting...</div>
                <div class="progress-container">
                    <div class="progress-text">
                        <span id="progress-status">Starting...</span>
                        <span id="progress-counter">0 / 0</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-bar-inner"></div>
                    </div>
                </div>
                <button class="cancel-button">Cancel</button>
            </div>
        `;
    }

    function createBulkDeleteOverlayStyles() {
        if (shadow.getElementById("gemini-delete-all-overlay-styles")) return;

        const theme = {
            isDark: document.body.classList.contains('dark-theme'),
            // Simplified theme colors, can be expanded if needed
            backgroundColor: 'var(--gf-bg-primary)',
            textColor: 'var(--gf-text-primary)',
            secondaryTextColor: 'var(--gf-text-secondary)',
            accentColor: 'var(--gf-accent-primary)',
            progressTrackColor: 'rgba(128, 128, 128, 0.2)',
            successColor: '#34a853', // Standard green
        };

        const css = `
          #gemini-delete-all-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: var(--gf-bg-primary);
            z-index: 2147483647; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            font-family: 'Google Sans', Roboto, Arial, sans-serif; color: ${theme.textColor}; text-align: center;
            opacity: 1; transition: opacity 0.3s ease-in-out;
          }
          #gemini-delete-all-overlay.hidden { opacity: 0; pointer-events: none; }
          #gemini-delete-all-overlay .spinner {
            display: block;
            border: 3px solid ${theme.progressTrackColor}; border-top: 3px solid ${theme.accentColor};
            border-radius: 50%; width: 50px; height: 50px;
            animation: spin 0.8s linear infinite; margin-bottom: 25px;
          }
          @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
          
          #gemini-delete-all-overlay .completion-tick {
            display: none; width: 60px; height: 60px;
            border-radius: 50%;
            stroke-width: 5; stroke: ${theme.successColor};
            stroke-miterlimit: 10;
            animation: draw-tick-container 0.5s ease-out forwards;
            margin-bottom: 20px;
          }
          #gemini-delete-all-overlay .completion-tick .tick-path {
            stroke-dasharray: 100;
            stroke-dashoffset: 100;
            animation: draw-tick-path 0.5s 0.2s ease-out forwards;
          }
          @keyframes draw-tick-container {
            0% { opacity: 0; transform: scale(0.5); }
            100% { opacity: 1; transform: scale(1); }
          }
          @keyframes draw-tick-path {
            to { stroke-dashoffset: 0; }
          }
          #gemini-delete-all-overlay .message { font-size: 20px; font-weight: 500; margin-bottom: 8px; }
          
          #gemini-delete-all-overlay .progress-container {
            display: flex; flex-direction: column; align-items: center;
            width: 300px; margin: 10px 0;
          }
          #gemini-delete-all-overlay .progress-text { 
            font-size: 14px; color: ${theme.secondaryTextColor}; 
            margin-bottom: 8px; width: 100%;
            display: flex; justify-content: space-between;
          }
          
          #gemini-delete-all-overlay .progress-bar {
            width: 100%; height: 4px; background-color: ${theme.progressTrackColor};
            border-radius: 4px; overflow: hidden;
          }
          #gemini-delete-all-overlay .progress-bar-inner {
            height: 100%; width: 0%;
            background-color: ${theme.accentColor};
            transition: width 0.25s ease-out;
            border-radius: 4px;
          }
          
          #gemini-delete-all-overlay .cancel-button {
            margin-top: 16px; color: ${theme.secondaryTextColor};
            font-size: 14px; background: none; border: 1px solid ${theme.secondaryTextColor};
            padding: 8px 16px; cursor: pointer;
            font-family: 'Google Sans', Roboto, Arial, sans-serif;
            border-radius: 4px; transition: background-color 0.15s;
          }
          #gemini-delete-all-overlay .cancel-button:hover {
            background-color: rgba(128, 128, 128, 0.2);
          }
        `;
        const styleEl = document.createElement("style");
        styleEl.id = "gemini-delete-all-overlay-styles";
        styleEl.textContent = css;
        shadow.appendChild(styleEl);
    }

    async function injectPromptLibraryResources() {
        async function fetchWebAccessibleResource(resourcePath) {
            try {
                const url = chrome.runtime.getURL(resourcePath);
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${resourcePath}: ${response.status}`);
                }
                return await response.text();
            } catch (error) {
                console.error(`Error fetching web accessible resource ${resourcePath}:`, error);
                return null;
            }
        }

        // Wait for HTML, CSS, and export chat CSS to be loaded
        const [htmlContent, cssContent, exportChatCSS] = await Promise.all([
            fetchWebAccessibleResource('prompt_library.html'),
            fetchWebAccessibleResource('prompt_library.css'),
            fetchWebAccessibleResource('export_chat.css')
        ]);

        if (htmlContent) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            shadow.appendChild(tempDiv.firstElementChild);
        }

        if (cssContent) {
            const styleElement = document.createElement('style');
            styleElement.textContent = cssContent;
            shadow.appendChild(styleElement);
        }

        if (exportChatCSS) {
            const styleElement = document.createElement('style');
            styleElement.textContent = exportChatCSS;
            shadow.appendChild(styleElement);
            console.log('Export chat CSS injected successfully');
        }
    }

    // --- WORD COUNTER FUNCTIONALITY ---
    let wordCounterInstance = null;

    async function initializeWordCounter() {
        // Destroy existing instance if it exists
        if (wordCounterInstance) {
            wordCounterInstance.destroy();
            wordCounterInstance = null;
        }

        // Create new instance - WordCounter is already loaded as a content script
        try {
            if (typeof WordCounter !== 'undefined') {
                wordCounterInstance = new WordCounter(shadow);
                console.log('Word counter initialized successfully');
            } else {
                console.error('WordCounter class not found');
            }
        } catch (error) {
            console.error('Error initializing word counter:', error);
        }
    }

    // --- VOICE MODE FUNCTIONALITY ---
    
    async function initializeVoiceMode() {
        if (!voiceModeInstance && window.VoiceMode) {
            try {
                voiceModeInstance = new window.VoiceMode(shadow);
                console.log('Voice Mode initialized successfully');
                voiceModeInstance.announcePresence();
            } catch (error) {
                console.error('Error initializing Voice Mode:', error);
            }
        }
    }

    // --- EXPORT CHAT FUNCTIONALITY ---
    
    async function initializeExportChat() {
        if (!chatExporterInstance && window.ChatExporter) {
            try {
                chatExporterInstance = new window.ChatExporter(shadow);
                console.log('Chat Exporter initialized successfully');
                showChatExportModal();
            } catch (error) {
                console.error('Error initializing Chat Exporter:', error);
            }
        } else if (chatExporterInstance) {
            // If already initialized, just show the modal
            showChatExportModal();
        } else {
            // If ChatExporter class is not available, create it directly
            console.log('ChatExporter class not found, creating from loaded script...');
            if (typeof ChatExporter !== 'undefined') {
                try {
                    chatExporterInstance = new ChatExporter(shadow);
                    console.log('Chat Exporter initialized successfully');
                    showChatExportModal();
                } catch (error) {
                    console.error('Error initializing Chat Exporter:', error);
                }
            } else {
                console.error('ChatExporter class not available');
            }
        }
    }

    // --- REFACTORED: INITIALIZATION ---

    async function init() {
        if (document.getElementById(INJECTOR_HOST_ID)) return;
        await delay(500);

        // Find a more stable insertion point, like the recent conversations list container.
        const recentConversationsList = document.querySelector('conversations-list');
        if (recentConversationsList && !document.getElementById(INJECTOR_HOST_ID)) {
            hostElement = document.createElement('div');
            hostElement.id = INJECTOR_HOST_ID;
            shadow = hostElement.attachShadow({ mode: 'open' });
            
            createGlobalStyles();
            
            // Inject the main "Folders" tab
            const sidebarTabHTML = getSidebarTabHTML();
            shadow.innerHTML += sidebarTabHTML;
            
            // Prepend our UI host to the conversation list
            recentConversationsList.prepend(hostElement);
            
            // Add event listeners for the new dropdown functionality
            const toolboxBtn = shadow.getElementById('gemini-toolbox-btn');
            const toolboxDropdown = shadow.getElementById('gemini-toolbox-dropdown');
            const manageFoldersLink = shadow.getElementById('manage-folders-link');
            const bulkDeleteLink = shadow.getElementById('bulk-delete-link');
            const promptLibraryLink = shadow.getElementById('prompt-library-link');
            const wordCounterLink = shadow.getElementById('word-counter-link');
            const voiceModeLink = shadow.getElementById('voice-mode-link');
            const voiceSettingsLink = shadow.getElementById('voice-settings-link');
            const exportChatLink = shadow.getElementById('export-chat-link');
            const dropdownArrow = shadow.querySelector('.dropdown-arrow');
            
            // Toggle dropdown on toolbox button click
            toolboxBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isVisible = toolboxDropdown.style.display !== 'none';
                toolboxDropdown.style.display = isVisible ? 'none' : 'block';
                dropdownArrow.classList.toggle('rotated', !isVisible);
            });
            
            // Handle manage folders link click
            manageFoldersLink.addEventListener('click', (e) => {
                e.stopPropagation();
                showManageFoldersModal();
                toolboxDropdown.style.display = 'none';
                dropdownArrow.classList.remove('rotated');
            });

            // Handle bulk delete link click
            bulkDeleteLink.addEventListener('click', (e) => {
                e.stopPropagation();
                showBulkDeleteModal();
                toolboxDropdown.style.display = 'none';
                dropdownArrow.classList.remove('rotated');
            });

            // Handle prompt library link click
            promptLibraryLink.addEventListener('click', (e) => {
                e.stopPropagation();
                if (promptLibraryInstance) {
                    promptLibraryInstance.show();
                }
                toolboxDropdown.style.display = 'none';
                dropdownArrow.classList.remove('rotated');
            });

            // Handle word counter link click
            wordCounterLink.addEventListener('click', (e) => {
                e.stopPropagation();
                initializeWordCounter();
                toolboxDropdown.style.display = 'none';
                dropdownArrow.classList.remove('rotated');
            });

            // Handle voice mode link click
            voiceModeLink.addEventListener('click', (e) => {
                e.stopPropagation();
                initializeVoiceMode();
                toolboxDropdown.style.display = 'none';
                dropdownArrow.classList.remove('rotated');
            });

            // Handle voice settings link click
            voiceSettingsLink.addEventListener('click', (e) => {
                e.stopPropagation();
                if (voiceModeInstance) {
                    voiceModeInstance.showVoiceSettings();
                } else {
                    // Initialize voice mode if not already done
                    initializeVoiceMode();
                    setTimeout(() => {
                        if (voiceModeInstance) {
                            voiceModeInstance.showVoiceSettings();
                        }
                    }, 100);
                }
                toolboxDropdown.style.display = 'none';
                dropdownArrow.classList.remove('rotated');
            });

            // Handle export chat link click
            exportChatLink.addEventListener('click', (e) => {
                e.stopPropagation();
                initializeExportChat();
                toolboxDropdown.style.display = 'none';
                dropdownArrow.classList.remove('rotated');
            });

            // Implement click outside to close functionality
            document.addEventListener('click', (e) => {
                const toolboxContainer = shadow.getElementById('gemini-toolbox-container');
                if (toolboxContainer && !toolboxContainer.contains(e.target)) {
                    toolboxDropdown.style.display = 'none';
                    dropdownArrow.classList.remove('rotated');
                }
            });

            await loadData();
            await injectPromptLibraryResources(); // Inject prompt library resources

            // Initialize PromptLibrary after HTML is loaded
            if (typeof PromptLibrary !== 'undefined') {
                promptLibraryInstance = new PromptLibrary(shadow);
                // Initialize event listeners now that HTML is loaded
                promptLibraryInstance.initializeEventListeners();
            } else {
                // Retry if the script hasn't loaded yet
                setTimeout(() => {
                    if (typeof PromptLibrary !== 'undefined') {
                        promptLibraryInstance = new PromptLibrary(shadow);
                        promptLibraryInstance.initializeEventListeners();
                    }
                }, 500);
            }

            // Initialize Voice Mode feature
            if (typeof VoiceMode !== 'undefined') {
                try {
                    voiceModeInstance = new VoiceMode(shadow);
                    console.log('Voice Mode auto-initialized successfully');
                    
                    // Auto-initialize to start monitoring for responses immediately
                    voiceModeInstance.announcePresence();
                } catch (error) {
                    console.error('Error auto-initializing Voice Mode:', error);
                }
            } else {
                // Retry if the script hasn't loaded yet
                setTimeout(() => {
                    if (typeof VoiceMode !== 'undefined') {
                        try {
                            voiceModeInstance = new VoiceMode(shadow);
                            console.log('Voice Mode auto-initialized successfully (delayed)');
                            voiceModeInstance.announcePresence();
                        } catch (error) {
                            console.error('Error auto-initializing Voice Mode (delayed):', error);
                        }
                    }
                }, 1000);
            }
        }
    }

    const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            if (mutation.type === 'childList') {
                if (document.querySelector('conversations-list') && !document.getElementById(INJECTOR_HOST_ID)) {
                    init();
                    // No need to break; let it run to catch theme changes etc.
                }
                 // Add theme change observation
                const newTheme = detectTheme();
                if (newTheme !== currentTheme) {
                    applyThemeStyles();
                }
            }
        }
    });

    observer.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] });
    
    // Initial check
    init();

})(); 

====================================================================
FILE: D/background.js
====================================================================
// Gemini Toolbox - background.js

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === 'downloadFile') {
        chrome.downloads.download({
            url: request.url,
            filename: request.filename,
            saveAs: false // Set to true if you want to prompt the user for the save location
        }).then(downloadId => {
            console.log("Download started with ID:", downloadId);
            sendResponse({status: "success"});
        }).catch(err => {
            console.error("Download failed:", err);
            sendResponse({status: "error", message: err.message});
        });
        
        // Return true to indicate you wish to send a response asynchronously
        return true;
    }
});

====================================================================
FILE: D/prompt_library.css
====================================================================
/* Main modal backdrop */
.modal {
    display: none; 
    position: fixed; 
    z-index: 2000; 
    left: 0;
    top: 0;
    width: 100%; 
    height: 100%; 
    overflow: auto; 
    background-color: rgba(0, 0, 0, 0.6); 
    backdrop-filter: blur(4px);
}

/* Modal content container */
.modal-content {
    background-color: #1f1f1f;
    color: #e8eaed;
    margin: 8% auto; 
    padding: 0;
    border: 1px solid #5f6368;
    width: 90%;
    max-width: 720px;
    border-radius: 16px;
    font-family: 'Google Sans', 'Roboto', sans-serif;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
    animation: modalFadeIn 0.3s ease-out;
}

@keyframes modalFadeIn {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Modal header */
.modal-content h2 {
    color: #e8eaed;
    margin: 0;
    padding: 24px 24px 16px 24px;
    font-size: 20px;
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

/* Close button */
.close-button {
    color: #9aa0a6;
    font-size: 24px;
    font-weight: 400;
    cursor: pointer;
    padding: 8px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    transition: all 0.2s ease;
}

.close-button:hover,
.close-button:focus {
    color: #e8eaed;
    background-color: #3c4043;
}

/* Controls section */
.controls {
    display: flex;
    gap: 12px;
    margin-bottom: 20px;
    padding: 0 24px;
}

#search-bar, #category-filter {
    flex: 1;
    padding: 12px 16px;
    border-radius: 8px;
    border: 1px solid #5f6368;
    background-color: #2d2d2f;
    color: #e8eaed;
    font-size: 14px;
    font-family: 'Google Sans', 'Roboto', sans-serif;
    transition: all 0.2s ease;
}

#search-bar:focus, #category-filter:focus {
    outline: none;
    border-color: #8ab4f8;
    box-shadow: 0 0 0 2px rgba(138, 180, 248, 0.2);
}

#search-bar::placeholder {
    color: #9aa0a6;
}

#category-filter {
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23e8eaed' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 12px center;
    background-size: 16px;
    padding-right: 40px;
    cursor: pointer;
}

/* Prompt list container */
.prompt-list {
    max-height: 450px;
    overflow-y: auto;
    padding: 0 24px 24px 24px;
    scrollbar-width: thin;
    scrollbar-color: #5f6368 #2d2d2f;
}

.prompt-list::-webkit-scrollbar {
    width: 6px;
}

.prompt-list::-webkit-scrollbar-track {
    background: #2d2d2f;
    border-radius: 3px;
}

.prompt-list::-webkit-scrollbar-thumb {
    background: #5f6368;
    border-radius: 3px;
}

.prompt-list::-webkit-scrollbar-thumb:hover {
    background: #8ab4f8;
}

/* Individual prompt items */
.prompt-item {
    background: #2d2d2f;
    border: 1px solid #5f6368;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
}

.prompt-item:hover {
    background: #3c4043;
    border-color: #8ab4f8;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.prompt-item:active {
    transform: translateY(0);
}

/* Prompt header with copy button */
.prompt-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
}

.prompt-item .title {
    font-size: 16px;
    font-weight: 500;
    color: #e8eaed;
    line-height: 1.4;
    flex: 1;
}

.prompt-item .content {
    font-size: 14px;
    color: #9aa0a6;
    line-height: 1.5;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* Copy button */
.copy-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    color: #9aa0a6;
    transition: all 0.2s ease;
    opacity: 0;
    flex-shrink: 0;
}

.prompt-item:hover .copy-btn {
    opacity: 1;
}

.copy-btn:hover {
    background-color: rgba(138, 180, 248, 0.1);
    color: #8ab4f8;
}

/* Category badge */
.prompt-item::before {
    content: attr(data-category);
    position: absolute;
    top: 12px;
    right: 12px;
    background: #8ab4f8;
    color: #1f1f1f;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.prompt-item:hover::before {
    opacity: 1;
}

/* Empty state */
.prompt-list:empty::after {
    content: "No prompts found. Try adjusting your search or category filter.";
    display: block;
    text-align: center;
    color: #9aa0a6;
    padding: 40px 20px;
    font-style: italic;
}

/* Light theme support */
@media (prefers-color-scheme: light) {
    .modal-content {
        background-color: #ffffff;
        color: #1f1f1f;
        border-color: #dadce0;
    }
    
    .modal-content h2 {
        color: #1f1f1f;
    }
    
    .close-button {
        color: #5f6368;
    }
    
    .close-button:hover {
        color: #1f1f1f;
        background-color: #f1f3f4;
    }
    
    #search-bar, #category-filter {
        background-color: #ffffff;
        color: #1f1f1f;
        border-color: #dadce0;
    }
    
    #search-bar::placeholder {
        color: #5f6368;
    }
    
    .prompt-item {
        background: #f8f9fa;
        border-color: #dadce0;
    }
    
    .prompt-item:hover {
        background: #e8f0fe;
        border-color: #1a73e8;
    }
    
    .prompt-item .title {
        color: #1f1f1f;
    }
    
    .prompt-item .content {
        color: #5f6368;
    }
    
    .prompt-item::before {
        background: #1a73e8;
        color: #ffffff;
    }
    
    .copy-btn {
        color: #5f6368;
    }
    
    .copy-btn:hover {
        background-color: rgba(26, 115, 232, 0.1);
        color: #1a73e8;
    }
}

/* Responsive design */
@media (max-width: 768px) {
    .modal-content {
        width: 95%;
        margin: 5% auto;
        max-height: 90vh;
    }
    
    .controls {
        flex-direction: column;
        gap: 8px;
    }
    
    .prompt-list {
        max-height: 60vh;
    }
    
    .prompt-item {
        padding: 12px;
    }
    
    .prompt-item .title {
        font-size: 14px;
    }
    
    .prompt-item .content {
        font-size: 12px;
        -webkit-line-clamp: 2;
    }
} 

====================================================================
FILE: D/voice_mode.js
====================================================================
// ================================================================
// VOICE_MODE.JS - Voice Mode Feature with Listen & Download
// ================================================================
class VoiceMode {
    constructor(shadowRoot) {
        this.shadowRoot = shadowRoot;
        this.isInitialized = false;
        this.currentAudio = null;
        this.isPlaying = false;
        this.voices = [];
        this.settings = {
            selectedVoice: 0,
            rate: 1.0,
            pitch: 1.0,
            volume: 1.0
        };
        this.processedResponses = new WeakSet();
        this.init();
    }

    async init() {
        if (this.isInitialized) return;

        console.log('Initializing Voice Mode feature...');

        // Load settings from storage
        await this.loadSettings();

        // Initialize voices
        this.loadVoices();

        // Set up voice change listener
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => this.loadVoices();
        }

        // Start monitoring for new AI responses
        this.startResponseMonitoring();

        // Check for existing responses with delay to avoid duplicates
        setTimeout(() => this.checkExistingResponses(), 1000);

        this.isInitialized = true;
        console.log('Voice Mode feature initialized');
    }

    loadVoices() {
        this.voices = speechSynthesis.getVoices();
        if (this.voices.length === 0) {
            setTimeout(() => this.loadVoices(), 100);
        }
    }

    async loadSettings() {
        try {
            const result = await chrome.storage.local.get('voiceModeSettings');
            if (result.voiceModeSettings) {
                this.settings = { ...this.settings, ...result.voiceModeSettings };
            }
        } catch (error) {
            console.log('Using default voice settings');
        }
    }

    async saveSettings() {
        try {
            await chrome.storage.local.set({ voiceModeSettings: this.settings });
        } catch (error) {
            console.error('Failed to save voice settings:', error);
        }
    }

    startResponseMonitoring() {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        // Add a small delay to ensure DOM is fully rendered
                        setTimeout(() => this.checkForNewResponses(node), 500);
                    }
                });
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    checkExistingResponses() {
        const responseSelectors = [
            'message-content.model-response-text',
            '.model-response-text:not(.has-voice-buttons)',
            '.markdown.markdown-main-panel',
            '[data-message-author-role="assistant"]'
        ];

        responseSelectors.forEach(selector => {
            const responses = document.querySelectorAll(selector);
            responses.forEach(response => {
                if (!this.processedResponses.has(response) && !response.querySelector('.voice-mode-container')) {
                    this.addVoiceButtonsToResponse(response);
                }
            });
        });
    }

    checkForNewResponses(element) {
        const responseSelectors = [
            'message-content.model-response-text',
            '.model-response-text',
            '.markdown.markdown-main-panel',
            '[data-message-author-role="assistant"]'
        ];

        // Check if element itself is a response
        responseSelectors.forEach(selector => {
            if (element.matches && element.matches(selector)) {
                if (!this.processedResponses.has(element) && !element.querySelector('.voice-mode-container')) {
                    setTimeout(() => this.addVoiceButtonsToResponse(element), 100);
                }
            }
        });

        // Check child elements
        responseSelectors.forEach(selector => {
            const responses = element.querySelectorAll ? element.querySelectorAll(selector) : [];
            responses.forEach(response => {
                if (!this.processedResponses.has(response) && !response.querySelector('.voice-mode-container')) {
                    setTimeout(() => this.addVoiceButtonsToResponse(response), 100);
                }
            });
        });
    }

    addVoiceButtonsToResponse(responseElement) {
        // Double-check to prevent duplicates
        if (this.processedResponses.has(responseElement) || responseElement.querySelector('.voice-mode-container')) {
            return;
        }

        // Mark as processed immediately
        this.processedResponses.add(responseElement);
        responseElement.classList.add('has-voice-buttons');

        if (!this.isAIResponse(responseElement)) return;

        console.log('Adding voice buttons to response:', responseElement);

        const voiceContainer = this.createVoiceContainer(responseElement);
        const insertionPoint = this.findInsertionPoint(responseElement);
        
        if (insertionPoint) {
            insertionPoint.appendChild(voiceContainer);
        }
    }

    isAIResponse(element) {
        const text = element.textContent || '';
        if (text.trim().length < 10) return false;

        // Skip user messages
        if (element.closest('[data-message-author-role="user"]') ||
            element.closest('.user-message') ||
            element.closest('.human-message')) {
            return false;
        }

        // Check for AI response indicators
        const isGeminiResponse = element.classList.contains('model-response-text') ||
                                element.closest('.model-response-text') ||
                                element.querySelector('.markdown.markdown-main-panel');

        return isGeminiResponse;
    }

    findInsertionPoint(responseElement) {
        // Check if we already have a voice container
        const existing = responseElement.querySelector('.voice-mode-container');
        if (existing) return null;

        let insertionPoint = null;

        // Try to find existing action area
        const possibleContainers = [
            responseElement.querySelector('.response-footer'),
            responseElement.querySelector('.message-actions'),
            responseElement.querySelector('.response-actions'),
            responseElement.parentElement?.querySelector('.response-footer')
        ];

        for (const container of possibleContainers) {
            if (container && !container.querySelector('.voice-mode-container')) {
                insertionPoint = container;
                break;
            }
        }

        if (!insertionPoint) {
            // Create our own container
            insertionPoint = document.createElement('div');
            insertionPoint.className = 'voice-mode-actions';
            insertionPoint.style.cssText = `
                display: flex;
                gap: 8px;
                margin-top: 12px;
                align-items: center;
                padding: 8px 0;
                border-top: 1px solid var(--border-color, #e0e0e0);
            `;

            // For Gemini, append to the parent of the markdown content
            const markdownContent = responseElement.querySelector('.markdown.markdown-main-panel');
            if (markdownContent && markdownContent.parentElement) {
                markdownContent.parentElement.appendChild(insertionPoint);
            } else {
                responseElement.appendChild(insertionPoint);
            }
        }

        return insertionPoint;
    }

    createVoiceContainer(responseElement) {
        const container = document.createElement('div');
        container.className = 'voice-mode-container';
        container.style.cssText = `
            display: inline-flex;
            align-items: center;
            gap: 4px;
        `;

        // Create Listen button
        const listenButton = this.createListenButton(responseElement);
        
        // Create Download button
        const downloadButton = this.createDownloadButton(responseElement);

        container.appendChild(listenButton);
        container.appendChild(downloadButton);

        return container;
    }

    createListenButton(responseElement) {
        const button = document.createElement('button');
        button.className = 'voice-mode-listen-btn';
        
        const isDarkTheme = document.body.classList.contains('dark-theme') || 
                           document.body.classList.contains('dark_mode_toggled');

        button.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M8 5v14l11-7z" fill="currentColor"/>
            </svg>
            <span>Listen</span>
        `;

        button.style.cssText = `
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border: 1px solid ${isDarkTheme ? '#5f6368' : '#dadce0'};
            border-radius: 20px;
            background: transparent;
            color: ${isDarkTheme ? '#8ab4f8' : '#1a73e8'};
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Google Sans', Roboto, sans-serif;
            white-space: nowrap;
        `;

        // Hover effects
        button.addEventListener('mouseenter', () => {
            button.style.backgroundColor = isDarkTheme ? 'rgba(138, 180, 248, 0.08)' : 'rgba(26, 115, 232, 0.08)';
            button.style.borderColor = isDarkTheme ? '#8ab4f8' : '#1a73e8';
        });

        button.addEventListener('mouseleave', () => {
            if (!button.classList.contains('playing')) {
                button.style.backgroundColor = 'transparent';
                button.style.borderColor = isDarkTheme ? '#5f6368' : '#dadce0';
            }
        });

        // Click handler
        button.addEventListener('click', (e) => {
            e.stopPropagation();
            this.handleListenClick(responseElement, button);
        });

        return button;
    }

    createDownloadButton(responseElement) {
        const button = document.createElement('button');
        button.className = 'voice-mode-download-btn';
        button.title = 'Download as audio';
        
        const isDarkTheme = document.body.classList.contains('dark-theme') || 
                           document.body.classList.contains('dark_mode_toggled');

        button.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <polyline points="7 10 12 15 17 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <line x1="12" y1="15" x2="12" y2="3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        `;

        button.style.cssText = `
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border: 1px solid ${isDarkTheme ? '#5f6368' : '#dadce0'};
            border-radius: 50%;
            background: transparent;
            color: ${isDarkTheme ? '#8ab4f8' : '#1a73e8'};
            cursor: pointer;
            transition: all 0.2s ease;
        `;

        // Hover effects
        button.addEventListener('mouseenter', () => {
            button.style.backgroundColor = isDarkTheme ? 'rgba(138, 180, 248, 0.08)' : 'rgba(26, 115, 232, 0.08)';
            button.style.borderColor = isDarkTheme ? '#8ab4f8' : '#1a73e8';
        });

        button.addEventListener('mouseleave', () => {
            button.style.backgroundColor = 'transparent';
            button.style.borderColor = isDarkTheme ? '#5f6368' : '#dadce0';
        });

        // Click handler
        button.addEventListener('click', (e) => {
            e.stopPropagation();
            this.handleDownloadClick(responseElement);
        });

        return button;
    }

    handleListenClick(responseElement, button) {
        const text = this.extractTextFromResponse(responseElement);
        if (!text) {
            alert('Could not extract text from this response.');
            return;
        }

        // If already playing this button, stop
        if (this.isPlaying && button.classList.contains('playing')) {
            this.stopSpeaking();
            return;
        }

        // Stop any other playing audio
        if (this.isPlaying) {
            this.stopSpeaking();
        }

        // Start playing
        this.playText(text, button);
    }

    handleDownloadClick(responseElement) {
        const text = this.extractTextFromResponse(responseElement);
        if (!text) {
            alert('Could not extract text from this response.');
            return;
        }

        // Use Web Speech API to generate audio blob
        this.generateAndDownloadAudio(text);
    }

    async generateAndDownloadAudio(text) {
        try {
            // Show loading state
            const downloadButtons = document.querySelectorAll('.voice-mode-download-btn');
            downloadButtons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
            });

            // Create a more sophisticated approach using MediaRecorder
            const utterance = new SpeechSynthesisUtterance(text);
            
            if (this.voices.length > 0) {
                utterance.voice = this.voices[this.settings.selectedVoice];
            }
            utterance.rate = this.settings.rate;
            utterance.pitch = this.settings.pitch;
            utterance.volume = this.settings.volume;

            // For now, we'll create a text file with the content and settings
            // (Full audio generation would require a server-side API)
            const audioSettings = {
                text: text,
                voice: this.voices[this.settings.selectedVoice]?.name || 'Default',
                rate: this.settings.rate,
                pitch: this.settings.pitch,
                volume: this.settings.volume
            };

            const blob = new Blob([JSON.stringify(audioSettings, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gemini-response-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Show info message
            this.showToast('Downloaded response data. Note: Audio file generation requires additional setup.');

        } catch (error) {
            console.error('Download error:', error);
            this.showToast('Download failed. Please try again.');
        } finally {
            // Reset button states
            const downloadButtons = document.querySelectorAll('.voice-mode-download-btn');
            downloadButtons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
            });
        }
    }

    showToast(message) {
        const toast = document.createElement('div');
        toast.className = 'voice-mode-toast';
        toast.textContent = message;
        
        const isDarkTheme = document.body.classList.contains('dark-theme') || 
                           document.body.classList.contains('dark_mode_toggled');

        toast.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: ${isDarkTheme ? '#2d2d2f' : '#323232'};
            color: #fff;
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
            font-family: 'Google Sans', Roboto, sans-serif;
        `;

        document.body.appendChild(toast);
        
        // Animate in
        setTimeout(() => toast.style.opacity = '1', 10);
        
        // Remove after 3 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    extractTextFromResponse(responseElement) {
        const clone = responseElement.cloneNode(true);
        
        // Remove non-content elements
        const selectorsToRemove = [
            'button', 
            '.response-actions', 
            '.message-actions', 
            '.voice-mode-container',
            '.voice-mode-actions',
            '.code-block-header',
            'pre',
            'code',
            '.copy-code-button'
        ];
        
        selectorsToRemove.forEach(selector => {
            clone.querySelectorAll(selector).forEach(el => el.remove());
        });
        
        // For Gemini, prefer markdown content
        const markdownContent = clone.querySelector('.markdown.markdown-main-panel');
        if (markdownContent) {
            return markdownContent.innerText || markdownContent.textContent || '';
        }
        
        return clone.innerText || clone.textContent || '';
    }

    playText(text, button) {
        if (!text) return;

        const utterance = new SpeechSynthesisUtterance(text);
        
        // Apply settings
        if (this.voices.length > 0) {
            utterance.voice = this.voices[this.settings.selectedVoice] || this.voices[0];
        }
        utterance.rate = this.settings.rate;
        utterance.pitch = this.settings.pitch;
        utterance.volume = this.settings.volume;
        
        // Update button state
        button.classList.add('playing');
        button.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="6" y="4" width="4" height="16" rx="1" fill="currentColor"/>
                <rect x="14" y="4" width="4" height="16" rx="1" fill="currentColor"/>
            </svg>
            <span>Stop</span>
        `;
        
        const isDarkTheme = document.body.classList.contains('dark-theme') || 
                           document.body.classList.contains('dark_mode_toggled');
        button.style.backgroundColor = isDarkTheme ? 'rgba(138, 180, 248, 0.08)' : 'rgba(26, 115, 232, 0.08)';
        
        utterance.onstart = () => {
            this.isPlaying = true;
            this.currentButton = button;
        };

        utterance.onend = () => {
            this.resetButton(button);
            this.isPlaying = false;
            this.currentButton = null;
        };

        utterance.onerror = (e) => {
            console.error('Speech synthesis error:', e);
            this.resetButton(button);
            this.isPlaying = false;
            this.currentButton = null;
        };
        
        speechSynthesis.speak(utterance);
    }

    stopSpeaking() {
        speechSynthesis.cancel();
        if (this.currentButton) {
            this.resetButton(this.currentButton);
        }
        this.isPlaying = false;
        this.currentButton = null;
    }

    resetButton(button) {
        button.classList.remove('playing');
        button.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M8 5v14l11-7z" fill="currentColor"/>
            </svg>
            <span>Listen</span>
        `;
        button.style.backgroundColor = 'transparent';
    }

    // Voice settings modal (same as before)
    showVoiceSettings() {
        const existingModal = this.shadowRoot.getElementById('voice-settings-modal');
        if (existingModal) {
            existingModal.style.display = 'block';
            return;
        }

        const modalHTML = `
            <div id="voice-settings-modal" class="modal">
                <div class="modal-content" style="width: 500px;">
                    <div class="modal-header">
                        <h2>Voice Settings</h2>
                        <button class="icon-btn close-button" id="close-voice-settings">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div class="settings-group">
                            <label for="voice-select">Voice:</label>
                            <select id="voice-select" class="settings-select">
                                ${this.voices.map((voice, index) => 
                                    `<option value="${index}" ${index === this.settings.selectedVoice ? 'selected' : ''}>
                                        ${voice.name} (${voice.lang})
                                    </option>`
                                ).join('')}
                            </select>
                        </div>
                        
                        <div class="settings-group">
                            <label for="rate-slider">Speed: <span id="rate-value">${this.settings.rate}</span></label>
                            <input type="range" id="rate-slider" min="0.5" max="2" step="0.1" value="${this.settings.rate}">
                        </div>
                        
                        <div class="settings-group">
                            <label for="pitch-slider">Pitch: <span id="pitch-value">${this.settings.pitch}</span></label>
                            <input type="range" id="pitch-slider" min="0.5" max="2" step="0.1" value="${this.settings.pitch}">
                        </div>
                        
                        <div class="settings-group">
                            <label for="volume-slider">Volume: <span id="volume-value">${this.settings.volume}</span></label>
                            <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="${this.settings.volume}">
                        </div>
                        
                        <div class="settings-actions">
                            <button class="button primary" id="test-voice-btn">Test Voice</button>
                            <button class="button secondary" id="reset-voice-btn">Reset Defaults</button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        const modalContainer = document.createElement('div');
        modalContainer.innerHTML = modalHTML;
        this.shadowRoot.appendChild(modalContainer.firstElementChild);

        this.addSettingsStyles();
        this.addSettingsEventListeners();
    }

    addSettingsStyles() {
        const styles = document.createElement('style');
        styles.textContent = `
            .settings-group {
                margin-bottom: 20px;
            }
            
            .settings-group label {
                display: block;
                margin-bottom: 8px;
                font-weight: 500;
                color: var(--gf-text-primary);
            }
            
            .settings-select {
                width: 100%;
                padding: 8px 12px;
                border: 1px solid var(--gf-border-color);
                border-radius: 6px;
                background: var(--gf-bg-input);
                color: var(--gf-text-primary);
                font-size: 14px;
            }
            
            input[type="range"] {
                width: 100%;
                margin-top: 8px;
            }
            
            .settings-actions {
                display: flex;
                gap: 12px;
                margin-top: 24px;
                padding-top: 24px;
                border-top: 1px solid var(--gf-border-color);
            }
        `;
        
        this.shadowRoot.appendChild(styles);
    }

    addSettingsEventListeners() {
        const modal = this.shadowRoot.getElementById('voice-settings-modal');
        
        modal.querySelector('#close-voice-settings').onclick = () => {
            modal.style.display = 'none';
        };
        
        modal.querySelector('#voice-select').onchange = (e) => {
            this.settings.selectedVoice = parseInt(e.target.value);
            this.saveSettings();
        };
        
        ['rate', 'pitch', 'volume'].forEach(param => {
            const slider = modal.querySelector(`#${param}-slider`);
            const value = modal.querySelector(`#${param}-value`);
            
            slider.oninput = (e) => {
                const val = parseFloat(e.target.value);
                this.settings[param] = val;
                value.textContent = val.toFixed(1);
                this.saveSettings();
            };
        });
        
        modal.querySelector('#test-voice-btn').onclick = () => {
            const testText = "Hello! This is a test of the voice settings. How does this sound?";
            const utterance = new SpeechSynthesisUtterance(testText);
            
            if (this.voices.length > 0) {
                utterance.voice = this.voices[this.settings.selectedVoice];
            }
            utterance.rate = this.settings.rate;
            utterance.pitch = this.settings.pitch;
            utterance.volume = this.settings.volume;
            
            speechSynthesis.cancel();
            speechSynthesis.speak(utterance);
        };
        
        modal.querySelector('#reset-voice-btn').onclick = () => {
            this.settings = {
                selectedVoice: 0,
                rate: 1.0,
                pitch: 1.0,
                volume: 1.0
            };
            this.saveSettings();
            
            modal.querySelector('#voice-select').value = '0';
            modal.querySelector('#rate-slider').value = '1';
            modal.querySelector('#rate-value').textContent = '1';
            modal.querySelector('#pitch-slider').value = '1';
            modal.querySelector('#pitch-value').textContent = '1';
            modal.querySelector('#volume-slider').value = '1';
            modal.querySelector('#volume-value').textContent = '1';
        };
    }

    announcePresence() {
        console.log('Voice Mode feature is active');
    }
}

// Make available globally
if (typeof window !== 'undefined') {
    window.VoiceMode = VoiceMode;
}

====================================================================
FILE: D/WORD_COUNTER_FEATURE.md
====================================================================
# üìä Word Counter Feature

## Overview
The Word Counter feature provides real-time character and word counting for your Gemini prompts, similar to the popular feature found in ChatGPT Toolbox extensions.

## üéØ **Feature Analysis from ChatGPT Toolbox**

### What I Found:
- **Real-time counting**: Updates as you type
- **Character & word tracking**: Shows both metrics simultaneously  
- **Smart positioning**: Positioned near input area for visibility
- **Responsive design**: Works on desktop and mobile
- **Theme awareness**: Matches light/dark themes
- **Multi-language support**: Handles LTR/RTL languages

### Implementation Benefits:
- **Better prompt management**: Know exactly how long your prompts are
- **Token estimation**: Helps estimate AI token usage
- **Writing efficiency**: Track your writing progress
- **Professional appearance**: Matches Gemini's design language

## üöÄ **Features**

### ‚ú® **Core Functionality**
- **Real-time counting**: Updates automatically as you type
- **Character count**: Total characters including spaces
- **Word count**: Accurate word counting with whitespace handling
- **Smart visibility**: Shows when typing, hides when empty

### üé® **User Experience**
- **Floating counter**: Positioned at bottom-right of screen
- **Minimizable**: Click toggle button to minimize/expand
- **Smooth animations**: Fade in/out with smooth transitions
- **Theme-aware**: Matches Gemini's light/dark theme
- **Mobile responsive**: Adapts to different screen sizes

### üîß **Technical Features**
- **Multiple input detection**: Works with all Gemini input variations
- **Efficient observing**: Uses MutationObserver for performance
- **Memory management**: Properly cleans up when destroyed
- **Error handling**: Graceful fallbacks if input not found

## üìñ **How to Use**

### 1. **Activate Word Counter**
- Click the **Gemini Toolbox** button in the sidebar
- Select **Word Counter** from the dropdown menu
- The counter will appear at the bottom-right of your screen

### 2. **Using the Counter**
- Start typing in the Gemini input field
- The counter will automatically appear and update
- Shows format: `X characters / Y words`
- Counter hides automatically when input is empty

### 3. **Toggle Display**
- Click the **document icon** in the counter to minimize/expand
- Minimized mode shows only the toggle button
- Expanded mode shows full character/word count

## üéØ **Benefits**

### **For Content Creators**
- Track prompt length for consistent output
- Optimize prompts within token limits
- Monitor writing efficiency

### **For Developers**
- Understand API token usage
- Debug prompt length issues
- Optimize for model context windows

### **For Students & Professionals**
- Meet specific word count requirements
- Track writing progress
- Maintain consistent prompt lengths

## üí° **Technical Implementation**

### **Smart Input Detection**
```javascript
const selectors = [
    '.ql-editor.textarea.new-input-ui',  // Primary Gemini input
    'rich-textarea .ql-editor',          // Alternative format
    '.ql-editor[contenteditable="true"]', // Fallback
    'div[contenteditable="true"][role="textbox"]' // Generic
];
```

### **Efficient Counting Algorithm**
- **Characters**: Simple `text.length`
- **Words**: `text.trim().split(/\s+/).length` with empty string handling
- **Performance**: Only updates when content actually changes

### **Responsive Design**
- **Desktop**: Bottom-right positioning with full visibility
- **Mobile**: Smaller size and adjusted positioning
- **Themes**: CSS variables for automatic theme switching

## üîß **Configuration**

### **Default Settings**
- **Position**: Bottom-right corner
- **Theme**: Auto-detect from Gemini
- **Visibility**: Auto-show/hide based on content
- **Animation**: Smooth fade transitions

### **Customization Options**
- **Toggle**: Minimize/expand display
- **Positioning**: Fixed bottom-right for consistency
- **Styling**: Matches Gemini's design system

## üêõ **Troubleshooting**

### **Counter Not Appearing**
- Ensure you're on a Gemini chat page
- Try clicking in the input field to focus it
- Check browser console for error messages
- Refresh the page and try again

### **Inaccurate Counts**
- Counter uses standard word/character counting
- Empty fields show `0 characters / 0 words`
- Whitespace is handled consistently

### **Performance Issues**
- Counter uses efficient MutationObserver
- Automatically cleans up when destroyed
- No impact on Gemini's performance

## üé® **Design Philosophy**

### **Inspired by ChatGPT Toolbox**
- Clean, minimalist interface
- Non-intrusive positioning
- Professional appearance
- Consistent with host application

### **Gemini Integration**
- Matches Gemini's color scheme
- Uses Google Sans typography
- Respects Gemini's design language
- Seamless user experience

## üìã **Future Enhancements**

### **Potential Additions**
- **Token estimation**: Approximate AI token usage
- **Reading time**: Estimated reading time
- **Paragraph count**: Additional text metrics
- **Export stats**: Save counting statistics
- **Custom thresholds**: Warnings for length limits

### **Advanced Features**
- **Multi-language support**: Better international counting
- **Custom positioning**: User-configurable placement
- **Statistics tracking**: Historical count data
- **Integration**: Export to other tools

## üîç **Comparison with ChatGPT Toolbox**

### **Similarities**
- ‚úÖ Real-time character/word counting
- ‚úÖ Smart positioning near input
- ‚úÖ Theme-aware design
- ‚úÖ Minimizable interface

### **Improvements**
- ‚úÖ Better Gemini integration
- ‚úÖ Smoother animations
- ‚úÖ More robust input detection
- ‚úÖ Cleaner code architecture

### **Unique Features**
- ‚úÖ Gemini-specific optimizations
- ‚úÖ Better mobile responsiveness
- ‚úÖ Enhanced error handling
- ‚úÖ Modular design architecture

This Word Counter feature brings professional-grade text analysis to your Gemini experience, inspired by the best features from ChatGPT Toolbox while being optimized specifically for Gemini's interface and functionality.

====================================================================
FILE: D/word_counter.js
====================================================================
class WordCounter {
    constructor(shadowRoot) {
        this.shadowRoot = shadowRoot;
        this.counterElement = null;
        this.isActive = false;
        this.observer = null;
        this.currentText = '';
        this.init();
    }

    init() {
        this.createCounter();
        this.attachToInput();
    }

    createCounter() {
        // Create counter element
        this.counterElement = document.createElement('div');
        this.counterElement.id = 'gemini-word-counter';
        this.counterElement.className = 'gemini-word-counter';
        this.counterElement.innerHTML = `
            <span class="counter-text">0 characters / 0 words</span>
            <button class="counter-toggle" title="Toggle counter">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" stroke="currentColor" stroke-width="2"/>
                    <polyline points="14,2 14,8 20,8" stroke="currentColor" stroke-width="2"/>
                    <line x1="16" y1="13" x2="8" y2="13" stroke="currentColor" stroke-width="2"/>
                    <line x1="16" y1="17" x2="8" y2="17" stroke="currentColor" stroke-width="2"/>
                    <polyline points="10,9 9,9 8,9" stroke="currentColor" stroke-width="2"/>
                </svg>
            </button>
        `;

        // Add event listener for toggle button
        const toggleButton = this.counterElement.querySelector('.counter-toggle');
        toggleButton.addEventListener('click', () => this.toggleCounter());

        // Inject counter styles
        this.injectStyles();
    }

    injectStyles() {
        const styles = document.createElement('style');
        styles.textContent = `
            .gemini-word-counter {
                position: fixed;
                bottom: 100px;
                right: 20px;
                background: #2d2d2f;
                color: #e8eaed;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 12px;
                font-family: 'Google Sans', 'Roboto', sans-serif;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
                z-index: 1000;
                display: flex;
                align-items: center;
                gap: 8px;
                transition: all 0.3s ease;
                opacity: 0;
                transform: translateY(20px);
                pointer-events: none;
            }

            .gemini-word-counter.active {
                opacity: 1;
                transform: translateY(0);
                pointer-events: auto;
            }

            .gemini-word-counter.minimized .counter-text {
                display: none;
            }

            .gemini-word-counter.minimized {
                padding: 8px;
                border-radius: 50%;
            }

            .counter-text {
                font-weight: 500;
                white-space: nowrap;
            }

            .counter-toggle {
                background: none;
                border: none;
                color: #9aa0a6;
                cursor: pointer;
                padding: 2px;
                border-radius: 4px;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .counter-toggle:hover {
                background: rgba(138, 180, 248, 0.1);
                color: #8ab4f8;
            }

            /* Light theme support */
            @media (prefers-color-scheme: light) {
                .gemini-word-counter {
                    background: #ffffff;
                    color: #1f1f1f;
                    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                    border: 1px solid #dadce0;
                }

                .counter-toggle {
                    color: #5f6368;
                }

                .counter-toggle:hover {
                    background: rgba(26, 115, 232, 0.1);
                    color: #1a73e8;
                }
            }

            /* Dark theme detection */
            body.dark-theme .gemini-word-counter,
            body.dark_mode_toggled .gemini-word-counter {
                background: #2d2d2f;
                color: #e8eaed;
                border: none;
            }

            body.dark-theme .counter-toggle,
            body.dark_mode_toggled .counter-toggle {
                color: #9aa0a6;
            }

            /* Mobile responsive */
            @media (max-width: 768px) {
                .gemini-word-counter {
                    bottom: 80px;
                    right: 16px;
                    font-size: 11px;
                }
            }
        `;

        document.head.appendChild(styles);
    }

    attachToInput() {
        // Function to find and attach to Gemini input
        const findAndAttachToInput = () => {
            const selectors = [
                '.ql-editor.textarea.new-input-ui',
                'rich-textarea .ql-editor',
                '.ql-editor[contenteditable="true"]',
                'div[contenteditable="true"][role="textbox"]'
            ];

            let geminiInput = null;
            
            for (const selector of selectors) {
                geminiInput = document.querySelector(selector);
                if (geminiInput) {
                    console.log(`Word counter attached to: ${selector}`);
                    break;
                }
            }

            if (geminiInput) {
                // Add counter to page
                document.body.appendChild(this.counterElement);
                
                // Set up observer for content changes
                this.setupObserver(geminiInput);
                
                // Initial count
                this.updateCount(geminiInput);
                
                // Show counter if there's text
                if (geminiInput.textContent.trim()) {
                    this.showCounter();
                }
                
                return true;
            }
            
            return false;
        };

        // Try to attach immediately
        if (!findAndAttachToInput()) {
            // If not found, try again after a delay
            setTimeout(() => {
                findAndAttachToInput();
            }, 1000);
        }
    }

    setupObserver(inputElement) {
        // Clean up existing observer
        if (this.observer) {
            this.observer.disconnect();
        }

        // Create new observer
        this.observer = new MutationObserver(() => {
            this.updateCount(inputElement);
        });

        // Start observing
        this.observer.observe(inputElement, {
            childList: true,
            characterData: true,
            subtree: true
        });

        // Also listen for input events
        inputElement.addEventListener('input', () => {
            this.updateCount(inputElement);
        });

        // Listen for focus/blur to show/hide counter
        inputElement.addEventListener('focus', () => {
            this.showCounter();
        });

        inputElement.addEventListener('blur', () => {
            // Hide counter after a delay if no text
            setTimeout(() => {
                if (!this.currentText.trim()) {
                    this.hideCounter();
                }
            }, 2000);
        });
    }

    updateCount(inputElement) {
        // Get text content
        const text = inputElement.textContent || inputElement.innerText || '';
        this.currentText = text;

        // Calculate counts
        const charCount = text.length;
        const wordCount = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;

        // Update counter display
        const counterText = this.counterElement.querySelector('.counter-text');
        counterText.textContent = `${charCount} characters / ${wordCount} words`;

        // Show counter if there's text
        if (charCount > 0) {
            this.showCounter();
        }
    }

    showCounter() {
        if (!this.isActive) {
            this.counterElement.classList.add('active');
            this.isActive = true;
        }
    }

    hideCounter() {
        if (this.isActive) {
            this.counterElement.classList.remove('active');
            this.isActive = false;
        }
    }

    toggleCounter() {
        this.counterElement.classList.toggle('minimized');
    }

    destroy() {
        if (this.observer) {
            this.observer.disconnect();
        }
        
        if (this.counterElement && this.counterElement.parentNode) {
            this.counterElement.parentNode.removeChild(this.counterElement);
        }
    }
}

// Make available globally
if (typeof window !== 'undefined') {
    window.WordCounter = WordCounter;
}

====================================================================
FILE: D/icons/icon16.png
====================================================================
âPNG

   IHDR         Ûˇa  µIDATx⁄•”ªjîa‡g˛≥+Iƒ¬Ä`lDPl≠º≠ºçÑêÉÖ¨Ab0*≈Nº	Ø¿.µ)cësv˜ã›òlíFú‚„;Ãº3Ô;ﬂOñq¸&"ΩÃ•Àˆ§J($(Ïöéo†ôÖπ®é dH,Vyo¿Ì^`•U[›≠¢.‹62CDvyIx`6¶OT>üwEgÑÚºR”∂-O§à¨!SIa)vL(]«Ñ©¯©tŒ@⁄FU>õã[d°∑Ù€∫é¬YïÜM˚ÊÛæY/Tæ+:ÀT;ö9“’!„$¿\¥myl∆òAwy„πõ¶‚£©⁄2≈™Aı˜‚XO∫‚≤ËµaÔ¥ÖöØr“R6Ñ3Z=ø ŸkÎ∂Pxj”¢öR«∏∫∑∆û<Ü⁄	
KŸ∞ÎÉ ¶m˜T6<äï√OTıÂ≠ù"bÀ†/µ¨yf,K∞¢s‹ΩvåB∫&å«'∞ú•5Ö´=∫ÕånßdØÆÒ8Ãrt`Ÿß]≠+[Ü¬/ïQØÚπ˝*•EˆU◊Phπ†Âw˜ü6LÖ+ˆ•é˛…+•∫êVM∆˙ﬂòˇµ?Îç¶¡W•‡    IENDÆB`Ç

====================================================================
FILE: D/icons/icon38.png
====================================================================
âPNG

   IHDR   &   &   ®=ÈÆ  ËIDATx⁄ÌòKlTU«ﬂπw¶•- ¶EÖ¿5]`¢ƒƒÂaàƒÑïÌ5ëhÏ¬ƒ∆ ÀLGÎtl1J"F@bÇ—÷Öí®ƒ BLêF|`b> â“B€i{ß˜ûœ≈‹ôÇPfngt≈óúd29˜ú˛ﬂÎˇ∏n—LäÓËUá„%Ïõ⁄,I±ïÖ≠*9'°¶rå©
"JZ∆ÿÂ¯∆†jØ¸Få˛£`¡ã\dƒyü§¸LØ:¥JP∞¸!]˛”‹ËÏ %9~“På⁄!FÕ*“OB]í‚ó˙˘ïvq?KÜ£å0eJ·Ω0≥˚“58tJ>måíEç°éº®KHäOB›È3ñwcóûé≤Q÷Fé´îˇ81g7„,ßÜ˜0ÃÊ|ˆ~:´~(Öπ"Ai!é™∞Cc®
	5¥®√Î⁄@Ø:® e+øœ"∏|~bà@ÜŸÒÉ$ÙÆRò3E=≠(" ôº{1ÙI@∆n·w‚ÙaË «0¿wÄà‚ JåZíÚX
å–¿^“≈!83M`ˇvº(IÒIeÔ•ﬁ¥„Û≠Íîà“D.Û‘Q‚p	≠„,ø2Ã¿£é}º:~;ËT‡¢KÈ"∂j7±ÿL`0ºÀ÷‡∫ÙnP!≠Û®ûÓÓ«≥µÙSÕ àqàq©°[µ9d˘™‹àU/>(„®9áÕzÇuL‘ˇàÍ^DN“©À0ˆ1å©√XÃ8√<Ñp '
!R∞çr
xôîÓ£é√dxíç“wI:Øª q>aá∆hì#¿ë+ŒÈ“œ¡6\Î*7rãÍ¿aì|KJ∑˚Û3∂iÌ‚ë“UT≥à	”Dóv–&ßÿ¶U0YÌg·0@Ä⁄xÆCL;+ß˛Ñf–…H£Gªx§ıV‚Ïƒ«‚Pè√ZCªxú@iFI–ÑOR|+ïc,oπ,º @èÆFÏvåôOTsÜÉtk;œÀ7ú}	IzÌ+"SAÅW2çT◊ÆCi≈∞kAÂ<0F@å%8¶Gø> Àn` J´çn¶6ã˛BÌ väFó+∞C('±¸ÜC6äå»òhx‡y`∞ã]Å∞ã8C÷îj&¯òÄÁ¬LûT-%ZÙ¨Ï√770ƒ=åÒÎÂ i} óØqôáÉÉ«Gº -°HtiF£h±Èee´±á◊

aÉ¸Å«∏≤úEy
U°Wí‚Gù±nmƒa5ñNbÃ•[?ﬁ √16À!“zÿœπ»Xi£ïb¨EòˆQ\Êíµäa5¬2™© i∏‡-îΩ·¨`ÀÉJgl?Üù“<HZ”ƒÕ3år'[‰tÆ]=g˜P›ËáÕYÀô_J÷ÑÜ£ú‚≤ù—`ê-Ói')πR∞æ)S©-ZåÂÉ∏Eœ∞‘yÉÑö®|FÙˇñ∑>	Ë#∏jù´ê~ù™Ÿñ9óôïäê2Êr˘–°a¡ç≤Êêf¬SÀq•A…ÜY6A[ŸÚC°ò[XG(ú±1Ó °7„1Añ¡iBö	å!ƒ©¬e!æ…ïô†ØT`Õ‰ﬂ!ﬁ§é∑ÅsÃ(®–íb‰™uFxc0‚o*ÔQ%•kpÌJ„Xô¶Pö||â··Ò)õÂÀ¬”H·ø≤"O\nQ˝U˛√›}7∫‚∏n◊≤ r5=¶¬    IENDÆB`Ç

====================================================================
FILE: D/icons/icon48.png
====================================================================
âPNG

   IHDR   0   0   W˘á  ≤IDATx⁄Ìôkà\g«œ{ŒÏÏÃl∂Mã¥M)§≠f)xkS
Jj>ıFE›µòÖVRmmäÑö¨›tÊl6ô$€(m@ÀjD±Xôÿ|∞î5IQPÒR?‘bb.Ñ“€lvfÁÃºÔ„ásv≤≥õtÁÛ!sòyÁúÁˆˇ?óÅ´rU⁄i¯§™∞√Tøyq‚.èôY5WÍ}¶
àí=”œ≤Î◊≤kA[àÑ†‡z©0[˙[”ˇ°†Cbªc@V vn#·^£ﬂ¨¢]üUÅ∞º«¨˝*œ˙?#´>ÅT[πùˇæﬂE@∆ÓaôY≈y¯ä N£Cp‡‚À(ªÁ]õ¯⁄0e5	>É«5ÙzØ∞≠*lïWÿ†	&§“¡Ã•éRíî∏°m‡Ì–ıÙÛ2Á‹ÒÕù¯@ëáë˝≠·7∆@∏9£†>ßV†ug–% ™®MìÙ }ëêiˆ°¸î—äÂ99–j$.Åy=Eﬁûº¿*ãŒ‘[¸yû"gÂıQ&TŸÆO0VÊEUˆhô— Á ÿ†âFµlíF	x}N˘q“≥èÅ(™≤ìçåÒÛúc=ÙêÒåUbB*5É;g¿EœjàÜ7„{#<•IrHÙ9CTÍårVÒäREUë]L€MÙ˙˚”˚	§⁄HùhŒÄ:ˇãHe∑?FÊCåàã(Q¥vN‰¬/çgqp7€ä7ë„&∂ïnFã?°Ë^¬«£óü≥SÔ"@TØ}ÍÂ‡feÕêÁY	ˆ^T¡7wbI‡Quøƒ”ó){áxVﬁaª~ √2∂o v≥
aä4	Œ/–ƒQ¬ê"yù-Ú¿RÖÆı*áÀ1ﬁà˘$.6J cnGº€p≥}†Ç«ßAÄ	6À[Ñ<Dôﬂ#Ó8 Iîì8NÅ{ÎéS¡70àküFYê:¢…#¿cÏ÷¿$}‹BâIf¯<ÅÃŒã‰gÅu Y–(ÁE&ÅI
⁄√oﬂä≤‡∫Ñp∂¢dnIs'¿yù´ój3Æ#¡”råù˙,òaÅÃÚÇ&YAï)¿É$YI^?Œ0G¿0®P¿!1ÜÍÔ+ı•º[,à„i¬ò)~Gâ	âj≈Yî!±$˘:Ω¨DQƒçÉ(o`bÂ5¬Y¸ ™Œ„Åu“e≠1ë£ƒ4	
ÍÒA<	Ÿ°kËaîKà%e÷±S∑÷™lV˝à’DAî—{
ƒhwShæ‰PDŒ‘*‘∏>à# ÖãÛaK/£Ï÷9û#êê îÊ”l:çE†3à(Éè5ÉkÄß∆EùGYc#RlF∏èq}Åê_ ÚN;ènœ U!áêf=∆}ã4°
ÃP<§ÆŒ‡1CÖ$∑”«ò&d‹˛ò≤	»q˙B©å[ÙŒb¿…¢NH$Íèä”ìX∑ë"/QÊ)¸ãj†XR$pTyè z0€©vÑÅÆF¿\bà%‡p8ÃÛ˙™|õ4˜S¬∆ë á%ÖGË˛Ñ3Ÿ"o÷„H•˚)§ö’(IvW†iüÂúÊq˘' ªÏwIõØQƒ‚ Rû◊9aæ¿^)GÌw\iÅ∏Òô©9]Ë£çD›®&øˆÀ<.ˆhäÇzlˆû†ƒ!íx$ Ó__bØî…™œêXÜƒ^îÅ.à#ez0<	§Ÿtz/õd¶÷
OP·oÙê"4õÿ,3⁄ÌR Ø◊”S˝ 0Ü[∏·∆CåWvp~ˆœ¿Yæ)«»ÎAJ‹…0ØQV”–ˆA7¢Öä¡f¯bÚd∏á*é
ñwc¸©æ;8J4ù Ó’8ULß’j£ïÉ¿AvÈ£x|0˘
œ»æ elÊW¯˛ëÊ–È.e’0Ä0$?$oÔìaXˆQPè)â◊/#ôS¿©ZÿaiƒÅ8
Í≈#ﬂ˜ÄYçñø¡¸	J£ÿ&€t∆Ä\Æ^s£ﬁÍ_ˇ÷Œyÿ-NπÓÌù;”Ã˜T˘?IsΩ–®ñ·äîÆ¥ét?
ÁõCåﬂî[VO)ŸπÂÆvñU&≤™Ù„ç6øaÂ»˘µm\∑dßfÒ±∆µiÄDkΩ@,y˚W˙Õ}Xí◊ø£NP:ÅπÈM˘˝Ùrñ7„y€#˙_ßÖ¨&Z}8ûaöè≤úµx¨≠AGtè“|7y±•5ÔÚ£Ò»ÍZ‹ç.⁄ë^K¶∫'◊RÅy„zgDQÄË€úÙ≥W µg∑-›˙õu©ÖA3÷RØÎä†·:„˘´rUñîˇl”yMê(    IENDÆB`Ç

====================================================================
FILE: D/icons/icon128.png
====================================================================
âPNG

   IHDR   Ä   Ä   √>aÀ  &IDATx⁄Ìùyê$uï«?ÔóôU’›√° ^J∏^† ‚±¬F†`(^ÿÕe¢B¿*Óà3√Q]8”s!∏*¨Î≤∫Évã«ÍzÖ∑¨≤éä·2ËÆ°ã®ã¿tWWWe˛ﬁ˛ëø¨ :˙Ó û.ÎELLWU÷Ø2Ô˚{◊ÔΩ˜É>ı©O}ÍSü˙‘ß>ı©O}ÍSü˙‘ß>ı©O}ÍSü˙‘À$´˙Î™íŸSjáß÷%Œà&◊âˆ!¥X*™°®~o<å
Eı)™ÈKÄÖ–∏zåHT}ÂÉá»£?ø>ƒΩˇpÀ˜jè¡¡–j;û¯ßê›èŸ?Î≥ı–≤Rp"sÎÃÒ‰ÃXs2÷<±ë‘≈j¬f≠´ôE\/D‹7}ñsa˜b¥M]O1∂ä·wﬂb*¸gJ˘ªQïµ¶$ÊJ(€ÌvﬁIŒxÑ@¥ ¶±àkñyu¸<„{ÄT©Ÿ›\È]MQ£(≤6@–}]<éaÀò›√¡Êl&±L"7ŸÇ∏)U +çUáÄçW°ZC˝⁄Ùw”c¥33ë"Òı±S„’«±∂w∫.="£Ã`÷ô´ÿQ;öMº>˛5e-Ä†ª HÙ‚u·fˆŒf?U @Q"§e•	Ä—f÷ôfÜ4ØFm˙øy˝∆ˇ«nCZELªcõÓ≤Æîn|É¢Ïß∆:ˇ\vXaìw.®Y Ë äjëà‚‘ë‰‰ D(Aù%xêRi∑L)¢Á˚ûvpˇÊ¥Ê¯Ì0^¸-¿ `äCÊ∂◊`≥¨	tS¿ö xù4î	›D)yÑ
ˇFƒ«∞·ÉT—xfór˚a˚K?≈,ﬂá0ú„{È/Ö…ù∆◊˙€6æ%wQ`=UlC<’ˇò§∆:ˇvDñMÚ˙]∑‘Nƒ÷ıgƒ 3ˆV6y¨I«yLˇàg9$≥h$Å9è±(bãú É†õ ∞1œÌ®ë∫T®¢ÑÊzTÖQÓ!bx0˛œÖÂNÖƒ àò¢∆O)|*D^]dﬁ¿ˆHŸ,p¨z†ˆ@s3à»•ÇdBƒ4’ÚC»êR‘ê	±L¨ UπX,cë6=ì!OçÛ®ÿkXgﬁ»$5 h®s>cQçyKlX Ë~”¶\+ƒ*¡‡⁄ç°€6„“Ggrlˆ.d“N0D ‘úzH$¡õŸ›ÃàDåcÅ±ø $Æï¶&≠Ã⁄%”‚Y®˘Xín6g3i?≈JÕ]É`–\¬òæ˜@Å…l…=B¶Âyò±.Ë%‹eŒf“ﬁﬁ&	¶®±é∑±-∫Ò@AvªXiﬂ=,Ø]8X€˛^‰ûl¬8ñªn?´MÅ†L»¡ÊÔãn8P@ê “è9∞¬ß’‹^÷q7ä0>É†L3ü)jd6∞=zw(√[Md  £mìµF‡∞z ﬁßöBtÅÉü˝å)x)î§ÇMú≈T &HÉ`ùycµÎ)I∏ö »¬ê+e˘t*QdO±FNœ‘hﬁ∂n®ÄN ®ò≥ò≤üMÅ 	á¨Û/gLw≠&≤P⁄¶ ÂbÖ(pòPTCI¬ÃfL“ ﬂÔ£(3Ã4ükÒ< ‘8à+ÿÌ\-dkÆÿX*îƒ≤Ìë« ú@¿„¨=Ua<VƒÛ4@Ò+Üô≤_JÅ@RÍ`#c—∂’ ÅYùü\ﬁê£n'ë¡◊í7«"Ÿ{" >≤K4]|àêﬂˇÍ5LÛÂ&uÉ dùŸ¬ˆh¥ÇûıÀqU8Â¢Ÿ@ÑR≈bÃyı(Fâ∫ö§©- ix#˜Là[Ω©NZﬁ˜‘*˜ˇÔkôÊk…©Gôê!Sd[xuÇl<õ"Å∂%`°∂d/@(0"O>~ÉÊÈ‘∞XîCÿ˜ª7C±h∫‰¥W1 ¯MI,√√8ª$ıœ≈˝KÔâﬁx‘4eŒ†bøŒPºŸÏFçApê˜.∂U/ß$a‚È¨m §ì1t´~\=ä*î§ v&Ôç∫›7É‡1Mƒ†9É]˙.JR*YäÍ/8	TUÊπ6û+1H∂BÑ‚±ïmïc‚M≠9∆Q˜(…øºˇïT¯:9∞NxTÆgGıELH‘mt_Ã4•a-"®*L∏Iëàó;¥3|;>7`≈–H“Ú(1¿’Ïå£l6RíIJƒ©i˚‹DóƒŒŒúIÄb8œ˝m®9ûÉÊ¬Òˆ^ûÉÖ®ëEú7…÷– ‘∞6Gh“ÈfBÑ Í]èÍÛE◊6 í§ ¥4†‚âãô^|`Ö√^Ü/o'g^H≈Â˘µßÇ&í‡ß≤3|°w;#Ú¿úëƒíX∆Ù˘PÉ-πÔ◊ﬂkè  |äi∆0‰P,CÕ%ÜÃ”RŸàsK<q#Ü-N≤`ò¡‚õÁ±£z<•¸]≥‹œ@Z‘≥<ø»øégêè÷ÉºÃ©‰y

L9q‹û,SD‰x*9Ô&f∏ñù—∑˝UªóﬂwÒ!¬‘ûº,∆ûáı ¿˜ÎÔµZÛqíÎ}ºKGy4;Ÿ_˜È„ƒ–⁄"Wkúç,û""á1ëw¢Öª:ﬁœZÄàQmÕÂ&b“DØ∆ìK0G"¿$`ÎY≈“—∂–∫Ìm®R#"`à«¢fÑiNFdÇß3îID≈Å ôÿ1&ÆI∫gFéH‰@∞ã1=íÉxUp¿.ZXKK®Lú˚Áû√Fˆ±›Êèü≈¬o{‡¡yE?\Õv`ª´Î±ﬁ∆úÀ O†X¨K«&]Q‡§B¸Ÿ ”‹Kô=ü·
~^|›ïi∞â•®á¢LS‘AJRéçπv¡àƒnÊπå±.rr%Åy:~ú6∫däÄ2ßlw—tÅ ≠õØ»Ìˆ2¶;–Ë≠o3Ü<°ctCîÇbÒ1(”ÃP>¿“®ﬂVèâT˝ﬁ‘Ñœ'ÔaÇ$‡Æ†%ö5∏É‡£ı_®ùH5x6:€‚Yµ£¥◊7‘*∆;öúySìQ£Ω M4˜A%±ı≤20lëˇJl≠~ÖBiÔDØI1_Ä?ÒJ6…ùH±Ø]BõòÒ˛=¢¯˙
åªø»º¯∆º≈ÜMPÓpˇñN≈ÍzÃõ∞Œø©–Ω&‘≤pcIî±ûV>Ñœ≈r'€fNßêªè!JBƒTÌLäπ;)jéµŸ7àT(I»@y%a2ÌÊUÔ›HâôY’@Z†¬0&ﬁù\=èâ9¥5f⁄±jÕ†©l	{±mP£xwé´Ú?eõn`q^Å•Äœ~ªÉbÓª1Û•:˜ä√£§ááß1ËÈ∆ÅGaè<‰s’ß4_≈ä(,Ω,|\ï∑Kƒ6ç:ôMΩ≥†©G[Œ^PÈYU∆’„*πÖi~HÉGô®ö]Æ:∑6Ô8˜∏0≠Á_“!xıéﬂø˚Ü¨eëﬁ*ÿñüúËg√çêCP{+%y0ÛFı∆’cÀ÷ÍzN•Çı è
ñúy1€kß‘ı|6úhNú—^Ä1+ü<ÍDÓ_`∆˛â®Ö{@eVæìËˆÇÎú◊`õ2<≥#”•∂X “+ hˆ“W*∫§å´Øxs5{?QÓø¿¥[˙ùVˇàDl’óQ‡enC…OŸ)"ÕÛÿ^Ï¸˛Ó€J~áëtﬂ»`7∞K±èdÔ˝€ˇ˚Ê÷ü7∂∞•¯ßÉ…Ÿõùœ›~b„x|ﬁ€Õuïßf≤56±_≥≤@≤®“vù∂9Å£DŒE˚
joôﬂh”8ûPÀ‡a¶`û‹T‚›¥ycímﬁÉ(‰?¡‡¥´â&~8K¯tÕªÅ6˛,t/`qn!líü?kè:Ò^ÖQ<J≤CK2Bô”·˘Í*VC<ó«€=lÙ^„⁄¬umgn÷≈”n`ˇW∞8pæDéDtó$dg∏ÖÆeöê$õ_Á∞[ƒeÈòWsΩ~í∑˝"Á¬¿+øpLa•-• ¶}íÀÉ+∏J§sG.uM'$bd_¿nΩôo",©n?-¶Wk +N⁄Ã3¬ìûÚUäzîÀŸ3+jÿpU
C≤M…Çb=m	Åê≠’ıºõ»s"e∑Ú”¨ÓîSêNË–
Ê≈d¿ŒpW mıﬂ;aÑï™˚◊Æ–ô@åv]®%Èc˚Pßü-[ıâÏîÀL‡òÔ∑à¯v h◊5¡4Åy,yˆ∞;:ü(⁄ &π#>ü{P&ñ ìjh'ŸŸ ŸÅ⁄í6∏Ç+˝Xëà$}lá>ü7¢\HﬁFò¡Ç€+l◊Ûs[›ö∫R®°Ñ(sbNcwÙU0‰˛˚øBI¶ö‚ √ÿÂ⁄PHLÕŒË> ¢Î%J√íï∞[è@x	p K»ì£L’EæibxgÅ;ßKIÑ8\î§¶òó/Âà#Óeó~j∑3Ïu€ƒKaE£î.Í`ZV€J–n¢Z=„=œ;k_B¡@(¢xıü.ö·ÅDº¬c Å9ö®‚gÏäæé⁄ØÖw3S¯ıºÆc∏j&˙¢¢T≈/OØß‡ÇÉΩ[9îsÃ·LSeö™ÀˆÎ´VWXòJ BçÂ∏„!Îx&áò∑‚˘∑!π+x¡"öTß6Ö∫œûlÛÃKî%±î ÑoS‘ı¿ÒLr&b_«Äy2JúWßN<KΩô[ªïø]ölÉx/a¿µè´Ò{ˆÛUl¯Yø√fÔœ ºo¡ú–,£xMf‘Jô˝BI*¿ù¿ù(·qñ1ˆtÚ∆c⁄ARÌdÖÄ¨.K…√#èOÖ25æÑo√˙_cì<‹‰°,®Ë§…Ii4§^˚¿¥KÅewmJ≈*…$p;p;€ı9`/√ò◊‡S!B1m˚Ìs3x.	Á!‡QÂèT¯aÂüÿ2À%{  °ﬂnöˆÑÿh∑æ∏¨‡ÖÄ†ûä•¬∏ãlñªÄ7≤UˇCâØ§
ÿzœÖÜa:/”<>U¶y¬çlî˚cf´«pùÈ—28!d^Ö  ªr∆M∫˛.I·ÆGÊ‰'¿´ÿæÅ¿ªÅÄ√ò!t≠Í{ E¨ÎÒ©r'µ⁄[Ÿú˚Q=¯◊FÀÍxÜÌÆ`œD”‚_Ã Ç∆wé§Å/åÈ˜ÏmöıÆkπø`†(Üà| ¸#e.£îãÎ˜Gâ\»y%Y°Y:iŸ5äl®ÑπïøK«=™I§ÅêdÛlë_rø9Ö˚eWìŒÍ⁄iìVÑà>eÆ·JπîQ"óçvΩ˚∑±Ω Ä#Pñ·÷„NóKÙZÒx3∏˝˛ŒÆcúÕÛnôb“úAÖ/0ÄÔ∫stŒ¡K‚‚ƒ~9ÂJŸZﬂÓˆÈ`BVN¿*ÇtYBZ¡T9DÁLùpı|£DLr3ˆ«‹±5Ü∑2 ˚ìˆ£lÒK\§%¢Ó≠˙A=õ≤<7@(ÒA∞¸ 	ıP&$ö3⁄VÀÜíî	Õ0πÌ!€¡`ç≈˛4wÛ˚_]¬∞z|∞©§ºªÎ?√ÃÄl∞”7Ó∂Êo…ô£(0»@t&¿¨j†Y¯lñ_3√eÆÆøı.≈πçï⁄ÖºÔi3ìÂiç;“^»
nc˛2mÄ§†”≤!Æ3Ôù\§«¢ÛˆÿK:pmëè1Õ∑(‡µú`ñks≈‹^äÍg|"hKÄƒ≤Yj$0Æ˘œgÄSò!"ƒ2»38ö´\ÛÂ`^[OªﬁHÑ≈∏ìÃ,ä¡cöI‘\ÁTäÕxÇ4À¨‡lÎdâ&¿∏zŒı™≤MO&Ô›Lµæ·c(ëÁZvË%©Rƒuù#Æ˚÷ŸK’~ô∆µgä( Ñˆ„\-øcÇÏ2Ä˝’aOvuãk√Í5π]#±#<ü_D$™˜◊™Qncóæ£¿Uu√pO07∫ä|©ßÇW√õ@Ö}´ù°ﬂõAmÄXXÉà§ƒkx‹„ƒ·ì˚N|Û2◊otI¥f‰ÊkÄw≥;:570≈óëÚ¨R@U·õú¿=¯ÉTÏ˜(ÂÔŒ4ˇ◊gvõAÈdÀ9m ﬁFé«Õº?81/Bx6æÅ∑≥'uÎ]R°€Xèóâ»õ†ºÄ!˚vEﬂ«Í◊òﬁ;•C›6≠≥ËGÒòêêt>[„xÄÓIÕ~ÜÂ·≥D&{B4ÌoÕ
÷8{†ß‚ùÑgN#‡Ÿ‰Äj›Ek‰Œ ,ˆsí	Ëô'aÃqà˜,84◊¡M¸ijV„S¿´_ .◊ƒât÷B/Â∞àöwIÚwˆÅçÏö˘kj˛πàπÄKŸµÑëñùª~è*˜QÂ√»Ã8Ô,¸º$Õ¡!TÿƒœŸ…Ø±∂¬5Éø©wÀ÷9í’V)∏ÄÌ¿$©bc˛ßlÙ6QÂ8f∏ô∆) mö0É%á°¬{é„
π.fæ´öÕ#(‚Å®Xˆ?XP@);{©áz-V∑%¡ó$ˇˇ*y ¯;vÑ?&Á}Ñ–Ÿ±‡∑xLGó∞≈ˇÄ˚^≤OoÁÏÛ„b¢·Eâl:Nê)Ö´bìØNØ‡≈‰$˘ˇç.a∑0¶èc[)ªÕúA<ˆ€˜pïˇ>®.xüﬁÕﬁıπ=$ág˘ã)ÁkoÅt–ˇK…Q.∆Öq£ÃO0x¶˘-Us√Í9Ê/~OåDÛvÈ™Jõ–{ùAÉKM	J+Jmwáµ›DI ÉàG¥/ ˛™‹˜ÍÅµeS"nŒX>œø£äR´~“yñµOôáfüÀL•à«Â2-jøCdˇ;v›`ı#w+¢»RdWêÙ
∆¨PZ∏äHÙ]T˜k√u{@hoÅi´ì¡2èv¢ÏÙÃÁ˝ZÂ˝≥ãö5D˛ÍÏØI|'Ü^iËæ‹ór◊0uàxΩ`¥2+iÿ®Î⁄’‘Ωl/HÄtiò¨SâdÿK#CNdò∂
´«¨\Zx/Qsó∞ÃJ√≤UÍ*@˙üUÙZiX'*˜˘›fÜ¥Ÿ ÙBiX"∆“È°Ù%¿\n`Ω5]/V)‡kﬂò]h£|Ωó
C˙4'¸)aΩËÙÖˇ¬ΩÄﬁ @ßüÏ3|ˆ8@Øùf˚^¿BUÄd/#≥ì È«Í{ÌTÖU81 É@Pü∑V´0Wƒ˙ X¨–S’¡"≠eL‹ôC˚∞hp<NgKz™JvÎ”Ôæ ∞Í Ï5ñy"ˇ	 øÂ—öcX√$õ	‚ÃÏ§ﬂ^ß˜[ﬂ#u=-ﬂOèë¶ŸæÀ<„Ãı∫”˚√≥åù~û} Lx$>q√ãd±x›ó›[ÖEı)I(€£èÎ†9ói"°ÄG’˛;WzØËØ|GóÎGÿ;Õq‘\±˙ >S—lÒoMÊrMJ ±—^s^˝Æ
Jﬁºúù˙M,∑Üøèõ¨áw®)(“⁄÷ØΩÕ_ªÁÈ+fâá0%øüDÊíøì{jΩøŸ>Kè”Èsﬂ„~ÙWx\äoéc<•bı˛s_˙ÄÄ∞’‡v l«#ÁdÄP≈íÁÑSà|hΩˆ€`æS€êE<Z∫u¨Ãv/˛õüí•¸nrΩÔ≈xÆ∫ûÍ˙OÛ]ÆíüwªOA˜ êúº="˜Q™]œa˛5Ïß
ö1T\Y◊\Ÿ/ãÒ ‚Cœ5^Î!Qù∆ÍÙ˛lcŒv<MÎ{µzÛ‰∏ÅIö]D∏ßª>Tó-q◊≈{8ﬁ~ÜCÃLbÎ-◊óí ∫‹P7 ∞¯¯`ˆGóŸk¸˜1¨^∑À’2p≈\”áûko$0ó 5ß$zycx!Ã7≥Åä˝›¿µ˛û˙)Ák÷hÛs]*˜÷ÍI¡Ö®}1jûÄ⁄|Ï¯®§qsø?ô#@"“Ú~ÍÑ’∆Á‚^œ&ID‹ÁÓÉ9%M„q◊ÃÚÖd‹N™Eƒ"L"Êàj_‡¡ÍGπ~›˝Y¨¸å‡SDÍÕ∞z√cò|(›∫9±L‚©öBB©ü˙Áî∞‚Æ´ Öln}¶˘‰EÅ∂˚LÓo~ãÀ›ø£ê∑>0‰°˙5≠¸’£¢öz˜è>πµ·∫òhˆ——U«:€`Ù/|ß`]≥%Ì}ÍSü˙‘ß>ı©O}ÍSü˙‘ß>ı©O}ÍSü˙‘ß>ıÈÄßˇîµé—˝ºR÷    IENDÆB`Ç

====================================================================
FILE: D/icons/icon64.png
====================================================================
âPNG

   IHDR   @   @   ™iqﬁ  	?IDATx⁄Ìõmå\U«œ9wfg∂X®Ö ’ê¢b´¢¿D‰-Å"%A .&Ç≈T	/EÈ∂ªÖùé–›•m¢U?H√À¬.÷`bh¥ÖB‘"Dm@"DILT¢tÅ∂ª3sÔ9èÓ›ŸŸÓÏÓÃtf∫ >…dfœÏ}9ˇÛ˛œÀ=∂`∂`ÔaìÜèÃ©LÓ—ì?ø`ã'ˇqΩ˙†*à(˜Ë9¿D,¬Ö“2$-FÑ4PªóıÚ95‰Qm& A›+!‚p€¯¡Ñ©È∞*sèM3;}(Üt+§áaµt´o&R«‰ÚqwÙ5é≥˜3ñå;∆Ãò·láèÎÄL9÷ƒ#‚„œãÛ?bΩΩ9Å¶Å‘ÕOkøé«£¸}ì¢{#Yº&≠JG¸ñ‚óXs
åsÉÍÈñ[õ…ÑP©P‚≈§0Ù√Ù•vµL¯›8Ú‚?JhN%À-:O∑‹3R›ëÇ‘©ÄRAÎ√jyD3≤·Âÿ°(i û£P∫Ö Û%ñê5k–ê>ÈiA√ °FËGn
;ög;ùr<˘ÏÎ‰u%ù˛	JÊ˝t≤é!ulêﬁ#¡4Æô5ŒyãûvDq\|HN9yÅ¢π·-J(60Ë»KD[fgk®Tv37‚958Ó:@MÃ∞úf∏C^búï£îP≤¶ó!∑yÑ÷†ì.‡gFºK-95d8ô◊“¡«‚U|™óõHäp‰4H Õ–//R‡JÑCD@∆Ù1§yÚ1¨∂=òm≈s∞úD¸::…`Ÿˇ}°'ß¡4ó–*ÙïƒﬂƒøèºD‰•@^
 ‹)ø#‰l‡oÑDdÈg@7&ödZ,ÇIrRÕb1ÙâÔØ≈r#£Ñtp5[tÄÈ´*R!`95ÒyÃªÑxåYÕÄ˛u˚âd‘§(œ“aNaúêNÓÊ}ñı≤á.µåàk]®sõÑ‘¶Oí·bî´∞úOò‹l	Oö^∂Íe(;âÿÕÈ¸æºbôËJzÉ_$Jn è∫˚Ïg0,%Cˇ¥4YÄ&Ä
ä˜ﬂ ˆ∞ºˆ∑9.† õ@¢”¡_Å·¸Ñ,æºfÒmûÖ·BÑ'˘CúX¨gk"îybP˙Çy«ıc•òL∂ÚULéNcR85'‘¢jf@@+E0¶∞èè±Mœ¿Ûc≤\¿8œ‡ã7∞>Û⁄dâ´Bñ3»p.ÖpËta»ãK™Œªÿ¨;Ë‡4∆£4&P|$ÀgÒ8¨πùåπÇ¢èZï
OÇ0[¯ÎRÀrÑ€ÂUn”ÀY∆≥√«Á5˛Õ*∂fê”ÄW&N(ÍVsåÅBÍêÁYû¢à“•ñçÚ&ÊiÛµÿ${l 5∫‘Ñ‰4M^∆“RÏ‚ w±U$„%TÖM€u1ÆÁ]√W‘A
ºS¬ëÑ	›∫™\ÔüúDƒÎ>›h)fÍpÚ©‘üç	yBPaúßyõ?a«ˆ$ìéKÁ‰≈3∆∑…r"EJd8∏ÉºxñU(ûà2"éÓ*Ø˝ƒÔÂ4≠ÄŸ5`:c4	ãL‘œXÁQDî{5≈	˘Æ~ö4Î)‡0§«ëf-õ√KX#!9M∑£€Vø‘íWÇ–ìz|JuçÑ‹•ßêe'êI"ÖAìOô‡Qı2zÂ≈rfWsƒ∑
Ä√WæF‚‰‘∞À?pÂ$iH/#˜cÃ)ï'Ç¡·1,%≈ì‹›H∑¸tJGÍîë*`HÀ–†UfÜ€JgCÍVÑÎQ√î…O åâ≥?”ab´ª1ﬂÁ {»Kt]†≤±gj®UÿNö"g!|e% ÁH0ŒDŒ`fPnÉC)†tòï8V≤à}l—›ˆRz˜∑Ù-ﬁ?ìF∑A˝"®qÊ∑ü,y`-ã∏8ô|4YLÃ*9Ç¢ÒX À'ÄÎ¡ØÇ≈KÀ6a:çÂ2á¯≈ﬂø‹	⁄œ.¡-Æ∆ E2K˝Æ8≤XBB"!‚^‡iFlúgÙïu·Hür4ê‘[#JèÏÊvYçrûÈú±è®Ä£K».îsX'◊±NûdD√j´ñŒì›&‘s˛Ì*úîL∂[û·f=èìŸA'_N\"®xV‡»PÙÙÿç SBa˜%Æ¥3öÕ&Vjr9]âp´ÂáîX'_°‡Bñ è´†}¿8CÙÿç´•Km9Îõ+ê∆pÕ Y¢¿(≈q!_BD≈ƒı?BNáÃ¸>:∞@âñqˆñ;Ω]¯Zõ} 6j@µ(∑ƒ“¨ëêÕz"ñ’§X≈†ûzXzk»K	gnB—$	äPn‡tJóh^•¬s'>%Ü}àÄaÑ„í´ÏdPØ¶W˛Zé•√jÈñg‘_≥ÑKŸÔFü›óåªÜf£-@Á AÖñltApûn«S¬£iŒ$≈Kl”ù8v2∆Øx*˜óÇøØ\&7‰ímKÑ™hÄÀN ˇÑ•ÂN›ƒ˜ 1¿bVº˜˝≈ÚFyç‚°ÁQÚ∏∆Ô©ù.0Ω%≥E?Ö)Vƒì˜Øô/“+úvûÁyã≥‹68ˆÌ)Udc%˙—rÅä7äaç¸ÅA]E¿> Õ¡‰3ØrØ¶XrX<«;ö”ò=⁄˝Äxbéú¶Èï7t?≥¥<˘52œ¨Òñÿl∂Ç§´k˜™¬Zª”KÀÇÜ0õãnﬂÆªâ¨I4¬1≠Ò˝µÿ≠RlÔt⁄í
◊{ïyÁ—Õ)Üj=¥=)mn€Ä6F∑˘h¶ÒCÃ{Ä	f{ô7≥ê∆kÅ†˛K˘$ﬁülì3mﬂ<]πÄ√jy›∑mõú"yÄ_D∑uG9æó pô§!"-@¥¸ƒVy'Ÿ∫r-·S›_ÄŸ∑ ñí˜tﬂïíœ•*cïÊláíÊLÑÀ)°L>F7µ™tPß^x<b98âT8ÑS√Oïku‹APe<ò·8l≤U=Ê·ÂéRK*Ë	∏ê17”ÆﬂåÃïóEæD—l`£|orìUÀZ*  @È\lÍ"ú?7[D0”„ç˜5∞‘ÄÒá˝Àa«X£˙&˚˝ÚÁz'ﬂ∏=’o˙=5À'ˆÕõá?¨Z∞[∞˚∞ˇ	°˝y π
∂    IENDÆB`Ç

====================================================================
FILE: D/icons/icon256.png
====================================================================
âPNG

   IHDR         \r®f  CJIDATx⁄ÌΩyúegUÔ˝]œﬁÁú™ÍÍtwH!"WÑ4` Ç»EíÑ^Ñ€%(˙"JÇÒÇ`Ç!©>Ië·""ﬁK‰™º Hó2(ÑA!Å(2â $äêH$È°∫™ŒŸ{?Î˝cgèß™ª´ªNù~~üOg⁄”Û<k˝÷z÷ ´ 9~o]≈ˇöN=uœ¿	Äcª‡˜`∏,]±n¯◊≥j √Vî¨N Ωâ∂aF¢¬˚|oäLµŸÑ˚Îü√>`SÕ{uÿ¥¬Î)ˇﬁ≥JddŸcÓ+Ω∑Ôp∆æC∏–∫Î<0∏No„…~„˝ÿ‡ªõ˜¬ø3ÁÑÖÔÔQèmXƒ	' V{‘À˛Â˜mbjÍlZﬁ≥¿ﬂJ=ò∆j¸íø5o%hf6h·Ò©
"JˆâÇ"—Ï3´…Î‹¡D@u˘Òë‰8
’≈ë\ªU¡†(Ç†u_!{˘Q∑…+CrâÔ]$>¢Ò≥ æ◊¯ær ù@JÁÕÓ"˜π/O~àFﬂ« ø!—«˘˙˝üÊ]ß¨åôÉ á«ˆUÿé–ÀÂ˜ˇ∏lûz9∆ü—∂y%ÍûÄÊÊ5•ˇÓS”¸¶n°6ù´¸y”˜ó;ØyÂ„È*ÃñÙx…øËŸoK`ﬂ©˜¯¬…òUCufÅ áG˘S˚~GˇïtºÌtÃ&z@Hîi t*j™˝¨†¶:aﬂ,çx—IÚ≈"à1
V¿ÄZ¿π–“ÁŸ+Ω/9Õûˇ∑ÒòÈÒL›Ò¥pÌı3B—íj◊ÏIÁL·˘$Á£ÖgS<∆‡óÒ∑‚#¯Z¿˜D◊qµˇ«ï±tp`≈ãˇ∑oﬂ"9ı/tcÎ9,ñ0ßs™⁄≥NÀWß,ïIÕñp$Z≤ndVzé&∂¢U∆æ"m=¯7˛ü4|;çá7£,`Òô ÊÌ{∏ıûóÚÆS:!‡¿ iøàÚ{˚O‚‰©è±¡{(~fÀ≤‰∏®±äOïÅø‡∞Õ]Ò2©ÍœÏJÜ–ˆ¡ßE≥"]¿⁄ ∆(i{iLUfêgí›#á,‚ﬂEl¿g>˙gÓ¯ﬁ/ÚøvøN ,7s‚-æœ›=¡â'íiÔI, ¥jÌOAõ ≠|dñÚB¢û@˚}ù84^è¬¨Œ¥ÍÆ!`öÛ—ÁπÛÓgÛ÷á‹ÎÑ¿—ÅãªÿÜaF"6üÙGúP≥¯ÀTXWDüãñ∞4íÏ‚ÔWvÏa4z†3•ñïπVé/9ˇ∆ L≠5=t≈ø[â)¢Cﬁ´{vÜÛlûƒè=Ë#¸Æn¶+6âpp ø¯’cN"f>G¶¸óp–Ü¸[…“¯4§·'†ŒﬁñÜ˜§§üÎÙ‰rRr?m‹r+Pı¢ÿ†ˆ{uÏFjØCK˜S'àÜqÀa¶ìT8Nã2Ì=ëG·∑˜nqB¿ô UÍØ¿ãÈìˆ´LôG–«;¸ñ”O6±_µñ¨6;˝¥`È6€Ày[\:ΩLÛÛ§ΩÍlÀ_I3±◊ä`´nfÊ≠πﬂJÂH˘sÓWJ,§¸~yØD≤ªÚÜ¯ñÛâÑL·3}ûÔ~Ô<Áp`ÄYıÈJh∂˜~Ÿnnˇ=B¥A˚&gÑ¡£ïMv›ˇ’õ~∏ûÅC›YXÓ∫¥∆j≤œá≈>‘ùßÓºÈÔ†?ÙﬁV‚	ô∆g>˙,_ù6ÔﬁÏÑ¿*¡_◊W[2ç|yqÖÍj√‚üƒcëà{¬g	ÇE"£ÿêdˇ>ﬁ«7v∞≠n»m±€‹πƒ®¨"jEå)˝Tçgc0j’4|DµItû©Ñê?V˙É¯öm∫o0Ò«Üd_ﬁ
j„s˙…˜¨ÏŸgÁ‘h¡≤ÄX…ÆE–Ïˇj≈ò¯ÀVå"VLr\ãg∞jiyOe <ìãbjÑÀÚbTô'` {2èùæëóˇËYteø«3H∑˝.˙ﬁIÊ·ß|”∂º-Ÿ´ x,Ò>Ù∑≥£ÛU7¸«Ç•ÖØ‰$ÔMÃ"+T8U!ûöe!Òôè˛âØÓ}6yí«-ò√ ßù¸SÍ{[]©5î“1Ö«o„ryYb>∆edtÁVàmX·éA1~°N$>ôÚ˛;èﬁ¸a.˘¡˘teﬁ	Å„Q ƒiΩò∂˘ImQFñ•Bñ[xÙ¯Oæ≈ÀKŸÅn“=ˇt%‰⁄p˘g,ÄAà˚Ö!˛¡gÅÄºßbw\ÚÉù8|¨{h#N”·>KÃRvnê íòácÉ»V˜3¥Ú'"‚^⁄,∂ô-1Ö¯-∞¡;õá<‡√ºËÆnã8 œ,∂b¿ˇ*ô„–·çèY.^BÒñ¬ﬂ¢«Õl¿ a%>!ç8ƒ!¥&4N‡π‡{Stç«ù ÈÊµK€`¨t/àr∫ «24˜0fh>∆o˚?‰^.‡†˝"ì¯(aÂHi‹ƒ¿<à#ßÕ”yÚÉﬁœyﬂË∞uB‡x e«ëRíkÒ⁄ÅÓ5ÄzZ–¸ynñ‹aû¿Â ˚Ãy,ÿa2q"ñ«∂xÖÑ	l2ÁÚ¥GÃÒ3ˇ‚;!p<	 Fíi-l#ızn¥◊ƒI!xH+B@P˚†¬ır/wögq–~ÅâZ&P6&bü¿<ÕÖ<Ôå˜23ó8]·◊Ò qé∫Xˆ¢Û…s‘M‡5&UñqÜDô’6oï{˘˛¸˘,D_.0ÅÊ¸Öò	Ã€êÕﬁ/Ò¯Áˇ]îÌàcc/ ≤ô˙ƒî¥ñüè”kbîvî∫Í@d\[âÿ¶o›t/w/úÀÇ˝RÊ–‹˜ãC–¯Ï'`⁄¸vÜôm:&0Œ> -'—÷√Y kJ–*π ˘≈_∆úƒB‡-'¸ê{Œg…~-«§¿ ™¨"ﬁ"‹‰øê]¡;! Nå© 0v-Ãπﬂw`M| œ}éôÂóoX/ﬁ∏Ò~dûIœ˛[≈'PW_ ›"<@¿¥ˇ"vFé8!0∂¿JR+ªLˇ©∂¢ÑÍ| kcüIÌ,+koÎK-ÿ£oêªŸgŒe…ﬁö	i`A‡sêêMÊ≈Ïﬁéàe„Ñ¿∏ô ≈#⁄T±G@$n‡◊d|–⁄ÄÎÅ¿.òg!∞[~¿Ωãœ`ëØ|uçı‚,¬M˛or]ôë»	Åq ∆§Ì:¥B¸Ûq‰ùQ_(c:)Û˚1MUâ`xVJ*ﬁ0}7˜qã	®ãlÚ	lÒ_¬µ¡€ù7`mqºk∑ôhè¯B”&˘öIuu”ˇá!+boêª9∞¯Lzˆ´µÉZ˚ø8N`ãˇõÏnpB`‹@:—h∞5G}iÕ~≠Õı∫i<ÄßÕ˚˜πÅ±+ÿ¶MÖ¿ÆÈª¯—‚πÙÏ≠µqeU 9¡);¢ˇ„Ñ¿ÿ¯ ¨ ∞RVi)âQ⁄Á1öŒ£û/Ω+ˇﬁ¯¯ ")ÏﬂÁeÍñQ¿˜Wñ õ7Ó2œd…~ô>6'@ÉoAÒ9@¿&s1◊osB`,ÅL≥7x•%¨◊
IM5˙Ûà<	T∆2UπX‰º∏LWVƒº^¸°‹≈ûEèØ2ï˘§‚™2ÅÄ-˛EÏ˛w&8>Ö¿80 ©M *”¡h„ ∂'-JUŒPﬂúÃÏ¬i±I0f·´≈≈^ü`Q§B‡çÔaësÈÒµBú¿–¶®⁄‚ !'¯/cGÙ'Ò±éO&0ëÄûh]«-Õ@Ø=Z< ≠ix≈ÅS@≈¬D˚g„o/∞\á"lxËã/]πõ}ú«í˝:À&•‡«L¿¸6;É∑ØL`≤≠(˘ˆîıìo‘≤Áíg?—zí∂Õ"@Ãy l={|v¨-ÚÄ∆¶ß˛·ïÛ ÉÚ=ÓÍ=Éû˝F)b∞m 9s‡ '¯óp]Ô≠8éÑ¿0 £öRÀ DÀ‚Ñu‰‚ ˚üvÎ\|‚˙˘p≥_k«~Ä1ôÑ∆‘eeÛ¿A≤V*˛hÍòg“Á[π8Å|´Ú∫Û˚,rb˚ÆﬁÃåDÃ‚/B`ÄMw–´›w09q0b†+!€¥z>!—2?A˚ëOÃöùéÖ˝oÎªósÃ∫jS!∞SæÀ˛}œ"‡;¥Òâà≤355dKw6˚Ø`G∫/B`,@6°Ü’%`è∆ìÎå‡gi{èHJö[Zûº∆(((ü≤˝ü—pªzã,õø≈AûEﬂ~ü	<4√œWﬁÏ_ u¡Îé!∞˛@DìÜ)nç\(∞("øñÙ0∂ÄOªu3ÿ±ˆJg€§’uUÖ@Wæ…Ω¡/⁄;Ë‡aâjœØ9—dÒô'‰ˇ’\◊€q<Åq®	®C?IÇ,å»6†™∞À¨ûÑoûOMÍ‚
!x º DŸé7ΩëW]Üi_Ä’d≥7˘º~‚,ôsâÏ›!På?êÃ è%B6∑Øbg∞}‹Ö¿xÿôBsπ®4‚¨3"π €ÒQ¸Ë:ÊDB¢Å£ J,ºKyπvbf∞Œ'û•¯ÉëÛWπIK˜úêYıπFæ¡|¯LBb!†%Œ(µä√cÅêiñk˚WÑÄ #/o_VSAF&0±\9*yeb˚{9{Ÿ`Ÿ`aN	.éõ]¨ÛâÁm™ò5-7‡yL≠˙πªÅnÁk,,B˚#⁄5Ê@YH"ñŸ‹⁄¡µ˝À≥c90j&(÷ *WüI_˜˙k≠∆£+ñÈ…]Lò∏ôÈ@"˙X€ÒÆev·°l'Z◊ëÅvˇ~ly£»#Qïl{t’ÖÄ¸˚¬gŸ{h◊0-\szeãÑlj]oÆ]∫tÖ¿¯ÏHi∞ —G¿∏H[\,›ﬁ6Èò≥@Ñ‡ÂxÀ`C,@ÈòMLv˛eÎ:.gÂ-ªˇbà@≈{6" ÉèB%ﬂt·ÓÍ|ôΩãÁcÌΩ&–<&âX"‘Mù7∞}·◊ËJ8N	[c	Hﬁ»k˛\ˆôíÂä≠ı˜πAf{g∞°˝5nd⁄‹œ»$6ËÛtvGobF¢ÿ!∏ÖÄÔ›Nç˝Åè>ë∂8õù˙ºXH&}˛tˇÄeV€Ïö˛˚£Û±v/x,∑ˇõF˚Dlò|;ó;«#_cz÷è_æ>Ä •´pë∂ËJ»ïΩ3d£ˇÑçXI¸ﬁıuIËÁ¥y%ªı∫ã∞mÎD˚lMû˜b˝8ÃyH$†≈óÌx◊Öø«ïÛß“ã¨‚üÆX∫€Å◊µø¿]¡œaÌÌ¥ µÀµ/3Ñ(m&≈Ûﬂ:N;Îﬂû—H%]›J]q»x!JˇX
;aè∆]ào ‡∫‡Ëò95ÊD˙	ı◊§öΩ6,ˇò≈¯,≤Å.◊GdÜﬂeN"f’g;—Q´"îj∑#i∑Ω-·f[_óêΩjÿú>©i*ƒ}õ'9¡{#≠…k∏6¸*6Í!íÙx“xI+@*Y¿TñO π*IMƒx'"J’ù*b<–yzjic¿Ë≤Í!nKÍî˜\◊ˇ^€˘KfoÚÈû:∞÷2†~¿rI ¢«§$ò™∞èÆÑÃHƒÀµ√i—ÔãÔÕjLumaÒSc{VÀf˘	¯~∆˛4ˇ≠˜;tÂﬂË&¶≈ms ‹ÃÍ÷8íÖ?ªƒ˝˘.ì±;˙,Û,â≤9Wø˝¶,bÒÃ&N‡©àWËr—ó∫◊5éà⁄d† Ë£ò!—$Uó•b¸KŸ∂ÁØÿ~vD◊1Ä5˜2âí-jQ‚-&Dé“.@¨-c3Æ?rñ˙ú˝æΩöé˜8]L<íxƒ•¶xï÷Lp…	ÅÉÑ¥ÕS9—ˇ˝1Ko¶+w¸`È¢áJ<´ÜÆÿ÷éﬁÅFSºvÍ3È{G`bZ	¬w*ÌÛ»o‘÷WqäqBîhòmnã÷´ j≥a®µlãÕHWYv◊a∞¡,z(msè˘≈' ÚTM2ÓN ¨	$ƒÀ7å™Fû)´ÿ I‘πIh∏Õ\ë≥•”~.∆˛&ﬁ„P»º˝≤e…]kπ»yjÙàÃS\Üô¯MvEMΩÉŸ÷gË ÄäÓQ/ŸN≥á∏x`CO∫¢Ì@·3πUuLÇU±€øÛ>~¸õt¯I˙D‰c¥—„ÂbJüõ˙˜hÚÕIç≥∏ë14àéT˙¥Ò•ﬂ˛EÖ/∞˝ûè ´ k—¡|™6èŒàBgïÄ(3…ˆQ∏j·aLzg·˚œEx:ìÊB†gmRÆÃî&zë‰„—Ûˆ±T4d‹‚4B9HÑ1[òÊ•ÙÃKπﬁ~æk?¬Wæ˘ef‰pËé$äDgb‰ ÆZ‘=íg•s_‚ZΩîáX-,“ÊΩê¡R≠≤;ÜöO’Á&ùâÍèßç¬A≤Xë'úùN å(ië¶Ü°á´˘e∑nÒÌ‚„B¸ü«3œ9S&ÕÖÿ XH|ﬁS` ÈîîÜVY˘xÄ≤∂*W:|,öÿ‘Û”x¸4=o;O|Ù◊ybÙiñÙ&ƒ˚ﬂ˝ó;∏·gÇ–°+ ÈK«ü8À4W8ëd’ãiwü˘;Ù-l6/gû>yßÃ0õæŸ\Ó“¬<Œ∞ÜÎ¸rúâƒÒõÚfoÚôë0õÎc$ıÉ9é|`[Ú¨¬EòºôìZ◊1Ì=c6Ë"=	à≤Ì=SFístIÕ’⁄“ïDFQTH.Å¸8 ëÄñ∞X&Ã£ÿb.‚dÔ=b¢œsÍc∫í‡ì<œü”6æ˙lbj‚±Ò">¬y2Éeèz\-Ø‡ sL”Çb¨FeeYMΩE†ÀR˙ïìºÔBà@#=Ö˚Œû:§Îr‡(@Ì@Ù êÅè∞&‡\íò.]Æ˜Öro¯Ï‡Sth—Jñ∑-hõ™áZ*é¿rCù±†Áf˙ÌÿÓo”bä	<=˛ì˚¯SˆÒBµﬁìÿ⁄˘àÆÿ–Ò>16¿ìˇp‰·π¢I§·£¸
˚Ì_0M+iŸñ»˙·U
>ZL≤Id(fÔ∫_?ÎﬂHò∂69xVÕH‰Ló{Äbˆ€ﬁƒÉûı€ˇ∆\HõG ¿R"L…Ÿ%ŸﬁÑ4^k˘ˇuE4ïÉGü πïæΩ¢øe±ıE∫≤tË;r—[¿”’ ÚÙƒ”±:€Ç™ D| ˚vÑˇJG∂≥¡la	í¨»?≤)#)FL`≠ƒÔ'ˇÆDÉKÖJ&JÏ"d√=à9»ÔŒƒ∑¬^ú XsÄÌõÔöhõU8ü
s….@Wñ"∏∏ôWÈï<0<œˇ-|.†Ö«bVÈŒ‘∫≥Úˆhìù*CAò¬câŸÉÜÔ‡K˛-ÃyÉXÄC›H∑˙rÊ√ÁÑœxø!tÂŒ#‹Å‘πZ˛àK>»)ùWaÃò‡î$07˛≥;<ìº6MÆ:*{BuÂ»«7≈ßúœbÆ€BT6;02Få°o¢≤jπ ±3, É€0úé–ïE‡É¿πÆˇTBÔ’¥ÃsÄ∏ﬁü$l@+ﬁ ≠X≠©3Ø}Ñê>ëUzºù•‡\3Òç‹"ˆπe{ÕE‚≠,/:õ∂)0a6∞©Û4–˜¿jmwâ“E«‡Ì¿+πbˇN¶€g!ùßŸ«`8	8	UØ–K† 
«õ$üZ¿(XAQ’XõÅSUUÉ¸>—ÙiîÜbN¿˜¶≥»≈º9¶π>GÎü 0v˘Õ% ]§Ô´o,*s9a«(Øï˛ëz!˛ê)~"YT~¡PÏò#%OAûÑL‚”„V˙—ÔpU˚Sô¶üK¸˘8ÄCG∫∞/ \k@å\†»ªŸ™´˚”Ñö≠3ÚC‡Øì?1^t◊z˜
úø>¯a˙·…ﬁÔ°cã] z˜≈œÆs¢“ªOËúòYàŸÎç˜	NT6a¬*KFà|èÖ~»£OºÇiÆ\&r:õ’	ÄµÜç≥}ö[Ñ≈gGŸ≠îãòU√mWÀﬂÒö}ü·ƒÈò2œc!'tG◊Ä—L–b¡~à˚Õã¯Éˆæ,Ío5⁄à≈[|ñ◊Ï{ û<%)O«ˆAÖgª˜ofFˆ—v`≠ﬂ!1)ÚfUj∂ºÎ‘É«^i$˜∑Ωø4tL≤˘uøc #°ÏãNöµG:±„B˜œgWÙßl2ø≈<!4à£Ú˛ø2Iã˚^^c~ƒ∆	(≤z	(qöqƒ∆ËÈLöÕ,f…Jqç¬)s2ö>Ù…v‡Í˜.,òU«Õ1∑ãÒACl`jÁ”zË4}òÙx¯ Ü∏◊§@\à¬∞G=ÆÙ^*¬ø»öX÷iñºs 1Åœ|xˇe~%NÆYÌÏ≥€í‹ëfæâ ïô$ÊŒ1ÑË1ˇsjÚ,LÌÍ–!ÇN ¨ù	‡’Ig≠HÌµjﬁÀ≠Ò‚’è¯/Â üKZW5U®≈“FXä~ƒ˝˝pÉÃÃôU…“ÀcVsq•ûä·Ùì
≈ÉÎËÜsπbˇ…ÃIt∑“ñ!aÀN ¨¢:Å\å°Éc]†*nC¯îÑ,Ú"‡!®≠∆¬•Æ?É°ß/„ıæœ¨˙´ûÚõˇÈ‡óô2”I)Ñ—FÑLöÕlòx˛¿dsòöÖÆ5÷⁄' FÄÿ™ò"Ñ÷∫;pZ»£+ˇIüÌL`¿DïH?ô¿c¡˛≥≠øI~stäNl'b€„˝zVØÍHçãi¯ﬁEl€ìÓ‘Îøp´©X4„ÂXˇ¿+µSÍ[QE#–d;€‘£˜ù?aûo“™©IßBk˝0∫8zŸf{í=ˆ3û˚T:ÊÒÙìD˙rU%≈£GƒÑy<è˝•Ûìz}˛8ÄLß”'$ë	qç)Eπã kÕ6˘ÀI3≈î–∞Ωˆí[D„†°á/°Ï ≤ÚˆÃÜ%˝x8€˛€‘[ï≠æZF ä◊zy≤dO)Ä/óUU„B+9ÉU3@∆√8&@>i¶ﬁQ3:Éï…†«{Yàn«œ`së˙ø ÿvîÆaVsXf˜üéœÖ,aìˆd5Ö6 )P1·ùE∑]±„TªFÿI%£PÎrMÔw`ÌÀh„2§	ÍË4Mz˛ue	+ÔLÆ+ m=æ…Ì˛Õ® Q”˛[ìÍô≠…+È–∆ î7áU†mf«ﬂ0§™ê8¿»ô Rî‘U¬&*#’<•–anzÙì<Å(é˜pÉGÕ€æG=f∞\Øèe¬üaëAI•jVB^x,1Âù√Œ‡πYﬁqÙhTvÃÚ	mûc:¿h‹A•Á|…0jËJ‹˙˚öŒ◊	ÏóÈ$eK˙(Ù?òhÈ£®iD±Ï§M´êRµsÀÇ ÆäÎôÎô’â¯≥1å— ‚/œ/Á%@}ﬁñ˙)äﬂ≠€éó‰ß} xxˆ?9yÍ+ GÖ˛ÔIúä◊œ`ísÌ…Ü{K$7_zX6òü¢\6ËX4f&Ä)L-i.;Ó| £uu…@Èø^{‘l∑ƒ>ƒ±>Ωôã%8*‘:’‘≥:Åoﬁ\	r©k±û¢ÉœKD2Ÿ∫íkó=($:n,Ä¢cπ\†EgåŒ2±4tŸE¿¿àn˛w‘~≈ÿè*„òëà∂ΩÜiszVûªÆõRìJÈpÍ1IªÛÁú•~º[1>¶ÄµCYPÍ(P« F©Ú1ı≈ø$±yG€ÒËû
|ÜE`_Ôs ‹∫ ˆˇçªΩ∂ˇÛLòÀÈeEøVÓ#…ó2#È[∏ÅüÂôv'3Ò6∆:8®™Tú`D≈À[k¶Û†;∞åŒ6`Õ⁄≤˙Y	¢˚ÿµ·nTeUì~f’∞ç8ﬂì˜N!,∏NÀì{PÙJá≤∆øœé‡˘\,¡∏DcœB)Föéõøc\rML˝‡C•◊ΩﬂG‡€hÈcjı‚’g**l%.r±y˙›tÃ√í˛ÑEÌ_ç°§¢„™K≈`âË¯∆eΩ3ËJ8V[É˘rd£P≠ÿ	Äz'Ä‰óæ‘»kQ¡ó—∫¥∫Œ’”wqEÎo
Ô≠∆‚ø)±˚wFofÉ9óÉÑ9Ø5≤≠‹õPk4üö∞¿„‰Ä+ÙîqàPï˙Ê-≈˜‘	ÄQ0©h,©–⁄∞≠£<„Vw—®p>ÁH»Æ26öW∞@ò9L ˝ ⁄≠π.~µ≠ô$…BmÛ0N¥7Ú;˚∞ﬁÖ@\Qî∫ﬁ9à:¿h SØ©Ú√'¬(˚ —’€˜Waè$`W¯
6xØßGòƒ˙WÛ%§¡¶“∆Ú*UF`@«<ÅﬂQ^ìÅıÍHä%¥bV∫m¿—0rˆZÛV‡ÒÄYç”yª≤;ºí)ÔÕÙâ∞π≈ø“g#5ëîBs∆ÄóüÙ~Üì¶oÊÍ•üJJ¢≠?! Y_ÑÊ>¬‹6‡»PËÇ‡xYÓÂ≈Ô”ÀŸ7{≤;∫ÅçﬁNzDÿ∏3bç-_m<Z˛N]W^-â…4üÉÑ¯Ê1ln}äÎ˙O…ÉÎà2[mp(Áú3FÜÆ	’∫˙eä€”Öü˙∫rï>å_<˚Ôu⁄ºîÉ	Ìo(ÛYiõ&4{∫Î|RKéc!∞DÑ1ß0—˙$;¬Kòë]ál†ÿ≈iUÀxo4Ÿ≤í≥ã«UÎãÑ@ƒŒpÜé}-Û¿BˇÅö&XI’·˙ÁW˜ˇ¶!ﬁ<,–a£˜V^ùÕ˝/ß+?»z&Ã•TÁ’5Ñ∫≥06€ÅcP`]À◊'ÏQTËJ»eÛ‚˙‡œŸ‡Ω1¨Èf#µiæEMÆC]ÜÌÅ≥í•G»§Ÿ∆âS_dWÔ◊Ëäe.Ÿ%Xæe˘⁄± Úì™Û°Ùd›ãÅq` ∂‡ ¨ıp´åDM¿#£9qÎ±mXD"P√ı·KºÎò‡TàPL%ªOKmBπwuÈjÉ ç∑øä_Øc	≈Û˙Ã—2a™˝ˇ±;˙˙—,3rK¬bFèÿl«Tjhzﬂ“uØX∆¢ HÉ ´&≈[ßÉ•*±Ìúlä(;ÉÁÒz˛ô)ÔÌßr0IÏ©ãÑêÜà>Ü0ß¶x ≠aS≤Ão‚YÊ¢qAs”≠OÛ—{∏∂f∆RìfùÖcÿh|Äµ†^]®jNœçh$‡r⁄àµ=!g©œy·Ö¯Ê˜hôß¢ê–})h˝‚éà4⁄ÎZaL]^Œ≠∞+-î—“ÔÍâµ äº§ıòa¬º ¯e^}kˇò◊¥>FWB∫©âÃ`◊ÿ|”°û¶˚ù -#%Z;h¿≠#X†∫Ëgì @]	≥F£;ûfºŒåıÏKòÉzD…BÙAgiç[´ÓByìKkÿVQ–êkuû]'t=çÅ1Lp°πÄ7D_†Ωã^Î}Ã»ùE«±fpøí=∑¶ﬁSN ¨Ì∫1y÷\‹j$} •EﬂM™Œ]§-∆ŸxˆEx\h;f!∞êµÔ*ñ¸rPu± u&¡2∆TÉûD¨ÏóxX4π'°mû»¥y"]Æè>BÏaÔÅO0#
¬‡÷õÖÌgG´⁄•∏f˘€∆ÁbÕUÇú 8÷.¿˙ÅHÔÿnGƒ0´&Æ K\ˆ+]Ù€ˆxú˘‹3ë÷sQ˚KtÃ£,ãÑ%™_§£Z´˜õlˇÂm⁄tõP®g¿Muò´«-≤é™)2∏ß>ñ>ä«f:ÊÖDù‚∑Ó`wp#æü;˜Üô†õ<«d≠∆œpıÇµ˜üπ•o« FÍ§6{k‘Ü)üÎ?´>ù‡Ò `ÃÛÕch°IÑ%vG˚•e%µãNK‚@W`Ÿ6iÙJ ∞PkR?ÓJ"Íäº;JÃã–2e“ºå»?ﬁæÉÎ£õâ¬è°¡M\-wq4îåô⁄$"ç2äÛÏ∏b ≤B+xpÂ¡”òhˇ,æ9ﬂ>i=ö	  ˙@DoÁ©1+≤•D√ÎßÛ°LQY¡yeŸT5^Ÿÿƒ[áÇbâíñeæy(¸:⁄˛uz˛˝\›B}¥ı?Dﬂ˘w∫èÈØ™	0∏j-≤¥u[÷2–8ïq“∆Èæ¶[K…π_ı›	≥ÂîÌt˚l¸dÜ@ÑeãfUzí]©”Øí-t©hÎ≤ÒìßﬂRâb”° •#VFù—QÂ\á¬¬§¡<»;l]h≥ÖIûC€<'–Ï}‘◊∏TüÃXH‘Ûä~õíRx.ö{ÌvF f˙K÷r+IT8·«z‚˜ﬁDdÔ¿ö≥Äá—".™◊R02dÈÂ,ı¶Ù'ÕêVëﬁ÷â—Â„*§¶T∂Ç;L·;ö≠HEi'"r…,öØÅ˝4ë~à;Êñêm¨é/¿‘{8 œ±∑◊EéòÓoe´¡Ô»ö
Å.¡ﬂÀÏèN†≥È)<„üGáá!&5“ñ·¶bïÀPß_ù›]ß˘WÊ‘eœS/«”⁄w‚EoÈ$}	§}^ïø%än‰™ˆ≠‡ÈQùW„ôE2f>Ä:y=äI€‘c0#˚ÅèÂ’?‹»âõüÅÒ±œb LΩ¨ï),d©ô†+Y≤ÇEZÁ≠ó!Ç°ÓÍMÜfﬂEqº!BÒi„·KÙY¥ˇåçﬁGœ~\ª_/sV}nCW5îÿ4<Á‚uùÕÍ¿ök´‰„a — ©	–ÎØ˝µŒI∑ÂŒE˙≈˚‹ÔﬁœÏ¬C—ˆÛÒ‰Wiô3i„±X¢¬¥,ÉzÕ^⁄æZØÛ¢Ë
t„°
†j∂°EQ⁄x¥ÒÈ°˝<}ùc1¸[∫ﬂ,¯s∂'ïª(]	èöV)QUaï:\¿Båñ™Uªπ†#VL4ãÙKÖ¡≠(]πx&vÎ/⁄ó"ÊB¶ÿ@/14)!ˆrùØáLœeì@@#h>r‘IÚˆ¯.=˛Â=¸æ˜Ö⁄E/bÅhéN°1àTΩ±IØâA6†€\Àµd•íP∑!6≤EAs¬ nÈJ»ÚI‡ìÏ÷üê{ë˙Ê%Ls2K§[ÖÉ™<U⁄Ω\N›Ç]âè@jÿ¬`ﬂAVdOk‚Áòƒ√Ç|^ÇË€˜ÊË ˛Ω?Fãæhòú2ë*;Pì(u&¿⁄√4€≈ŸÑ['‚9≤%¡)ºÜÛo∆nxp	ìúƒb≤ê4qê≥˜uàmæúÕ^˜~}ÿ±ΩétÎQ±L$6[¿ßâxΩ^.“Ú¢Ôä=:Ù˛P)@ùÉ¿9G»	òd
äj\∏íÌ¶‡Ø3íñ˙RVGæÕr•˛N∞Ø∆3ó–°ì’®nj¡u®:πﬁ°◊ÙõÊ]á:œÅÆ(¬«ßÖGœﬁ‚ÖvWteÎ£Ÿo˜®«k∑ËõïJ=¡◊áD9pttﬁ&ìTîpùÊo•¨ µÉªr{Ï÷w ÏdÇ_$ ,!‡Áq±[BUÎÀ[]Üö+aÈg÷*b,S¯ÙÌù,Ëkπ¬ˇã(µÌÁ0ÃHtT⁄°¡˙œ)g"0Å@¶öy^uÆˇ›‹8ò)Ã¡Ú‡vÑ/°-Øc¬<Ä•¨˘«r˙ãÜ‡†Ê≠@≠˝ñ‘TKD€x<ÈŸ?”˘Ö+Ënº'[¯q≠Éë´h¨≠&ƒÏrT¨J÷¿9◊“»fc9('∆®&`*“zzWÀüqïﬁƒ&ﬁ Á≥ÄM¢Áãókﬁ‰C©+Æµ~YXÑL‚ŸÔ≥d^°WxìŸ¯i!”—fñ%#H.∂∏ÑI	∏ˆP´öè®õä¢ÇﬂØòÆ4´0Óm‡ŸÏ
gô‚ñ£qD°W…Îì–zm`À0±àI|ñ¯${ó~ù]æ«ıízÜ·Ë?\S≥Œœ)1ÉÙ≥EWpÙ§vì=:í¬KÂàï‚Ó;ÜY5\ÈwY‡`òßÖól∑~¥`y+Uó"qõ∞à¯¥ 8ó]æ«¨˙Y=√ı7ßÚUé¥v∑√1ÄµıHΩïü≥Ze4õÉÆ÷ÇHŸ¿MÍsé¸›˛ùL{†cDèÉw~∞ò)µ∆ÜÊöÒ‚∑“¡gﬁ^´Wx≥±øBÕhxˆ…™,& £ÈÀÌë(Æ7‡àóÊß,%{5-e=JëÄ€í:wª√mfW`U∫ÈûìÙ‚õmé%sﬂa/	%Æêu¶A]ñ°V‹Ç≈x@èàûå^•ØÒfŸ£q|Bæ  zZëä≈ﬁSc“kf∫g.æfj&"Ù˚£sØß'¡§ûúß-Û´ ‹ j±ÅX\%_gqÒlBnc"1™‚±ZX)˛¿„Ø%—`È‡≥Ω ^ÈˇaB˘Ì∫uæ™HçG©∆¿\ˇπ c—Pó/<5Zÿû,F√Vƒ;çY›LWÏ™.IÖ¿kßngëgÿªiß±Ùˆ|S>Z£˙´TXDL—‚Ä}#È‚Ô±ûÎÊä‰€É6ÖPU}#N ¨ïüÜÊn≠ö¸Âç»0©J‹(s˛AjÕ£¥Õ·œ 0∑ä„ë	πù≈Ë`>qÊ]Qü◊?≥|‚è6Fƒ[}˚Ìª∏⁄ªl∞¯◊˜∂´±∂^ [™ç≈÷ÚX m¢a˘≠´Qqn'ÓÎ◊Ó<üMI•Ÿg&f¿Íí…T\”˛y1ì⁄F\Îj˘•Vˇ†B~”~˚Ø¸{1´&f6Î?Ê¬ñ9µ~qN¿—ÆeZ\â“ë˛‡[ì÷∆<ü∏
ÊŸlS/3V[\§-Æí»A{S¯HÓ<My˙}ﬂ‚˚ôüˇeﬁÙ–EnõìuπÕWoUV˝$U?ÅÛåà˙B˝s&¿H¨f$bVO Œ' B,-NÁ±¡∞gè∑ÍßΩAˆ®ßWy◊∞/∫ôI¸ß‡p^†%©€∆£] éMˇ¡¨˙ÃÕDåñm¸°éå∆@ï¶÷Ã=õÏ«w¢Ûô2$$,æ¸FLü∑ùsﬂä¢*D˝≥h˜‚#H)‰}π»¿∏aHƒæå>¿’˛€ìHƒpú÷æ5¶.®L•sÆÌ®,c«¢2"Å ±yÈqIn‚xÙP|3√ÏﬁŸÜ=*eÃªbŸé«kßnßØó”∆B(*œ≠°òç+ˆ/⁄yØHÆ”2n∞∂∏ËkMKã™¿cPê√öÎnõy≥eÌÎÏQ/.rú£æ˜4ñ∞Y¨~Hƒ§9ô…MøÉà&ÂØV]"ˆ®«’ﬁü2œgÒ
µ˚Mgb∂ÍN^+ﬂM“ì«O ‘˚Aä˛ èH 36w Y‰ﬂhL€ÏHZ{Ê{Ó˙X<^≈=∞Y∂ﬂ™BΩïÀ∞Zç,6ø»—¬p–~õ‡ox˝«≤B·‡¿HHl≠‘≤/Ã˚5¨
ú&√Ï“ﬂ`Éy
KIïﬂA¢Æ!¿“aoL¥Í—õâY¿UÚOÙtéI< ıˆ§Ã†¯=Ì“=mÅ≠åç◊øqYh≥Ã-õ’tª #A◊§j˚Á>_´8Äò˙áÃÍ#iÛ&˙πﬂ≈-8ü%B6BvÜøBWBﬁ¶≠£rM∑&Ÿ-÷\Cü>Ç)ÿªU'óM¥ˇpØ˜WÃ™aÜÒ§˛Ä±9V©Ö˘•9'†™;∞VãﬂJ(N‚µ®∞G=f$‚wÔﬂÃ4s¯l"Ã”î'è&¶¿Ñ˜6^€?ìã%‡¢£ ∫bŸÉ·*˘:=˚7Lb≤ÿÄb6‡ +ÆÖ`ııºEzÒºWÌ÷∑Mä%_…˘ Fû—öªêäÌÎcpSB˚{ÔN€¯a:<é%¢D€6’‚3	üfìw#WÎ„π!G√È§Çö7–œ:Âü‡†éá«ºΩã{ˆæ7)I6ﬁ∂ˇ‡Q4S|A«°3–Ïÿ·∫Híâ~¨Å∂©«6ı‚‘‹•GÚMü`“{
ãÑH‚›Ø#éÅ`à0ÊÅl≤ˇ¿u¡y‹ àÆJ pﬁ0ãpµ|â~Ù):(±Ä¥kOà¬∑Ûñìˆ≥o|mˇ2,gb⁄èÅ¿rÜïª:™a *q…+ı‚rﬁ±;|1”≠¶Õ„Y$Lzﬁ5lS–ç‡≈ZŸú»î#Ì‚U:ôUŒùUï∂°‚Ò¬?ŒŒ≠•
8Ç«"=ñÏ;2Fp|Aö√Ã]$‡0Ä‹¬iäa!)éµ∫ã~õzq#QfíÖﬂÌˇwÆè>∆î˜Á`Nd)ivIM|¬R]Ü Ÿ•ü4W`˚vÜ/Ä§¬é$å`V˝√ﬁ2ÏÅ
—]7≤ƒ%]xµt'˙—ßŸ9˘-f’åÌæˇp0ã§>';> åDò÷h“’GJ√g$b.°Ã/ˇfáS˙t1≠ﬂRﬂ¸m`1Î„Á’Z˚2‰_ÕÓ-~µHD«l•Õ{xóÖÔ‡@Ô}Ã»˜˜õˆœ€nÈvW∏HE„Pﬁá/±;z/msE¡0ò¯ë{⁄«(Ê™—L©80"„£IY¶æÄ´Y •·óﬁµÅìNz"÷\àœ¥Õ#’ K(Iî_]ÎH)ïÿhj≠=∏tº$v &8„ùâôËÚ˙Ëı„Ñ¡'˘6á◊?/^–Õ_‚€WÉÒ23¿√„`Ù#¢7q!ìÓq∞‡À-Áµñe™ £!ùEÎ4È™Sbo_z˜8Òyx˛”Ey*-Ûm–œÚÏÛZøxE˘Õ…ºpêòÈ1{i5!≥Ö6€h≥çûw@˛ ¸ú˘Á÷}{Ç›ø∂b∫ﬁõ|˜6vE_dí''ÁP⁄¯ÙıÔÈnŸ◊¯ìà„∂~ˆb#¨–€/µsŒ˘ é!tôŸ8PÈ¡6¿lrØ˝„Ç∑C6öˇWO0èP$"†Oıß√††µÕ5 ›|õ√PM2Gñ¡µÌ=CÑKl´˝h@∏Ìê¶•‘hÙ◊I_°AE‡–æTVΩX…z#ˇyÅêﬁªÓπ¿x‰Øs√Î˛0uìóØ{¿≠z•ˇ0›◊{£+	¢/aP¶h”6&ic±í¯∞&¶2‹1ªÉ«$-ƒˆàÏ?p0z%Ω˛„Ù≤k]€ôîπC“÷¿˙ˆCÙíˆbèE∞øˇ)ˇΩˇ‹î£Àéö†∞Ÿô #¡÷îj7õ¸ø¢≤™ª Wt˛¯W`7◊/=⁄ÃõÁ[„ΩÄ∂ŸädÊ¿pr®ç6ùpà&Ë=>m4¯+´—«∏bÚøäle÷¨‹	òpÒ∂‚7yù˝
ms& aÙ%ﬁ∏Òf5n«ROûçY
9hg˝wÚ«j‡ä˚Ï≈˝ÏU+
™íòÒv‹k&˛›¬Œ“Î9?|b˛'-s ˝§=W›Ê≥(
Å∏f,⁄9ÇË-\’æe`•¶ﬁ,]Ù∞∑È‚‘ﬁê›—'9Ñ·ﬂÁx÷q# Ï†5XU(èW/≠q 66Ω´ïZdê¡µöq ¢t—lAƒ{±0¯>ÏÌŒè:˛.6pÿ§ùTq…óõpñçÜ∏”é2ÅOü¢\¡UÌ[*ã>÷ÃG^ëgkÒ|JÇŒÔkÑ¢ˆÊ¬g«≥ı_2’‘	Ä—qà4TŒ;”¢£îk\Gb∏çÆñèr˝$∂W–6≥ƒﬂàS|uôâ&Ÿ‚|ÑÖh;ØÒÆÉ∂eèz‹äÆ⁄¢œc["–z˝œcZ(Ã¸7ÄqŒ¸kV*p<∏=«¬–e?P9˙…@¢Ã$é≤8∞lgß~ô	ﬁâ0MXìtì∂õL8ãK+º∆ˇ ≥jÿödµÀM∂$◊ﬂÍÎO>p‹Eˇ-gêÂ«m`∆j®ïŒ-ÃHb˚∂∏7K\Ä±ã•J@Eo@jH,$ÃB¯".ó6m—EèÍ‚/ÕÌü¿Ü∑åß’{®Ü@CŒÖqΩGWTl≤ı DπXÇD|äy˝-ZLCM~3°Éœ|pytMÎ}ÃjõãìL¿cÅ§∫Ø~ıÀóÎÌ˜Ω6ˇﬁqì–RØP\M¿ëì’í[H≈Ú`(«º@äT\„øõ˚V&r5˘ãNøà	<Füf∂˝∫§‹ˆ⁄‘1õ{ "7ú∂¿Òi ˙íœeéñÓW ¡µm‹[√Œ 2´Ü˚ÔªÇEæKìıË¯ §G˝O n[KSel˙_Ÿ¢»∑E´J@„% $74ícŸˆ⁄OÊ∏ÄÜ·ı' àÆ•](-wÿù¿£oﬂ√5ùØ∆ùv÷2Ó^túK~“ºjä◊ \AêQc⁄ÙûÄø∆˘õ]"f’Ôù≤hˇÉV≤è√£OèË‡ÎÕkqX;ÿ“,™Ì<Ú—å—h5∑râﬁÄ	xãÙ¥ºùVvÒÑ ∫ôkN¯wfë„x€mtfT~πÏ»&ñÛå∆-h≈@!ÎNF•3X"≠¬Ë›,⁄ÉxI¬Ë]…d3n	éåYYÂ˛öurPgå ‰;I!ˇ~¥¢π≤‹˚wÒ1⁄Ç«A{Ä}ÌèoYw#;•‘]~ç5&€ﬂj¡R”:>†k◊§û≤V?(h!D—gy£§YwŒ˘∂Ê⁄ﬂJu±ÁLÄÿK#pA÷R Ú˛ÍáCE€kÔ»ô¢ﬁÕ,ŸIπ–èèI6&>Äaµ~∆(O`<| Âñ÷Z“'@ñ{ﬂï;˝äDÄ◊ª©‡#pÂ¢µ
‚≠Âû∏ˆ‡ko00√*Ìé“ˆﬂ™_î≈(‡Óªæ˝ù≈_(+ƒàKçÅä§∂jkπø?Bb …Ø7Aˇ4¯8oyd/Æ+‡ÏˇëX∆‘HJπÅπöÄN ¨Òî#∂¥Nú˜GÁöìÃæ(z›Ï]ﬂ}~f8å
Ö[ e\U°≥…ï1 V≠µó:s¢t€tª∫=∑⁄F•≤‡uUõº!Ì‘8ñﬂMÄ¶Fﬁ®⁄◊«o“Õ:·ı;÷µamlex§,D°=™sÃŸ˝£ (áævπ £Â8Nj∏9ù]¶9ÀÿL∂Ò2ä≤∫‘≈≠Ôf∂√
IY2ß¥ÜU÷5wëÄkJ’§dÔÁ+‰∏m7±Õ˙ØÔŸêõW[ÍÕ' éÂ@≠Ñ≤O†ÁÄ√¨
-«*.`$ÄßÕvZNxmÁls8¥EQÓúw.+ÉP`« ÷6*¶n◊VR©‘„wphöRÈTIõ¥‘iy
<:w†√j∑I:XŒpX±(Î˝*≥te¡Gh¥öå Õ—µ»m:t»;©RIª;¿ﬂÇ4ÿlŸﬂ
ìŒ‡∞“UõñëŒßxY« FKZ[ni©2êµÊ†c(LU°¢KKµ˛Ñ k∂¯´6ZŸncîCÅF“ZjZÉ8`ç} ’r†•W
Qﬂô +úRY{˙ä@cƒ%«#H©ßl˘Í-.¿·»y@nûπ\Ä1lS—ÊÅ`∞*Œ p8NY7üäiÊ‚≤Gû)◊l´FÙù–·Pu∫Ö\Êcƒ%◊ø à¨TFkF”Q áïÆ˝AêOQ˚k√sª k|Rc˚óıΩrX±Ú˜lM p±Â\˛#∑∞∆> -P^d¶Çs:¨Tÿb–O∫Ãº@q}F¬–™/RHrkﬂ·I•Pﬂk"Øˆ”P`g¨%Çx∞ MAŸ€‚rÅçX£ˆB“hü8`n°ú˙_≠ÂÍÄ√j!Ÿ$—qË0ª IKç∫T†Å(˜‹6†√
ó∏≠£Â%£Æ »h‹A+≠¨/ıµ “n–·0Q^Êô}∞w¯Ûzái.hÉí¿±áC_&∑Ë´&Â`F9`†C´88ôÓ/4-Õ,∑8õ§)¿≈∞çb\@‰∏Ä√JÁTM®9ÂLPgåà†Av˜pù–a≈f•_◊¯K
å”’i55p»ıs7Ç◊q¿aeà¨Tñ}9Xå¬f' F‘r+ø6-K«Õláï@E ;J5Ÿ%:àt`MÔ¿jù∑?çT"ZLò£*luÓAáe@ã”j™J‰˘e}:ÈúÄkíÎ¢µl@ÒAœADπ’	 áfÉíŸõ|9ã [%◊rfÑ£Z∆È¿±2Ω]¬“0Û∂=ñPm˚øÃU˙ct%‰m⁄rs›!O˙y≥vËäE˛Ö:È˝$`™¶ÄQ< Ó‡œNöèùÅÎ∑<êøn«Ï∂xâ€@æ-!i`]M`!"bäò∂{x…œÂb9Ä™0áqå‡8«Vîâ¯]z\Ÿ{”ÚáDX¥≤¯”Ÿd1"˝OeN= r‡XcÊæ!S”˜´Ôm!lÍ„Ü«Ê…<ÍƒõπN_ç»'◊Û¿9¨".’úΩHå\ØûŸLÄÕ‘HçoI ±zãÎ]Å¨_ ¢lSè7…}ÏÏññw°µàÒj§6Ä«ìÊ	>!ª¢E˘	¢;k√∏%döbll YA`sµ·ÚﬂC¨6uöJƒŸ‰b≈à—|Çâ¡∆ø7&∂¡rZKZÈ8ig+´V±<ƒ`±ÒˇF≠Xµb`–.=g÷f«5õœbj≤^“À7ÿ‹gFå"V∞ÒÛ¿ò§ãQìœP£÷ÄâÔZ≠∆œâﬂâÔ8yrb4˚ΩZ±b‘Bz_È}ãQk≠1È=	Jdì\:?m#&>/+F$EcMvˇò¯yb¯∆X#èƒÿüc“{∏@‰ãVi\†ß=B{S·;∞8=YîÅæC‡|ïóÜÊò¿Rl€ÈÑy<èW1ŸÁ6«‚Öˇ6{_kF\¿*u≈£2iaKu‰Ï¿XâèïˇΩÑ÷‡|πcZ©y]ÛΩ∫n…∂È:áÃf[Æ≤§ﬂó‚5TûKMºÜm8N˛π€≤oGé%πÒ†Ù;)]c˛B`ë(°˝Õ]≠•c√œpMÁõÃ™°+N ¨∫D®ä›Œ9}ãIÔ'ËcërëÄ¬ƒÒPî>v®Ù÷e[@¶U±âÑ¨¯≈≥QÚd‘]Õ‡LR˚-2M98”‡ód⁄íäØ§*8Úg,_eÒ,Zø +BHÜgjüàîÓ¢˛◊Õï{Î|B≈´’,f‘+ñ⁄%ˇ6äﬁ -e´Æ{'˙˙wÄÌQèâ∏¶˜B∂¥ﬂMè0lÀMº¶¡ñÜ≈4l“6/Ó™@)˛¯Ë‘-2≠ùÏıìüÂ&ıêœXDÂ⁄ö<áª·†úå+5ﬂoøaåpÂ´ƒ2â/˚˚”k:Á±M=Êd›˚ê÷ˇ6‡åDÏQèk;ÔaowL‚£….Æ@m™p›Dêµî⁄i÷<qÍÇGõø!+« ≤TîÆµ8±•q1»
ûÕr˜ªΩozZÀ Í∑R{¸aœNÜ0ë∫ÔÆK√¢=†ˆTÖ”«#πl<∂¿TÖÌ˚˜mÊ§çˇ»îy4ãZÀÔÊEßC4Â·<µÂ~◊¸yô≤Æ\`¨‰~áô@√Ñ‘\ôñLòaÁ[…µhÕs◊éâÆ¬ò≈øµ‘¯x≤Ø?]€ôÀXÁ`<r$	ƒx”Ê˚∏w˛π≤›…-Hò@”ÇYnR‘kï√´[gÒØåäÀä4›r˜◊¥Hö©øTXBK*⁄“U¶±≤Á1‹<©3ÀV∆>éLÕ)!>è˚ñ.äÆÌÃ1´˛∏,˛Òa )RªÏïwˇÑúr“ªu⁄˚Y&©xòãæÈµ6⁄¨ZKØó[tu.Ci8Cﬁg?¿r#›tﬁaÇ®Ël≤ÕõÆ≥ËÔêö˚_ŒÔ ç~b®s6≥U@" æ,Ÿ{ı@p;&ﬁ«¨˙tì∏”1¡xeŒIƒ∂=¯†ˇ“è~˜lˆˆ_è°«~‚„B¿&9üÚ°Ò‡'ˇœﬁœΩß(®dù!‚◊y¶πÚüÂè¡‡oMΩÚi∫¯Ω¸∑D◊°•k£È¸ïÑË‰˜Z‘πZÿüå;¯ﬁ‡xÈ9Ûøœﬂ˘Îœ=À¯˛»^ãÊ¥}Ó>ÛoJÓ¸í>->3-p-\èÊÓ#ˇ8î‹Ωï«ã!F`è>ˆc˙£‡Á∆uÒèHëﬂüΩ∫˜Xo“º ˙Êy:a6eõQNChçe+µD}π')KX©ù‰Jå ©—lJqsØÈl≈öv+—º‘<âÍÎ:6RØ√•Å/î∑¸äﬂ‘<π¸5ÂG¢xïun—4›«K‘·Aâ’õMæ9öù¯;Äq≤˘èœa&∏ÀÔ{(””Á„{ÁÄyjLÉxŸú»¶Ö‰µ›ÄJ¢¸•Ù›¸\M_7‰Ë≤Ó‡XÈrê¡˘”ÔiÓ∑J_√≠+îøÜˇñÇeÍóùœóOµ¯, Ø+bÆt˘Ô/∑ïò~°|ﬂ*•ë“9
èYÄHÒº˝Dv?™_>≈¸‚çÏﬁ¯µÇsyù˚ß «∂"	~ñ˙<Ö-mz'˜˜O`EP?âô]LBâ[	1Ø•òD"Xëÿ∑òO(¿¯
–ÚD*Ó«‚w”„ßˇ,%Á»≥@∞≠¯‹≠VÚì`–Õ §Ì+£$¥)˝]ê¯>[-íﬂ§Ó–(wû®tŒÏ⁄íÎäÇ“‹Hè[so^Kã˜ï˚Bv˝e„≥°òFö¡1kçV…Æ’kivˇAP|¶A2&6ë*˘·äTÒ⁄B€ÿ0}7w}ûN[»	£8QlLµ˛Ò% ÚÇ Lñ˝Â‡P7?¿é≥∆?~@Ÿ<P`{Õ˝ﬂ67xÔÙm ms¬È€én–G˘˘k(£|MÈw”˜Îæ_wû¶˚JﬂvM◊u®˜ŸÙùa«[Ó€SﬂÄ∏™—áãˇ’}ÖCˇ‡k    IENDÆB`Ç

====================================================================
FILE: D/icons/icon19.png
====================================================================
âPNG

   IHDR         rP6Ã  IDATx⁄µ‘±oúEﬂÏ}éœ`@t© BîñR¶¢É⁄ˇB§Ñ"ä–ÂLd_C
‚4AtëÚ§A(—F4h@äî§‰˚˚v(lN∂Ô(`§’J≥⁄∑ÔΩŸGfd!cÊdq'{˛”dôïé	£àt=_ó∂§E‘B©≤Ü¢:Qñµnª_dcÌa∞\÷C´Z•˛`∑‹≤®±[v§˙ÖU∏ÅëQæ`-n∫ì=´—õx&’Ú¿GÒÛÅúìÜÒpræëè=∑¢oÀFÓXç/≤FÖiÌEﬂ‡aﬂ’\˜ä˚6s≈Õ\88Îºjù˙»¢€Fy∆0Í_NÉ•‰TE+ç±«ﬁ≥ôg-π®ıùRæó>WùôPòí	U∆.÷≠ÂgFÒƒµºãGŒ«YlÉ+äóßpTf¯µÏEÔ∏û‚¥p⁄V~´Înx÷ª´Xûæ:?ve;F{ÅHO»ﬂ—¢ø–Ã Ÿ‡%oËöﬂ\å◊ÚÅÍGkÒÓ° ˙{f)§Œ óU€zæ∂1~SzÀü‰“<)ÂX?§¢∏Ï)ÆË|‡yˇ'œ|eÕ7"“ˆÊÅ5Ê6Y‹;“ã	∂ÖÃpUwmV∆ƒQCÜQE§àt.ˆD§4˛f]!ﬁ6 ◊§F´≥ Ìç√¬“˛ﬁ,ıÑo	øÃüõyJÒ©¨˚S£Ã ûR#TOÖ.˘U""˝1ô¥ˇr@f∆·‘üŸó„)bìÊ≈    IENDÆB`Ç

====================================================================
FILE: D/icons/icon32.png
====================================================================
âPNG

   IHDR           szzÙ  $IDATx⁄ÕóMlTU«Áﬁ73Ìå6ÄDÑ11⁄òò≤®çâ‡FÉ—∏±5—ƒÑhlTtÅñj
éjøÑ‡F√√¬Ö°]®+cdÉâDqHã&¢ÑØZ;3ÌºwÔq1Øh˚:”÷ËYΩº˜Œ=ˇÛqœˇ¯èEøÊ’–º¿?7K;]:4UY¥n^Õ#†¢Ë}÷0¡GEêB∆˘ûÇL–ÆñaqıòVÏèvìµ{)£¶jZ2Äc«£tÀO‰5† Q bœè®Âg∆∞Ù1≈a,é∞$§»˙ï!Ö¢4`˘ö´pÑi• g9¢ñé˘#1w\Obi!sú›Ú{ÕπÔ◊[(≥ùîûÊ8ym°CŒ'Åò?±b@»ëW√:lÏmÜ´ï∏Ù÷!ºHDÜ{Qö	8K@MÚ]m|√
N–£õÈêQÚj(àøŸÃB’Í)àÁéN	˘ã“(HDßÑà(√‚(àÁä¯Ä(«NiE˝∑‹Êø‚=›¿;Ë\∑#π¥}T≠ë&V0§è{Hq˚Ù0>‡N–BYJt zö,—Ø?Çá)ìa5πÏ"v˘ŸW;96∆7I
√F`-’≥X…0Âe lBU∞t‡˘√‘\Œq’s@57ÇHéÄ∆Ê*\¢G
Ë<{xC∂Ã¸ì“Då!r^π·åﬁI¨˘∞æ[0[y5î˘ÇFÆÃTıÄæDñ;(≤ìn˝òA˘ì˝⁄»8éUWqXwk“¡µhF„k4|	¿†>çÂ D§Ÿƒj>£∑¯,ØÀo3Ì∏ û>uIm¨6 'Pa®∏…mûBxßi
Oö-§≥'ÿß#D|Jôc@	„µ	°≠E∂Bµr9`3‡pHÏ_ï.nG}ñıd/W≠:ª@nkëK(Ïíst…"÷S·çXîà·<![È≤mt…!J´ãUÂd>™5ƒ1††Qo…Q‡’êc;ì\¶Ã#ºP35œµÚ∂'ØM@&Ë•_W¢*îxçê2°{?6û¶ Q˘‘`:øÓ§â≤<L#íÚ#ÏÁn
2¡$1ÓÛ∏ÕFıŒ.µ5¢)~%‡9"F,°yÜ
W@•ü∆Ù8oŒ&ö•∏^v…º´›•ÈI]§]-à“√•‰(Z]éF‰PDé?ªôŸ1iU'à]Ü¸cDôÎ=ÀõΩéÆa»k}Ü¶uø ‚¡õb<≈,¶¿™:˝a)…L0oŒœômÙNú"»Uá“˙bkâäkZÒ”tΩÛ•=¶⁄>¢ÅΩhn/§ÉT“@âW8Ç°„FGíì^Ωükk[LÊXT2T¯Ö95ó˜ˇﬁjV«™∂¸ÀÈl"”π∆Òˇç¸«ß^
NQú    IENDÆB`Ç

====================================================================
FILE: D/scripts/delete-conversations.js
====================================================================
(function() {
    const e = !1,
        t = (...t) => {
            e
        },
        n = (...t) => {
            e
        },
        o = (...t) => {
            e
        };
    t();
    const r = ["div.cdk-overlay-container", '[role="dialog"]', ".modal-container", ".overlay-container"],
        a = ['button[data-test-id="delete-button"]', 'button[aria-label*="delete"]', 'button:contains("Delete")', "button.delete-btn"],
        i = ['button[data-test-id="confirm-button"]', 'button:contains("Delete")', 'button:contains("Confirm")', 'button[aria-label*="confirm"]', "button.confirm-btn"],
        s = ['button[data-test-id="actions-menu-button"]', 'button[aria-label*="actions"]', 'button[aria-label*="menu"]', "button.menu-button", "button.actions-button"];

    function l(e, t = document) {
        if (!t) return null;
        for (const n of e) try {
            const e = t.querySelector(n);
            if (e) return e
        } catch (e) {
            console.warn(`[GD] Invalid selector "${n}":`, e)
        }
        return null
    }

    function d(e, t = document, n = 7e3) {
        return new Promise((o, r) => {
            const a = l(e, t);
            if (a && null !== a.offsetParent && !a.disabled) return void o(a);
            let i = 0;
            const s = setInterval(() => {
                if (c && c.signal.aborted) return clearInterval(s), void r(new Error("Operation aborted"));
                i += 150;
                const a = l(e, t);
                a && null !== a.offsetParent && !a.disabled ? (clearInterval(s), o(a)) : i >= n && (clearInterval(s), console.error(`Elements not actionable within ${n}ms. Tried selectors:`, e), r(new Error(`Elements not actionable within ${n}ms`)))
            }, 150)
        })
    }
    let c = null,
        m = null,
        g = !1;
    let u = null,
        p = null,
        b = null,
        f = null,
        y = null,
        h = null,
        v = null,
        x = null;
    const w = [chrome.i18n.getMessage("deleteConversations_deleting")],
        C = [chrome.i18n.getMessage("deleteConversations_cleared"), chrome.i18n.getMessage("deleteConversations_done"), chrome.i18n.getMessage("deleteConversations_finished"), chrome.i18n.getMessage("deleteConversations_tidied"), chrome.i18n.getMessage("deleteConversations_taskComplete")],
        k = chrome.i18n.getMessage("deleteConversations_cancelled");

    function E(e) {
        return e[Math.floor(Math.random() * e.length)]
    }

    function T() {
        if (document.getElementById("gemini-delete-all-overlay-styles")) return;
        const e = function() {
            const e = getComputedStyle(document.documentElement),
                t = document.body.classList.contains("dark-theme") || document.body.classList.contains("dark_mode_toggled") || "dark" === document.documentElement.getAttribute("data-theme"),
                n = t ? "#202124" : "#ffffff",
                o = t ? "#e8eaed" : "#202124",
                r = t ? "#9aa0a6" : "#5f6368";
            try {
                return {
                    isDark: t,
                    backgroundColor: (t ? e.getPropertyValue("--google-grey-900") || n : e.getPropertyValue("--google-grey-100") || n) || n,
                    textColor: t ? e.getPropertyValue("--google-grey-200") || o : e.getPropertyValue("--google-grey-900") || o,
                    secondaryTextColor: t ? e.getPropertyValue("--google-grey-500") || r : e.getPropertyValue("--google-grey-700") || r,
                    accentColor: t ? "#8ab4f8" : "#1a73e8",
                    progressTrackColor: t ? "rgba(255, 255, 255, 0.12)" : "rgba(0, 0, 0, 0.08)",
                    successColor: t ? "#81c995" : "#34a853"
                }
            } catch (e) {
                return console.warn("Could not read Gemini theme variables, using defaults"), {
                    isDark: t,
                    backgroundColor: n,
                    textColor: o,
                    secondaryTextColor: r,
                    accentColor: t ? "#8ab4f8" : "#1a73e8",
                    progressTrackColor: t ? "rgba(255, 255, 255, 0.12)" : "rgba(0, 0, 0, 0.08)",
                    successColor: t ? "#81c995" : "#34a853"
                }
            }
        }(),
            t = `
      #gemini-delete-all-overlay {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background-color: ${e.backgroundColor}; /* Theme-synced */
        z-index: 2147483647; display: flex; flex-direction: column;
        justify-content: center; align-items: center;
        font-family: 'Google Sans', Roboto, Arial, sans-serif; color: ${e.textColor}; text-align: center;
        opacity: 0; transition: opacity 0.3s ease-in-out;
      }
      #gemini-delete-all-overlay.visible { opacity: 1; }
      #gemini-delete-all-overlay .spinner {
        display: block; /* Default state */
        border: 3px solid ${e.progressTrackColor}; border-top: 3px solid ${e.accentColor}; /* Themed */
        border-radius: 50%; width: 50px; height: 50px;
        animation: spin 0.8s linear infinite; margin-bottom: 25px;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      
      /* Completion Tick Styles */
      #gemini-delete-all-overlay .completion-tick {
        display: none; /* Hidden by default */
        width: 60px; height: 60px;
        border-radius: 50%;
        stroke-width: 5; stroke: ${e.successColor}; /* Themed */
        stroke-miterlimit: 10;
        animation: draw-tick-container 0.5s ease-out forwards;
        margin-bottom: 20px;
      }
      #gemini-delete-all-overlay .completion-tick .tick-path {
        stroke-dasharray: 100;
        stroke-dashoffset: 100;
        animation: draw-tick-path 0.5s 0.2s ease-out forwards;
      }
      @keyframes draw-tick-container {
        0% { opacity: 0; transform: scale(0.5); }
        100% { opacity: 1; transform: scale(1); }
      }
      @keyframes draw-tick-path {
        to { stroke-dashoffset: 0; }
      }

      #gemini-delete-all-overlay .message { 
        font-size: 20px; font-weight: 500; margin-bottom: 8px; 
      }
      
      /* Progress Container and Text */
      #gemini-delete-all-overlay .progress-container {
        display: flex; flex-direction: column; align-items: center;
        width: 300px; /* Fixed width for the progress bar */
        margin: 10px 0;
      }
      #gemini-delete-all-overlay .progress-text { 
        font-size: 14px; color: ${e.secondaryTextColor}; 
        margin-bottom: 8px; width: 100%;
        display: flex; justify-content: space-between;
      }
      
      /* Progress Bar Styles */
      #gemini-delete-all-overlay .progress-bar {
        width: 100%; height: 4px; background-color: ${e.progressTrackColor};
        border-radius: 4px; overflow: hidden;
      }
      #gemini-delete-all-overlay .progress-bar-inner {
        height: 100%; width: 0%; /* Initial width */
        background-color: ${e.accentColor};
        /* Smooth animation when the width changes */
        transition: width 0.25s ease-out;
        border-radius: 4px;
      }
      
      /* Cancel Button */
      #gemini-delete-all-overlay .cancel-button {
        margin-top: 16px;
        color: ${e.secondaryTextColor};
        font-size: 14px;
        background: none;
        border: none;
        padding: 8px 16px;
        cursor: pointer;
        font-family: 'Google Sans', Roboto, Arial, sans-serif;
        border-radius: 4px;
        transition: background-color 0.15s;
      }
      #gemini-delete-all-overlay .cancel-button:hover {
        background-color: rgba(128, 128, 128, 0.1);
      }
      #gemini-delete-all-overlay .cancel-button:focus {
        outline: none;
        box-shadow: 0 0 0 2px ${e.accentColor};
      }
    `,
            n = document.createElement("style");
        n.id = "gemini-delete-all-overlay-styles", n.innerText = t, document.head.appendChild(n)
    }

    function S(e, t, n) {
        if (!p || !f) return;
        const o = e + t;
        p.textContent = chrome.i18n.getMessage("deleteConversations_progress", [String(o), String(n), String(e), String(t)]), o > 0 && f.style.animation && (f.style.animation = "", f.classList.remove("indeterminate"));
        const r = n > 0 ? o / n * 100 : 0;
        f.style.width = `${r}%`
    }

    function M(e, t, n, o = !1) {
        h && (h.style.display = "none"), b && (b.style.display = "none"), p && (p.style.display = "none"), x && (x.style.display = "none");
        let r = !1;
        if (y)
            if (o) y.textContent = k;
            else if (g) {
                y.textContent = chrome.i18n.getMessage("deleteConversations_workspaceMessage"), y.style.fontSize = "14px";
                try {
                    localStorage.removeItem("gemini_bulk_delete_workspace_warning_dismissed")
                } catch (e) {
                    console.warn("Could not reset workspace warning state:", e)
                }
            } else n > 0 && e === n && 0 === t ? (y.textContent = E(C), r = !0) : n > 0 && e > 0 && t > 0 ? (y.textContent = chrome.i18n.getMessage("deleteConversations_partialSuccess", [String(e), String(n)]), e >= t && (r = !0)) : n > 0 && t === n ? y.textContent = chrome.i18n.getMessage("deleteConversations_allFailed") : n > 0 && 0 === e && 0 === t ? y.textContent = chrome.i18n.getMessage("deleteConversations_noItemsProcessed") : 0 === n ? y.textContent = chrome.i18n.getMessage("deleteConversations_noItems") : (y.textContent = E(C), r = !0);
        r && v && n > 0 && (e > 0 || o) && (v.style.display = "block")
    }

    function A() {
        clearTimeout(m);
        const e = document.getElementById("gemini-delete-all-overlay");
        e ? (e.classList.remove("visible"), e.addEventListener("transitionend", () => {
            e && e.remove(), u = null, p = null, y = null, h = null, v = null, b = null, f = null, x = null
        }, {
            once: !0
        })) : (u = null, p = null, y = null, h = null, v = null, b = null, f = null, x = null)
    }

    function _() {
        document.querySelectorAll(".conversation-checkbox:checked").forEach(e => {
            e.checked = !1
        });
        try {
            const e = new Event("change", {
                bubbles: !0
            });
            document.querySelector(".conversation-checkbox") && document.querySelector(".conversation-checkbox").dispatchEvent(e);
        } catch (e) {
            n()
        }
    }

    function L(e) {
        return new Promise(t => setTimeout(t, e))
    }
    async function P(e) {
        if (c && c.signal.aborted) throw new Error("Operation aborted");
        const t = e.parentElement;
        if (!t) throw new Error("Checkbox parentElement is null.");
        if (t.classList.contains("conversations-container") || t.id && t.id.startsWith("conversations-list")) throw new Error("conversationItem incorrectly identified as main list container.");
        const n = t.nextElementSibling;
        if (!n) throw new Error("Actions wrapper (sibling to conversation item) not found.");
        let o = l(s, n);
        if (o || (o = n.querySelector("button")), !o) throw new Error("Three-dot button not found in actions wrapper.");
        o.click();
        const m = l(r);
        if (!m) throw new Error("Overlay container not found.");
        const g = await d(a, m, 7e3);
        if (!g) throw new Error("Delete button not found in menu");
        g.click();
        const u = await d(i, m, 7e3);
        if (!u) throw new Error("Confirm button not found in dialog");
        u.click(), await
            function(e, t = 15e3) {
                return new Promise((n, o) => {
                    if (!e || !document.body.contains(e)) return void n();
                    let r = 0;
                    const a = setInterval(() => {
                        if (c && c.signal.aborted) return clearInterval(a), void o(new Error("Operation aborted"));
                        r += 100, document.body.contains(e) && null !== e.offsetParent ? r >= t && (clearInterval(a), console.error("Element did not disappear within timeout:", e), o(new Error("Element did not disappear within timeout."))) : (clearInterval(a), n())
                    }, 100)
                })
            }(t)
    }(async function() {
        let e = Array.from(document.querySelectorAll(".conversation-checkbox:checked"));
        const r = e.length;
        if (0 === r) {
            return;
        }
        const a = function(e) {
            const t = document.getElementById("gemini-delete-all-overlay");
            t && t.remove(), c = new AbortController, clearTimeout(m), m = setTimeout(() => {
                if (c && !c.signal.aborted) {
                    console.error("Bulk deletion watchdog triggered - operation taking too long"), c.abort("timeout");
                    const e = document.createElement("div");
                    e.textContent = chrome.i18n.getMessage("deleteConversations_timeout"), e.style.cssText = "color: #f28b82; font-size: 14px; margin-top: 8px;", y && y.parentNode && y.parentNode.insertBefore(e, y.nextSibling), setTimeout(() => {
                        A(), _()
                    }, 3e3)
                }
            }, 3e4), T(), u = document.createElement("div"), u.id = "gemini-delete-all-overlay", u.setAttribute("role", "dialog"), u.setAttribute("aria-modal", "true"), u.setAttribute("aria-labelledby", "gemini-delete-message"), h = document.createElement("div"), h.className = "spinner", v = document.createElementNS("http://www.w3.org/2000/svg", "svg"), v.setAttribute("class", "completion-tick"), v.setAttribute("viewBox", "0 0 52 52");
            const n = document.createElementNS("http://www.w3.org/2000/svg", "path");
            n.setAttribute("class", "tick-path"), n.setAttribute("fill", "none"), n.setAttribute("d", "M14.1 27.2l7.1 7.2 16.7-16.8"), v.appendChild(n), y = document.createElement("div"), y.className = "message", y.id = "gemini-delete-message", y.setAttribute("role", "status"), y.setAttribute("aria-live", "polite"), y.textContent = E(w);
            const o = document.createElement("div");
            o.className = "progress-container", p = document.createElement("div"), p.className = "progress-text", p.textContent = chrome.i18n.getMessage("deleteConversations_preparing", String(e)), o.appendChild(p), b = document.createElement("div"), b.className = "progress-bar", f = document.createElement("div"), f.className = "progress-bar-inner", f.id = "gbd-progress", f.style.width = "30%", f.style.animation = "progress-indeterminate 1.5s ease-in-out infinite", b.appendChild(f), o.appendChild(b), x = document.createElement("button"), x.className = "cancel-button", x.textContent = chrome.i18n.getMessage("deleteConversations_cancel"), x.addEventListener("click", () => {
                c && !c.signal.aborted && (c.abort(), y.textContent = k, M(0, 0, e, !0), setTimeout(() => {
                    A(), _()
                }, 1500))
            }), u.appendChild(h), u.appendChild(v), u.appendChild(y), u.appendChild(o), u.appendChild(x), document.body.appendChild(u), requestAnimationFrame(() => {
                u && u.classList.add("visible")
            });
            const r = document.getElementById("gemini-delete-all-overlay-styles");
            return r && (r.innerText += "\n        @keyframes progress-indeterminate {\n          0% { left: -30%; width: 30% }\n          50% { left: 100%; width: 30% }\n          100% { left: 100%; width: 0 }\n        }\n        #gemini-delete-all-overlay .progress-bar-inner.indeterminate {\n          position: relative;\n          animation: progress-indeterminate 1.5s ease-in-out infinite;\n        }\n      "), c
        }(r);
        if (!a) return void console.error("Failed to initialize abort controller");
        const i = setTimeout(() => {
            if (c && !c.signal.aborted) {
                console.error("Bulk deletion watchdog triggered - operation taking too long"), c.abort("timeout"), y && (y.textContent = chrome.i18n.getMessage("deleteConversations_longOperation")), b && (b.style.display = "none"), p && (p.textContent = chrome.i18n.getMessage("deleteConversations_longOperationSuggestion"), p.style.display = "block", p.style.textAlign = "center", p.style.width = "100%", p.style.marginTop = "10px"), h && (h.style.borderTopColor = "#f28b82");
                const e = document.createElement("button");
                if (e.textContent = chrome.i18n.getMessage("deleteConversations_tryAgain"), e.style.cssText = "\n          background-color: var(--gd-bg-primary);\n          color: var(--gd-focus-ring, #1a73e8);\n          border: 1px solid var(--gd-focus-ring, #1a73e8);\n          border-radius: 4px;\n          padding: 8px 16px;\n          margin-top: 16px;\n          font-family: 'Google Sans', Roboto, Arial, sans-serif;\n          font-size: 14px;\n          cursor: pointer;\n        ", e.addEventListener("click", () => {
                    A(), _()
                }), y && y.parentNode) {
                    const t = y.parentNode;
                    x && (x.style.display = "none"), t.appendChild(e)
                }
                setTimeout(() => {
                    A(), _()
                }, 3e4)
            }
        }, 3e4);
        try {
            if (await L(500), a.signal.aborted) return A(), void _();
            let n = 0,
                o = 0;
            for (const [a, i] of Array.from(e).entries()) {
                if (c && c.signal.aborted) {
                    console.log("Deletion aborted by user or timeout");
                    break
                }
                if (document.body.contains(i)) {
                    try {
                        await P(i), n++;
                        try {
                            const e = await chrome.storage.sync.get(["remainingDeletes", "isUnlocked"]),
                                n = e.remainingDeletes || 0;
                            if (e.isUnlocked || !1) t();
                            else if (n > 0) {
                                const e = n - 1;
                                await chrome.storage.sync.set({
                                    remainingDeletes: e
                                }), t(), e <= 0 && t()
                            }
                        } catch (e) {
                            console.error("Error updating quota:", e)
                        }
                    } catch (e) {
                        if (o++, "Operation aborted" === e.message) break;
                        console.error(`Failed to delete conversation for checkbox (original index: ${i.dataset.index||"N/A"}):`, e.message), document.body.dispatchEvent(new KeyboardEvent("keydown", {
                            key: "Escape",
                            code: "Escape",
                            keyCode: 27,
                            bubbles: !0,
                            cancelable: !0
                        })), await L(100)
                    }
                    S(n, o, r), (a + 1) % 20 == 0 && await new Promise(e => {
                        window.requestIdleCallback ? requestIdleCallback(e) : setTimeout(e, 10)
                    })
                } else S(n, o, r)
            }
            c && c.signal.aborted || (M(n, o, r), await L(2200))
        } finally {
            clearTimeout(i), A(), _()
        }
        console.log(`Bulk delete process finished. Total Selected: ${r}, Deleted: ${n}, Errors: ${o}`)
    })()
})();

====================================================================
FILE: D/manifest.json
====================================================================
{
  "manifest_version": 3,
  "name": "Gemini Toolbox",
  "version": "1.2",
  "description": "Enhance Gemini with folders, prompt library, word counter, and a powerful chat exporter.",
  "permissions": [
    "storage",
    "activeTab",
    "scripting",
    "downloads"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["*://gemini.google.com/*"],
      "js": [
        "lib/html2pdf.bundle.min.js",
        "prompt_library.js",
        "word_counter.js",
        "voice_mode.js",
        "chat_exporter.js",
        "injector.js"
      ]
    }
  ],
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "web_accessible_resources": [
    {
      "resources": [
        "prompt_library.html",
        "prompt_library.css",
        "chat_exporter.css",
        "chat_exporter.js",
        "prompt_library.js",
        "word_counter.js",
        "voice_mode.js"
      ],
      "matches": ["*://gemini.google.com/*"]
    }
  ]
} 

====================================================================
FILE: D/prompt_library.html
====================================================================
<div id="prompt-library-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Prompt Library</h2>
            <button class="icon-btn close-button">√ó</button>
        </div>
        <div class="modal-body">
            <div class="controls">
                <input type="text" id="search-bar" placeholder="Search prompts...">
                <select id="category-filter">
                    <option value="all">All Categories</option>
                    <option value="marketing">Marketing</option>
                    <option value="sales">Sales</option>
                    <option value="customer_service">Customer Service</option>
                    <option value="personal_development">Personal Development</option>
                    <option value="seo">SEO</option>
                    <option value="engineering">Engineering</option>
                    <option value="coding">Coding</option>
                    <option value="education">Education</option>
                    <option value="finance">Finance</option>
                    <option value="creative">Creative</option>
                </select>
            </div>
            <div id="prompt-list" class="prompt-list">
                <!-- Prompts will be dynamically loaded here -->
            </div>
        </div>
    </div>
</div> 

====================================================================
FILE: D/EXPORT_CHAT_FEATURE.md
====================================================================
# üì§ Export Chat Feature

## Overview

The **Export Chat** feature allows users to export their Gemini conversations in multiple formats for backup, sharing, or analysis purposes. This feature is accessible through the Gemini Toolbox dropdown menu.

## üéØ Features

### ‚ú® **Multiple Export Formats**
- **PDF**: High-quality document with proper formatting
- **HTML**: Web page format with full styling
- **Markdown**: Plain text with formatting preserved
- **JSON**: Structured data format for programmatic use
- **Text**: Simple plain text format
- **CSV**: Spreadsheet-compatible format

### üé® **Customization Options**
- **File Name**: Customizable filename for exports
- **Theme**: Light, Dark, or Auto theme selection
- **Orientation**: Portrait or Landscape for PDF exports
- **Compression**: Enable/disable PDF compression for smaller file sizes

### üîß **Smart Export**
- **Current Conversation**: Export the entire current conversation
- **Selected Messages**: Export only selected messages (future feature)
- **Auto-scroll**: Automatically scrolls to load all messages before export
- **Clean Content**: Removes UI elements and formatting artifacts

## üìñ **How to Use**

### 1. **Access Export Feature**
- Click the **Gemini Toolbox** button in the sidebar
- Select **Export Chat** from the dropdown menu
- The export modal will appear with format options

### 2. **Choose Export Format**
- Select from 6 different export formats:
  - **PDF**: Best for printing and sharing
  - **HTML**: Good for web viewing
  - **Markdown**: Ideal for documentation
  - **JSON**: Perfect for data analysis
  - **Text**: Simple text format
  - **CSV**: Spreadsheet format

### 3. **Configure Settings**
- **File Name**: Enter a custom filename (default: gemini-conversation)
- **Theme**: Choose Light, Dark, or Auto theme
- **Orientation**: Select Portrait or Landscape for PDFs
- **Compression**: Toggle PDF compression for smaller files

### 4. **Export Range**
- **Current Conversation**: Export the entire conversation
- **Selected Messages**: Export only selected messages (coming soon)

### 5. **Export**
- Click **Export Chat** to start the export process
- Files will be automatically downloaded to your default download folder
- A success notification will appear when export is complete

## üéØ **Benefits**

### **For Content Creators**
- Save important conversations for reference
- Create documentation from AI interactions
- Share conversations in professional formats

### **For Developers**
- Export code discussions for documentation
- Save debugging sessions for future reference
- Create training datasets from conversations

### **For Students & Professionals**
- Save study materials and notes
- Create presentation materials
- Archive important discussions

## üí° **Technical Implementation**

### **Smart Content Extraction**
```javascript
// Automatically detects conversation structure
const conversationElements = document.querySelectorAll('div.conversation-container');
// Extracts user queries and AI responses
// Cleans HTML content for clean exports
```

### **Multi-Format Support**
- **PDF**: Uses html2pdf library for high-quality output
- **HTML**: Generates standalone HTML with embedded styles
- **Markdown**: Converts HTML to Markdown format
- **JSON**: Structured data with metadata
- **Text**: Plain text extraction
- **CSV**: Tabular format with timestamps

### **Theme-Aware Export**
- Automatically detects Gemini's theme
- Supports Light, Dark, and Auto theme modes
- Maintains visual consistency in exports

## üîß **Configuration**

### **Default Settings**
- **Format**: PDF
- **Theme**: Auto (follows Gemini's theme)
- **Orientation**: Portrait
- **Compression**: Enabled
- **Filename**: gemini-conversation

### **Persistent Settings**
- All settings are saved to localStorage
- Settings persist between browser sessions
- Custom filename is remembered

## üêõ **Troubleshooting**

### **Export Not Working**
- Ensure you're on a Gemini conversation page
- Check that the conversation has content
- Try refreshing the page and retrying

### **PDF Export Issues**
- PDF export requires html2pdf library
- Falls back to HTML export if library unavailable
- Check browser console for error messages

### **Large File Sizes**
- Enable compression for smaller PDF files
- Use Text or Markdown format for smaller files
- Consider exporting selected messages only

### **Formatting Issues**
- HTML and PDF formats preserve formatting best
- Text format strips all formatting
- Markdown preserves basic formatting

## üé® **Design Philosophy**

### **Inspired by Professional Tools**
- Clean, intuitive interface
- Multiple format options
- Professional export quality
- Consistent with Gemini's design

### **User Experience**
- One-click access from toolbox
- Clear format selection
- Immediate feedback
- Automatic file downloads

## üìã **Future Enhancements**

### **Planned Features**
- **Message Selection**: Select specific messages for export
- **Batch Export**: Export multiple conversations at once
- **Cloud Integration**: Save to cloud storage
- **Custom Templates**: User-defined export templates
- **Advanced Formatting**: More formatting options

### **Advanced Capabilities**
- **Image Export**: Include images in exports
- **Code Highlighting**: Syntax highlighting in exports
- **Metadata Export**: Include conversation metadata
- **Search Integration**: Export search results
- **Scheduled Exports**: Automatic periodic exports

## üîç **Comparison with ChatGPT Toolbox**

| Feature | ChatGPT Toolbox | Gemini Export Chat |
|---------|----------------|-------------------|
| Export Formats | ‚úÖ Multiple | ‚úÖ 6 formats |
| Theme Support | ‚úÖ Basic | ‚úÖ Advanced |
| Customization | ‚úÖ Limited | ‚úÖ Comprehensive |
| PDF Quality | ‚úÖ Good | ‚úÖ Excellent |
| File Naming | ‚úÖ Basic | ‚úÖ Custom |
| Settings Persistence | ‚ùå No | ‚úÖ Yes |

This Export Chat feature brings professional-grade export capabilities to your Gemini experience, making it easy to save, share, and archive your important conversations in the format that works best for your needs.

====================================================================
FILE: D/prompt_library.js
====================================================================
class PromptLibrary {
    constructor(shadowRoot) {
        this.shadowRoot = shadowRoot;
        this.prompts = [
            // Marketing
            { title: 'Marketing Copy', content: 'Write a catchy marketing slogan for a new coffee brand.', category: 'marketing' },
            { title: 'Product Description', content: 'Create a compelling product description for [product name] that highlights its key features and benefits.', category: 'marketing' },
            { title: 'Social Media Post', content: 'Write an engaging social media post about [topic] that encourages interaction and shares.', category: 'marketing' },
            { title: 'Email Marketing', content: 'Create a persuasive email marketing campaign for [product/service] targeting [audience].', category: 'marketing' },
            
            // Sales
            { title: 'Sales Email', content: 'Draft a follow-up email to a potential client who has shown interest in our product.', category: 'sales' },
            { title: 'Sales Pitch', content: 'Create a compelling 2-minute sales pitch for [product/service] addressing common objections.', category: 'sales' },
            { title: 'Cold Outreach', content: 'Write a professional cold outreach message for [target audience] about [product/service].', category: 'sales' },
            
            // Coding
            { title: 'Code Generation', content: 'Generate a Python function to calculate the factorial of a number.', category: 'coding' },
            { title: 'Code Review', content: 'Review this code and suggest improvements for performance, readability, and best practices: [paste code here]', category: 'coding' },
            { title: 'Bug Fix', content: 'Help me debug this code. Here\'s the error I\'m getting: [error message] and here\'s the code: [paste code]', category: 'coding' },
            { title: 'API Documentation', content: 'Create comprehensive API documentation for this function: [paste function]', category: 'coding' },
            { title: 'Unit Tests', content: 'Write unit tests for this function: [paste function]', category: 'coding' },
            
            // Creative
            { title: 'Creative Writing', content: 'Write a short story about a robot who discovers music.', category: 'creative' },
            { title: 'Blog Post', content: 'Write a comprehensive blog post about [topic] that is engaging and informative.', category: 'creative' },
            { title: 'Video Script', content: 'Create a script for a 5-minute video explaining [topic] to [target audience].', category: 'creative' },
            { title: 'Content Ideas', content: 'Generate 10 creative content ideas for [topic/industry] that would engage [target audience].', category: 'creative' },
            
            // Personal Development
            { title: 'Goal Setting', content: 'Help me create a SMART goal framework for achieving [specific objective] within [timeframe].', category: 'personal_development' },
            { title: 'Career Advice', content: 'Provide career advice for someone looking to transition from [current role] to [desired role].', category: 'personal_development' },
            { title: 'Learning Plan', content: 'Create a structured learning plan to master [skill/topic] in [timeframe].', category: 'personal_development' },
            { title: 'Resume Review', content: 'Review and improve this resume for a [target position]: [paste resume]', category: 'personal_development' },
            
            // Customer Service
            { title: 'Customer Support', content: 'Write a helpful customer support response for a client who [describe issue].', category: 'customer_service' },
            { title: 'Complaint Response', content: 'Draft a professional response to this customer complaint: [paste complaint]', category: 'customer_service' },
            { title: 'FAQ Creation', content: 'Create comprehensive FAQ answers for common questions about [product/service].', category: 'customer_service' },
            
            // SEO
            { title: 'SEO Content', content: 'Write SEO-optimized content about [topic] targeting the keyword "[keyword]".', category: 'seo' },
            { title: 'Meta Descriptions', content: 'Create compelling meta descriptions for pages about [topic] that are under 160 characters.', category: 'seo' },
            { title: 'Keyword Research', content: 'Suggest relevant keywords and search terms for content about [topic].', category: 'seo' },
            
            // Engineering
            { title: 'Technical Documentation', content: 'Write technical documentation for [system/process] that explains how it works and how to use it.', category: 'engineering' },
            { title: 'Architecture Design', content: 'Help me design a system architecture for [project description] considering scalability and performance.', category: 'engineering' },
            { title: 'Requirements Analysis', content: 'Analyze these requirements and identify potential issues or improvements: [paste requirements]', category: 'engineering' },
            
            // Education
            { title: 'Lesson Plan', content: 'Create a lesson plan for teaching [topic] to [target audience/grade level].', category: 'education' },
            { title: 'Study Guide', content: 'Create a comprehensive study guide for [subject/topic] covering key concepts and practice questions.', category: 'education' },
            { title: 'Quiz Generator', content: 'Generate a quiz with 10 questions about [topic] with multiple choice answers.', category: 'education' },
            
            // Finance
            { title: 'Budget Analysis', content: 'Help me analyze this budget and suggest optimizations: [paste budget details]', category: 'finance' },
            { title: 'Investment Advice', content: 'Provide general investment guidance for someone with [financial situation] and [risk tolerance].', category: 'finance' },
            { title: 'Financial Planning', content: 'Create a basic financial plan for achieving [financial goal] within [timeframe].', category: 'finance' },
        ];
        this.isInitialized = false;
    }

    init() {
        if (!this.isInitialized) {
            this.setupEventListeners();
            this.isInitialized = true;
        }
    }

    initializeEventListeners() {
        // This is called after HTML is loaded
        this.init();
    }

    setupEventListeners() {
        console.log('Setting up event listeners for prompt library');
        
        const closeButton = this.shadowRoot.querySelector('.close-button');
        const searchBar = this.shadowRoot.getElementById('search-bar');
        const categoryFilter = this.shadowRoot.getElementById('category-filter');
        const modal = this.shadowRoot.getElementById('prompt-library-modal');
        
        const elementsFound = {
            closeButton: !!closeButton,
            searchBar: !!searchBar,
            categoryFilter: !!categoryFilter,
            modal: !!modal
        };
        
        console.log('Elements found:', elementsFound);

        if (closeButton) {
            closeButton.onclick = () => this.hide();
        }

        if (searchBar) {
            searchBar.onkeyup = () => this.filterPrompts();
        }

        if (categoryFilter) {
            categoryFilter.onchange = () => this.filterPrompts();
        }

        // Click outside to close
        if (modal) {
            modal.onclick = (event) => {
                if (event.target === modal) {
                    this.hide();
                }
            };
        }
    }

    show() {
        const modal = this.shadowRoot.getElementById('prompt-library-modal');
        if (modal) {
            modal.style.display = 'block';
            this.loadPrompts();
        }
    }

    hide() {
        const modal = this.shadowRoot.getElementById('prompt-library-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    }

    loadPrompts(filteredPrompts = this.prompts) {
        const promptList = this.shadowRoot.getElementById('prompt-list');
        if (!promptList) return;
        
        promptList.innerHTML = '';

        filteredPrompts.forEach(prompt => {
            const promptElement = document.createElement('div');
            promptElement.className = 'prompt-item';
            promptElement.setAttribute('data-category', prompt.category);
            promptElement.innerHTML = `
                <div class="prompt-header">
                    <div class="title">${prompt.title}</div>
                    <button class="copy-btn" title="Copy prompt">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"/>
                        </svg>
                    </button>
                </div>
                <div class="content">${prompt.content}</div>
            `;
            
            // Click on prompt inserts it
            promptElement.addEventListener('click', (e) => {
                if (!e.target.closest('.copy-btn')) {
                    this.usePrompt(prompt.content);
                }
            });
            
            // Copy button functionality
            const copyBtn = promptElement.querySelector('.copy-btn');
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(prompt.content).then(() => {
                    copyBtn.innerHTML = '‚úì';
                    setTimeout(() => {
                        copyBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"/>
                        </svg>`;
                    }, 1000);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                });
            });
            
            promptList.appendChild(promptElement);
        });
    }

    usePrompt(content) {
        // Updated selectors based on the actual Gemini HTML structure
        const selectors = [
            '.ql-editor.textarea.new-input-ui',
            'rich-textarea .ql-editor',
            '.ql-editor[contenteditable="true"]',
            'div[contenteditable="true"][role="textbox"]'
        ];

        let geminiInput = null;
        
        for (const selector of selectors) {
            geminiInput = document.querySelector(selector);
            if (geminiInput) {
                console.log(`Found input using: ${selector}`);
                break;
            }
        }

        if (geminiInput && geminiInput.contentEditable === 'true') {
            // Clear existing content first
            geminiInput.innerHTML = '';
            
            // Insert the prompt
            const p = document.createElement('p');
            p.textContent = content;
            geminiInput.appendChild(p);
            
            // Remove the ql-blank class if present
            geminiInput.classList.remove('ql-blank');
            
            // Focus the input
            geminiInput.focus();
            
            // Trigger input event for Gemini to recognize the change
            geminiInput.dispatchEvent(new Event('input', { bubbles: true }));
            geminiInput.dispatchEvent(new Event('change', { bubbles: true }));
            
            // Set cursor at end
            const range = document.createRange();
            const sel = window.getSelection();
            range.selectNodeContents(geminiInput);
            range.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range);
            
            this.hide();
        } else {
            console.error('Could not find Gemini input field');
            alert('Could not find the chat input field. Please make sure you are on the Gemini chat page.');
        }
    }

    filterPrompts() {
        const searchTerm = this.shadowRoot.getElementById('search-bar').value.toLowerCase();
        const category = this.shadowRoot.getElementById('category-filter').value;

        const filtered = this.prompts.filter(prompt => {
            const matchesSearch = prompt.title.toLowerCase().includes(searchTerm) || 
                                  prompt.content.toLowerCase().includes(searchTerm);
            const matchesCategory = category === 'all' || prompt.category === category;
            return matchesSearch && matchesCategory;
        });

        this.loadPrompts(filtered);
    }
} 

====================================================================
FILE: D/VOICE_DOWNLOAD_FEATURE.md
====================================================================
# Voice Download Feature - Gemini Toolbox

## Overview

The **Voice Download** feature is a powerful addition to the Gemini Toolbox that enables users to convert AI responses to speech and download them as audio files. This feature was inspired by the ChatGPT Toolbox capabilities and brings advanced text-to-speech functionality to Google Gemini.

## Features

### üéôÔ∏è **Text-to-Speech Conversion**
- Instant conversion of Gemini AI responses to natural-sounding speech
- Real-time audio playback with play/pause controls
- Clean text extraction that removes UI elements and buttons

### üéµ **Audio Download**
- Download AI responses as audio files (WAV format)
- Automatic filename generation based on conversation context
- Offline listening capability for accessibility and convenience

### ‚öôÔ∏è **Advanced Voice Settings**
- **Voice Selection**: Choose from all available system voices
- **Speed Control**: Adjust speech rate (0.5x to 2.0x speed)
- **Pitch Control**: Modify voice pitch for personal preference
- **Volume Control**: Fine-tune audio volume levels
- **Test Voice**: Preview settings before applying
- **Persistent Settings**: Your preferences are saved automatically

### üéØ **Smart Response Detection**
- Automatically detects new AI responses in conversations
- Adds voice buttons only to actual AI responses (not user messages)
- Works with all Gemini response formats including code blocks

### üé® **Seamless Integration**
- Matches Gemini's design language with light/dark theme support
- Non-intrusive voice buttons that appear near AI responses
- Dropdown menu with intuitive icons and clear labels
- Professional modal interface for voice settings

## How to Use

### Basic Usage

1. **Access Voice Options**: After Gemini provides a response, look for the "Voice" button that appears near the response
2. **Choose Action**: Click the Voice button to see three options:
   - **Play Audio**: Listen to the response immediately
   - **Download MP3**: Save the audio as a file
   - **Voice Settings**: Customize voice preferences

### Voice Settings

1. **Open Settings**: Click "Voice Settings" from the voice options dropdown
2. **Configure Preferences**:
   - Select your preferred voice from the dropdown menu
   - Adjust speech speed using the speed slider
   - Modify pitch to your liking
   - Set comfortable volume level
3. **Test Your Settings**: Click "Test Voice" to hear how your settings sound
4. **Save Changes**: Click "Save Settings" to apply and remember your preferences

### Audio Downloads

1. **Download Audio**: Click "Download MP3" from the voice options
2. **File Naming**: Files are automatically named based on:
   - Conversation title (if available)
   - First few words of the response
   - Format: `gemini_voice_[title].wav`
3. **File Location**: Downloads go to your browser's default download folder

## Technical Implementation

### Architecture

The Voice Download feature is built using modern web APIs:

- **Web Speech API**: For text-to-speech conversion
- **MediaRecorder API**: For audio file generation (where supported)
- **Chrome Storage API**: For saving user preferences
- **MutationObserver**: For detecting new AI responses

### Browser Compatibility

- **Chrome/Chromium**: Full support including audio downloads
- **Firefox**: Speech playback supported, limited download capability
- **Safari**: Basic speech functionality
- **Edge**: Full support similar to Chrome

### File Structure

```
D/
‚îú‚îÄ‚îÄ voice_download.js         # Core functionality (620+ lines)
‚îú‚îÄ‚îÄ manifest.json            # Updated with voice download scripts
‚îî‚îÄ‚îÄ injector.js             # Integration with main extension
```

## Code Highlights

### Response Detection
```javascript
checkForNewResponses(element) {
    const responseSelectors = [
        '[data-response-index]',
        '.model-response-text',
        '.response-content',
        '[role="presentation"] .markdown',
        '.conversation-turn',
        'model-response'
    ];
    // Smart detection logic...
}
```

### Voice Button Creation
```javascript
createVoiceButton(responseElement) {
    const button = document.createElement('button');
    button.className = 'voice-download-btn';
    // Professional styling with hover effects...
}
```

### Settings Management
```javascript
async saveSettings() {
    await chrome.storage.local.set({ 
        voiceDownloadSettings: this.settings 
    });
}
```

## Benefits

### üîß **Accessibility**
- Helps users with visual impairments access AI responses
- Supports multitasking by allowing audio consumption
- Provides alternative content consumption method

### üì± **Productivity** 
- Listen to responses while working on other tasks
- Create audio notes from AI conversations
- Offline access to important AI responses

### üéì **Learning Enhancement**
- Auditory learning support for complex explanations
- Language learning assistance with pronunciation
- Better retention through multi-modal content consumption

## Comparison with ChatGPT Toolbox

| Feature | ChatGPT Toolbox | Gemini Toolbox Voice Download |
|---------|----------------|-------------------------------|
| Voice Playback | ‚úÖ Basic | ‚úÖ Advanced with controls |
| Audio Downloads | ‚úÖ MP3 | ‚úÖ WAV format |
| Voice Settings | ‚ùå Limited | ‚úÖ Comprehensive |
| Theme Support | ‚ùå Basic | ‚úÖ Full light/dark support |
| Smart Detection | ‚ùå Basic | ‚úÖ Advanced AI response detection |
| Settings Persistence | ‚ùå No | ‚úÖ Auto-save preferences |

## Future Enhancements

### Planned Features
- **Multiple Audio Formats**: Support for MP3, OGG, and other formats
- **Batch Processing**: Convert multiple responses at once
- **Cloud Integration**: Save audio files to cloud storage
- **Keyboard Shortcuts**: Quick access to voice functions
- **Custom Voice Training**: Personal voice model support

### Advanced Capabilities
- **SSML Support**: Advanced speech markup language
- **Emotion Recognition**: Contextual voice tone adjustment
- **Multi-language Support**: Automatic language detection
- **Voice Profiles**: Different settings for different use cases

## Troubleshooting

### Common Issues

**Voice button not appearing:**
- Ensure you're on a Gemini conversation page
- Refresh the page and wait for responses to load
- Check browser console for any errors

**Audio not playing:**
- Verify browser supports Web Speech API
- Check system volume and mute settings
- Try different voice selections in settings

**Download not working:**
- Modern browsers may have limited audio download support
- Use Chrome/Edge for best download compatibility
- Check browser permissions for downloads

### Getting Help

If you encounter issues:
1. Check the browser console for error messages
2. Try refreshing the page and testing again
3. Verify your browser supports the required web APIs
4. Test with different voice settings

## Technical Notes

### Performance
- Minimal impact on page load times
- Efficient memory usage with cleanup on page navigation
- Asynchronous initialization prevents blocking

### Security
- All processing happens locally in the browser
- No external API calls for speech synthesis
- User settings stored locally using Chrome Storage API

### Compatibility
- Works with all Gemini conversation types
- Compatible with existing Gemini Toolbox features
- No conflicts with other extensions

---

**Voice Download Feature v1.0** - Bringing advanced text-to-speech capabilities to Google Gemini, inspired by the best features of ChatGPT Toolbox while adding unique enhancements for the Gemini ecosystem.

====================================================================
FILE: D/chat_exporter.js
====================================================================
// Gemini Toolbox - chat_exporter.js

class ChatExporter {
    constructor(shadowRoot) {
        this.shadowRoot = shadowRoot;
        this.originalURL = window.location.href;
    }

    /**
     * Shows a modal to select the export format for a given chat.
     * @param {string} chatId The ID of the chat to export.
     * @param {string} chatTitle The title of the chat.
     */
    showFormatSelection(chatId, chatTitle) {
        let modal = document.createElement('div');
        modal.id = 'format-selection-modal';
        modal.className = 'gemini-modal-backdrop';
        modal.innerHTML = `
            <div class="gemini-modal-content" style="max-width: 400px;">
                <div class="gemini-modal-header">
                    <h2 style="font-size: 18px;">Export "${chatTitle}"</h2>
                    <button class="gemini-modal-close-btn">&times;</button>
                </div>
                <div class="gemini-modal-body format-selector">
                    <button data-format="pdf" class="format-btn">PDF</button>
                    <button data-format="html" class="format-btn">HTML</button>
                    <button data-format="md" class="format-btn">Markdown</button>
                    <button data-format="txt" class="format-btn">Text</button>
                    <button data-format="json" class="format-btn">JSON</button>
                </div>
            </div>
        `;
        this.shadowRoot.appendChild(modal);

        modal.querySelector('.gemini-modal-close-btn').onclick = () => modal.remove();
        modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

        modal.querySelectorAll('.format-btn').forEach(btn => {
            btn.onclick = () => {
                const format = btn.dataset.format;
                modal.remove();
                this.startExportProcess(chatId, chatTitle, format);
            };
        });
    }

    /**
     * Orchestrates the entire export process.
     */
    async startExportProcess(chatId, chatTitle, format) {
        this.showOverlay("Navigating to chat...");
        this.originalURL = window.location.href; // Save current URL

        // Clean the chat ID - remove 'c_' prefix if it exists
        const cleanChatId = chatId.startsWith('c_') ? chatId.substring(2) : chatId;

        // Navigate to the target chat page using the correct URL format
        window.location.href = `https://gemini.google.com/app/${cleanChatId}`;

        try {
            // Wait for the conversation to be loaded on the new page
            await this.waitForElement('message-content', document, 20000);
            await this.delay(2000); // Extra delay for content rendering

            this.updateOverlay("Loading full conversation...");
            await this.scrollToTopAndWait({
                loadWaitTimeout: 3000,
                maxTotalTime: 45000,
                maxScrollAttempts: 150
            });

            this.updateOverlay("Extracting content...");
            const conversation = this.extractConversationElements();
            if (!conversation || conversation.length === 0) {
                throw new Error("No content could be extracted from the chat. The page may not have finished loading, or the chat format has changed.");
            }

            this.updateOverlay(`Generating ${format.toUpperCase()} file...`);
            const fileNameBase = chatTitle.replace(/[^a-z0-9_\-]/gi, '_') || "gemini-conversation";

            switch (format) {
                case 'pdf':
                    await this.generatePDF(conversation, fileNameBase);
                    break;
                case 'html':
                    this.downloadAsHTML(conversation, fileNameBase);
                    break;
                case 'md':
                    this.downloadAsMarkdown(conversation, fileNameBase);
                    break;
                case 'txt':
                    this.downloadAsTXT(conversation, fileNameBase);
                    break;
                case 'json':
                    this.downloadAsJSON(conversation, fileNameBase);
                    break;
            }

            this.updateOverlay("Export successful!", true);
        } catch (error) {
            console.error("Gemini Exporter Error:", error);
            this.updateOverlay(`Error: ${error.message}`, true, true);
        } finally {
            // After a delay, navigate back to the original page
            setTimeout(() => {
                this.hideOverlay();
                if (window.location.href !== this.originalURL) {
                    window.location.href = this.originalURL;
                }
            }, 3000);
        }
    }
    
    // --- UI HELPER METHODS ---

    showOverlay(message) {
        let overlay = this.shadowRoot.querySelector('#exporter-overlay');
        if (overlay) overlay.remove();

        overlay = document.createElement('div');
        overlay.id = 'exporter-overlay';
        overlay.innerHTML = `
            <div class="exporter-overlay-content">
                <div class="exporter-spinner"></div>
                <div class="exporter-message">${message}</div>
            </div>
        `;
        this.shadowRoot.appendChild(overlay);
    }

    updateOverlay(message, isFinal = false, isError = false) {
        const overlay = this.shadowRoot.querySelector('#exporter-overlay');
        if (!overlay) return;

        overlay.querySelector('.exporter-message').textContent = message;

        if (isFinal) {
            const spinner = overlay.querySelector('.exporter-spinner');
            spinner.style.borderTopColor = isError ? '#d93025' : '#34a853';
            spinner.style.animation = 'none';
        }
    }

    hideOverlay() {
        const overlay = this.shadowRoot.querySelector('#exporter-overlay');
        if (overlay) overlay.remove();
    }

    // --- CORE EXPORT LOGIC ---
    
    delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    waitForElement(selector, parent = document, timeout = 7000) {
        return new Promise((resolve, reject) => {
            const element = parent.querySelector(selector);
            if (element) {
                console.log(`[Gemini Exporter] Element '${selector}' found immediately`);
                return resolve(element);
            }
            
            console.log(`[Gemini Exporter] Waiting for element '${selector}' (timeout: ${timeout}ms)`);
            const observer = new MutationObserver(() => {
                const element = parent.querySelector(selector);
                if (element) {
                    console.log(`[Gemini Exporter] Element '${selector}' found after waiting`);
                    observer.disconnect();
                    resolve(element);
                }
            });
            observer.observe(parent, { childList: true, subtree: true });
            setTimeout(() => {
                observer.disconnect();
                console.error(`[Gemini Exporter] Element '${selector}' not found within ${timeout}ms`);
                reject(new Error(`Element "${selector}" not found after ${timeout}ms`));
            }, timeout);
        });
    }

    getScrollHost() {
        let scrollHost = document.querySelector('#chat-history[data-test-id="chat-history-container"]');
        if (scrollHost) {
            console.log("[Gemini Exporter] Found scroll container by specific ID/data-test-id");
            return scrollHost;
        }
        
        scrollHost = document.querySelector("infinite-scroller.chat-history");
        if (scrollHost) {
            console.log("[Gemini Exporter] Found scroll container by custom element name + class");
            return scrollHost;
        }
        
        scrollHost = document.querySelector(".chat-history-scroll-container");
        if (scrollHost) {
            console.log("[Gemini Exporter] Found scroll container by common class name");
            return scrollHost;
        }
        
        // Check within main conversation area
        const mainArea = document.querySelector("main .conversation-area");
        if (mainArea) {
            const divs = mainArea.querySelectorAll("div");
            for (const div of divs) {
                const computedStyle = window.getComputedStyle(div);
                if ((computedStyle.overflowY === 'auto' || computedStyle.overflowY === 'scroll') && 
                    div.clientHeight > 300) {
                    console.log("[Gemini Exporter] Found potential scroll container by computed style within main area");
                    return div;
                }
            }
        }
        
        scrollHost = document.querySelector("infinite-scroller");
        if (scrollHost) {
            console.warn("[Gemini Exporter] Found scroll container by 'infinite-scroller' tag name (fallback).");
            return scrollHost;
        }
        
        console.error("[Gemini Exporter] All specific scroll container selectors failed. Falling back to documentElement.");
        return document.documentElement;
    }

    async scrollToTopAndWait(options = {}) {
        const {
            loadWaitTimeout = 2000,
            maxTotalTime = 30000,
            maxScrollAttempts = 100
        } = options;

        console.log("[Gemini Exporter] Starting robust scroll to top...");
        return new Promise(async (resolve, reject) => {
            let scroller;
            try {
                scroller = this.getScrollHost();
                if (!scroller) {
                    throw new Error("Scroll container returned null.");
                }
                
                const scrollContent = scroller === document.documentElement ? document.body : scroller;
                if (scrollContent.scrollHeight <= scrollContent.clientHeight) {
                    console.log("[Gemini Exporter] Scroller content doesn't exceed its height. No scrolling needed.");
                    return resolve();
                }
            } catch (error) {
                console.error(`[Gemini Exporter] Error finding scroll container: ${error.message}`);
                return reject(new Error("Scroll container lookup failed. Cannot scroll."));
            }

            const startTime = Date.now();
            let scrollAttempts = 0;
            const conversationSelector = 'div.conversation-container';
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
            const scrollTarget = scroller === document.documentElement ? window : scroller;

            while (scrollAttempts < maxScrollAttempts) {
                if (Date.now() - startTime > maxTotalTime) {
                    console.warn(`[Gemini Exporter] Scroll timeout reached after ${maxTotalTime}ms.`);
                    return reject(new Error(`Scroll process timed out after ${maxTotalTime}ms.`));
                }

                const messagesBeforeScroll = scroller.querySelectorAll(conversationSelector).length;
                const scrollTopBefore = scrollTarget === window ? window.scrollY : scrollTarget.scrollTop;
                
                console.log(`[Gemini Exporter] Scroll attempt ${scrollAttempts + 1}: Current messages: ${messagesBeforeScroll}, ScrollTop: ${scrollTopBefore}`);

                if (scrollTopBefore === 0 && scrollAttempts > 0) {
                    console.log("[Gemini Exporter] Reached scrollTop 0. Checking for final loads...");
                    await delay(loadWaitTimeout);
                    const messagesAfterWait = scroller.querySelectorAll(conversationSelector).length;
                    if (messagesAfterWait === messagesBeforeScroll) {
                        console.log("[Gemini Exporter] ScrollTop is 0 and no new messages loaded after wait. Scrolling complete.");
                        return resolve();
                    }
                    console.log(`[Gemini Exporter] Messages loaded after reaching top (${messagesBeforeScroll} -> ${messagesAfterWait}). Continuing check.`);
                }

                // Scroll to top
                if (scrollTarget === window) {
                    window.scrollTo(0, 0);
                } else {
                    scrollTarget.scrollTop = 0;
                    scrollTarget.dispatchEvent(new Event('scroll'));
                }
                console.log("[Gemini Exporter] Scrolled to top (scrollTop set to 0).");

                // Wait for new messages to load
                let messagesLoaded = false;
                const waitStartTime = Date.now();
                while (Date.now() - waitStartTime < loadWaitTimeout) {
                    const messagesAfterScroll = scroller.querySelectorAll(conversationSelector).length;
                    if (messagesAfterScroll > messagesBeforeScroll) {
                        console.log(`[Gemini Exporter] New messages loaded (${messagesBeforeScroll} -> ${messagesAfterScroll}).`);
                        messagesLoaded = true;
                        break;
                    }
                    
                    const currentScrollTop = scrollTarget === window ? window.scrollY : scrollTarget.scrollTop;
                    if (currentScrollTop > 5 && scrollTopBefore === 0) {
                        console.warn(`[Gemini Exporter] Scroll position changed unexpectedly after scroll attempt (${currentScrollTop}).`);
                    }
                    
                    await delay(100);
                }

                if (!messagesLoaded) {
                    const finalScrollTop = scrollTarget === window ? window.scrollY : scrollTarget.scrollTop;
                    if (finalScrollTop === 0) {
                        console.log("[Gemini Exporter] Scrolled, waited, no new messages loaded, and still at scrollTop 0. Assuming end of history.");
                        return resolve();
                    }
                    console.warn(`[Gemini Exporter] Scrolled, waited, no new messages, but scrollTop is now ${finalScrollTop}. Continuing loop cautiously.`);
                }

                scrollAttempts++;
                await delay(50);
            }

            console.warn(`[Gemini Exporter] Reached max scroll attempts (${maxScrollAttempts}). Finishing scroll process.`);
            resolve();
        });
    }

    extractConversationElements() {
        const conversationPairs = [];
        let scroller;
        
        try {
            scroller = this.getScrollHost();
            if (!scroller) {
                throw new Error("Scroller element not found.");
            }
        } catch (error) {
            console.error("[Gemini Exporter] Could not find chat history scroller for extraction:", error);
            return conversationPairs;
        }

        const conversationContainers = scroller.querySelectorAll('div.conversation-container');
        console.log(`[Gemini Exporter] Found ${conversationContainers.length} conversation containers within scroller.`);

        conversationContainers.forEach(container => {
            const userQueryEl = container.querySelector('user-query, user-query-content');
            const modelResponseEl = container.querySelector('message-content');

            let questionHTML = '';
            // Try to get user query text
            const queryTextLine = userQueryEl?.querySelector('.query-text-line');
            if (queryTextLine) {
                questionHTML = queryTextLine.innerHTML.trim();
            } else if (userQueryEl) {
                const clonedUserEl = userQueryEl.cloneNode(true);
                clonedUserEl.querySelectorAll('mat-icon, .icon-button').forEach(el => el.remove());
                questionHTML = clonedUserEl.innerHTML.trim();
            }

            let answerHTML = '';
            // Try to get model response
            const responseContent = modelResponseEl?.querySelector('.markdown-main-panel, .output-content .markdown, .output-content');
            if (responseContent) {
                answerHTML = responseContent.innerHTML.trim();
            } else if (modelResponseEl) {
                const clonedResponseEl = modelResponseEl.cloneNode(true);
                clonedResponseEl.querySelectorAll('message-actions, mat-icon-button, .icon-button, response-actions').forEach(el => el.remove());
                answerHTML = clonedResponseEl.innerHTML.trim();
            }

            if (questionHTML || answerHTML) {
                // Clean up any checkbox containers that might be present
                const tempQuestionDiv = document.createElement('div');
                tempQuestionDiv.innerHTML = questionHTML;
                tempQuestionDiv.querySelectorAll('.gemini-export-checkbox-container').forEach(el => el.remove());
                
                const tempAnswerDiv = document.createElement('div');
                tempAnswerDiv.innerHTML = answerHTML;
                tempAnswerDiv.querySelectorAll('.gemini-export-checkbox-container').forEach(el => el.remove());
                
                conversationPairs.push({ 
                    question: tempQuestionDiv.innerHTML || null, 
                    answer: tempAnswerDiv.innerHTML || null 
                });
            }
        });

        return conversationPairs;
    }
    
    generateFilename(base, ext) {
        const timestamp = new Date().toISOString().split('T')[0];
        return `${base}-${timestamp}.${ext}`;
    }

    downloadData(data, filename, type) {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        chrome.runtime.sendMessage({
            action: 'downloadFile',
            url: url,
            filename: filename
        }, () => URL.revokeObjectURL(url));
    }

    convertHtmlToMarkdown(html) {
        if (!html) return "";
        let markdown = html;
        // Basic conversions; a more robust library might be needed for complex cases
        markdown = markdown.replace(/<p>(.*?)<\/p>/gi, '$1\n\n');
        markdown = markdown.replace(/<br\s*\/?>/gi, '\n');
        markdown = markdown.replace(/<strong>(.*?)<\/strong>/gi, '**$1**');
        markdown = markdown.replace(/<em>(.*?)<\/em>/gi, '*$1*');
        markdown = markdown.replace(/<h1>(.*?)<\/h1>/gi, '# $1\n');
        markdown = markdown.replace(/<h2>(.*?)<\/h2>/gi, '## $1\n');
        markdown = markdown.replace(/<h3>(.*?)<\/h3>/gi, '### $1\n');
        markdown = markdown.replace(/<li>(.*?)<\/li>/gi, '* $1\n');
        markdown = markdown.replace(/<pre><code>(.*?)<\/code><\/pre>/gis, '```\n$1\n```\n');
        markdown = markdown.replace(/<code>(.*?)<\/code>/gi, '`$1`');
        // Strip remaining tags
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = markdown;
        return tempDiv.textContent || tempDiv.innerText || '';
    }

    formatConversationHTML(conversation, title, theme = 'light') {
        const isDark = theme === 'dark';
        const styles = `
            body { font-family: sans-serif; margin: 0; padding: 2em; background-color: ${isDark ? '#131314' : '#fff'}; color: ${isDark ? '#e3e3e3' : '#202124'}; }
            .wrapper { max-width: 800px; margin: auto; }
            h1 { font-size: 24px; border-bottom: 1px solid #ccc; padding-bottom: 10px; }
            .pair { margin-bottom: 2em; }
            .question, .answer { padding: 1em; border-radius: 8px; }
            .question { background-color: ${isDark ? '#1e1e1f' : '#f0f4f9'}; }
            .answer { background-color: ${isDark ? '#2a2a2c' : '#f8f9fa'}; margin-top: 1em; }
            .label { font-weight: bold; margin-bottom: 0.5em; color: ${isDark ? '#8ab4f8' : '#1a73e8'}; }
            code-block, pre { background-color: ${isDark ? '#202124' : '#e8eaed'} !important; padding: 1em; border-radius: 8px; overflow-x: auto; font-family: monospace; }
        `;
        let body = `<h1>${title}</h1><p><i>Exported on: ${new Date().toLocaleString()}</i></p>`;
        conversation.forEach(c => {
            body += '<div class="pair">';
            if (c.question) body += `<div class="question"><div class="label">User</div><div>${c.question}</div></div>`;
            if (c.answer) body += `<div class="answer"><div class="label">Gemini</div><div>${c.answer}</div></div>`;
            body += '</div>';
        });

        return `<!DOCTYPE html><html><head><title>${title}</title><style>${styles}</style></head><body><div class="wrapper">${body}</div></body></html>`;
    }

    async generatePDF(conversation, fileNameBase) {
        const theme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
        const htmlContent = this.formatConversationHTML(conversation, fileNameBase, theme);
        const fileName = this.generateFilename(fileNameBase, 'pdf');
        
        // Use the html2pdf library already included in your extension
        if (typeof html2pdf === 'undefined') {
            throw new Error('html2pdf.js is not loaded.');
        }

        const opt = {
            margin: 0.5,
            filename: fileName,
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2, useCORS: true, backgroundColor: theme === 'dark' ? '#131314' : '#ffffff' },
            jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' }
        };

        // html2pdf returns a promise-like object
        await html2pdf().from(htmlContent).set(opt).save();
    }

    downloadAsHTML(conversation, fileNameBase) {
        const theme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
        const htmlContent = this.formatConversationHTML(conversation, fileNameBase, theme);
        const fileName = this.generateFilename(fileNameBase, 'html');
        this.downloadData(htmlContent, fileName, 'text/html;charset=utf-8');
    }
    
    downloadAsMarkdown(conversation, fileNameBase) {
        let content = `# ${fileNameBase}\n\n---\n\n`;
        conversation.forEach(c => {
            if (c.question) content += `**User:**\n${this.convertHtmlToMarkdown(c.question)}\n\n`;
            if (c.answer) content += `**Gemini:**\n${this.convertHtmlToMarkdown(c.answer)}\n\n`;
            content += '---\n\n';
        });
        const fileName = this.generateFilename(fileNameBase, 'md');
        this.downloadData(content, fileName, 'text/markdown;charset=utf-8');
    }

    downloadAsTXT(conversation, fileNameBase) {
        let content = `${fileNameBase}\n\n`;
        const tempDiv = document.createElement('div');
        conversation.forEach(c => {
            if (c.question) {
                tempDiv.innerHTML = c.question;
                content += `User:\n${tempDiv.textContent || tempDiv.innerText}\n\n`;
            }
            if (c.answer) {
                tempDiv.innerHTML = c.answer;
                content += `Gemini:\n${tempDiv.textContent || tempDiv.innerText}\n\n`;
            }
            content += '----------------------------------------\n\n';
        });
        const fileName = this.generateFilename(fileNameBase, 'txt');
        this.downloadData(content, fileName, 'text/plain;charset=utf-8');
    }

    downloadAsJSON(conversation, fileNameBase) {
        const data = {
            title: fileNameBase,
            exportedAt: new Date().toISOString(),
            conversation: conversation
        };
        const fileName = this.generateFilename(fileNameBase, 'json');
        this.downloadData(JSON.stringify(data, null, 2), fileName, 'application/json;charset=utf-8');
    }
}

====================================================================
FILE: D/D/injector.js
====================================================================
// Gemini Folders - REFACTORED injector.js
(function() {
    'use strict';

    // --- CONSTANTS AND STATE ---
    const INJECTOR_HOST_ID = 'gemini-folders-injector-host';
    const STORAGE_KEY = 'geminiFoldersData';

    // Selectors for the deletion logic, adapted from the source extension
    const DELETE_BUTTON_SELECTORS = ['button[data-test-id="delete-button"]', 'button[aria-label*="delete"]', 'button:contains("Delete")', "button.delete-btn"];
    const CONFIRM_BUTTON_SELECTORS = ['button[data-test-id="confirm-button"]', 'button:contains("Delete")', 'button:contains("Confirm")', 'button[aria-label*="confirm"]', "button.confirm-btn"];
    const ACTIONS_MENU_SELECTORS = ['button[data-test-id="actions-menu-button"]', 'button[aria-label*="actions"]', 'button[aria-label*="menu"]', "button.menu-button", "button.actions-button"];
    const OVERLAY_CONTAINER_SELECTORS = ["div.cdk-overlay-container", '[role="dialog"]', ".modal-container", ".overlay-container"];

    let hostElement = null;
    let shadow = null;
    let currentTheme = 'light';
    let isModalOpen = false;

    // State object to hold dynamic data, similar to the target's storage module.
    let state = {
        folders: [],
        settings: {
            hideFolderedChats: false
        },
        selectedItems: [],
        modalType: null, // e.g., 'MANAGE_FOLDERS', 'ADD_FOLDER'
    };

    // --- ORIGINAL UTILITY FUNCTIONS (Unchanged) ---
    function generateUUID() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }
    function delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    // --- NEW HELPER FUNCTIONS (for Bulk Delete) ---
    function delayMs(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function findElement(selectors, parent = document) {
        if (!parent) return null;
        for (const selector of selectors) {
            try {
                const element = parent.querySelector(selector);
                if (element) return element;
            } catch (e) {
                console.warn(`[Gemini Toolbox] Invalid selector "${selector}":`, e);
            }
        }
        return null;
    }

    function waitForElement(selectors, parent = document, timeout = 7000) {
        return new Promise((resolve, reject) => {
            const element = findElement(selectors, parent);
            // Check if element is not only present but also visible and interactive
            if (element && element.offsetParent !== null && !element.disabled) {
                return resolve(element);
            }

            let elapsedTime = 0;
            const interval = 150;
            const timer = setInterval(() => {
                elapsedTime += interval;
                const foundElement = findElement(selectors, parent);
                if (foundElement && foundElement.offsetParent !== null && !foundElement.disabled) {
                    clearInterval(timer);
                    resolve(foundElement);
                } else if (elapsedTime >= timeout) {
                    clearInterval(timer);
                    console.error(`[Gemini Toolbox] Element not actionable within ${timeout}ms. Tried selectors:`, selectors);
                    reject(new Error(`Element not actionable within ${timeout}ms`));
                }
            }, interval);
        });
    }


    async function loadData() {
        try {
            const result = await chrome.storage.local.get(STORAGE_KEY);
            // Initialize with default structure if it doesn't exist
            state.folders = result[STORAGE_KEY]?.folders || [];
            state.settings = result[STORAGE_KEY]?.settings || { hideFolderedChats: false };
        } catch (error) {
            console.error("Gemini Folders: Error loading data", error);
            state.folders = [];
            state.settings = { hideFolderedChats: false };
        }
    }

    async function saveData() {
        try {
            // Only save the necessary parts of the state
            const dataToSave = { 
                folders: state.folders,
                settings: state.settings 
            };
            await chrome.storage.local.set({ [STORAGE_KEY]: dataToSave });
        } catch (error) {
            console.error("Gemini Folders: Error saving data", error);
        }
    }
    
    function getChatIdFromElement(chatElement) {
        if (!chatElement) return null;
        const jslog = chatElement.getAttribute('jslog');
        if (jslog) {
            const match = jslog.match(/BardVeMetadataKey:\[[^\]]*\["([^"]+)"/);
            if (match && match[1]) {
                return match[1];
            }
        }
        const testId = chatElement.getAttribute('data-test-id');
        if (testId && testId.startsWith('conversation_c_')) {
            return testId.substring('conversation_'.length);
        }
        return null;
    }

    function getAllConversationElements() {
        return Array.from(document.querySelectorAll('conversations-list div[data-test-id="conversation"]'));
    }

    function getTextColorForBackground(hexColor) {
        if (!hexColor || hexColor.length < 7) return 'var(--gf-text-primary)'; // Default if invalid

        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);

        // Formula for perceived brightness (YIQ)
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;

        // Return black for light backgrounds, white for dark backgrounds
        return brightness > 155 ? '#000000' : '#FFFFFF';
    }

    // --- THEME & STYLING (Slightly modified to use a single CSS block) ---
    function detectTheme() {
        const body = document.body;
        if (body.classList.contains('dark-theme') || body.classList.contains('dark_mode_toggled')) return 'dark';
        const htmlTheme = document.documentElement.getAttribute('data-theme');
        if (htmlTheme === 'dark') return 'dark';
        const bodyBgColor = window.getComputedStyle(body).backgroundColor;
        if (bodyBgColor) {
            const rgb = bodyBgColor.match(/\d+/g);
            if (rgb && rgb.length >= 3) {
                const brightness = (parseInt(rgb[0]) * 299 + parseInt(rgb[1]) * 587 + parseInt(rgb[2]) * 114) / 1000;
                return brightness < 128 ? 'dark' : 'light';
            }
        }
        return 'light';
    }

    function createGlobalStyles() {
        if (!shadow) return;
        const styleElement = document.createElement('style');
        // REFACTORED: We'll use a single, large CSS block that contains all styles
        // for the modals, lists, buttons, etc., mimicking the target UI.
        styleElement.textContent = `
            :host { 
                /* Light Theme */
                --gf-bg-primary-light: #FFFFFF;
                --gf-text-primary-light: #202124;
                --gf-danger-light: #d93025;
                --gf-border-light: #dadce0;
                --gf-hover-light: #f1f3f4;
                --gf-blue-light: #1a73e8;
                --gf-bg-secondary-light: #f0f4f9;
                --gf-border-color-light: #dadce0;
                --gf-text-primary-light: #1f1f1f;
                --gf-text-secondary-light: #5f6368;
                --gf-accent-primary-light: #1a73e8;
                --gf-accent-danger-light: #d93025;
                --gf-bg-input-light: #ffffff;

                /* Dark Theme */
                --gf-bg-primary-dark: #131314;
                --gf-bg-secondary-dark: #2d2d2f;
                --gf-border-color-dark: #5f6368;
                --gf-text-primary-dark: #e3e3e3;
                --gf-text-secondary-dark: #9aa0a6;
                --gf-accent-primary-dark: #8ab4f8;
                --gf-accent-danger-dark: #f28b82;
                --gf-bg-input-dark: #2d2d2f;

                /* Default to dark theme from screenshot */
                --gf-text-primary: var(--gf-text-primary-dark);
                --gf-text-secondary: #969ba1;
                --gf-bg-primary: var(--gf-bg-primary-dark);
                --gf-hover-bg: var(--gf-hover-dark);
                --gf-border-color: var(--gf-border-dark);
                --gf-danger: var(--gf-danger-dark);
                --gf-blue-accent: var(--gf-blue-dark);
            }
            .sidebar-tab { 
                display: flex; align-items: center; gap: 12px;
                padding: 10px; margin: 4px 0; border-radius: 8px;
                cursor: pointer; font-size: 14px; color: var(--gf-text-primary);
                position: relative;
            }
            .sidebar-tab:hover { background-color: var(--gf-hover-bg); }

            /* Gemini Toolbox Button and Dropdown */
            .toolbox-button {
                display: flex; align-items: center; gap: 8px;
                width: 100%; padding: 0; border: none; background: none;
                cursor: pointer; font-size: 14px; color: var(--gf-text-primary);
            }
            .toolbox-button:hover { background-color: var(--gf-hover-bg); }

            .dropdown-arrow {
                margin-left: auto;
                transition: transform 0.2s ease;
            }
            .dropdown-arrow.rotated {
                transform: rotate(180deg);
            }

            .toolbox-dropdown {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background-color: var(--gf-bg-primary);
                border: 1px solid var(--gf-border-color);
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 1000;
                overflow: hidden;
            }

            .dropdown-item {
                display: flex; align-items: center; gap: 8px;
                padding: 12px; cursor: pointer;
                color: var(--gf-text-primary);
                font-size: 14px;
                transition: background-color 0.2s ease;
            }
            .dropdown-item:hover {
                background-color: var(--gf-hover-bg);
            }

            /* Modal Backdrop */
            .infi-chatgpt-modal {
                position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
                background-color: rgba(0,0,0,0.65); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            }
            /* Modal Content Box */
            .modal-content {
                width: 600px;
                background-color: var(--gf-bg-primary);
                border-radius: 12px; border: 1px solid var(--gf-border-color);
                box-shadow: 0 5px 20px rgba(0,0,0,0.4);
                color: var(--gf-text-primary);
                display: flex; flex-direction: column;
                max-height: 80vh;
            }
            .modal-header {
                display: flex; justify-content: space-between; align-items: center;
                padding: 20px;
            }
            .modal-header h2 { margin: 0; font-size: 20px; font-weight: 500; }
            .modal-body { 
                padding: 0 20px 20px 20px; 
                display: flex; flex-direction: column;
                flex-grow: 1;
                overflow-y: hidden;
            }
             .infi-chatgpt-manageTabs-content {
                display: flex; flex-direction: column;
                height: 100%;
            }
            #folder-list-container {
                flex-grow: 1;
                overflow-y: auto;
                margin-top: 16px;
            }
             .infi-chatgpt-manageTabs-buttonsContainer {
                margin-top: auto; /* Pushes to the bottom */
                padding-top: 16px;
                text-align: right;
            }
            /* Buttons */
            .button {
                border: none; border-radius: 6px; padding: 8px 14px;
                font-size: 14px; cursor: pointer;
            }
            .primary { background-color: #8AB4F8; color: #202124; }
            .secondary { background-color: var(--gf-hover-bg); color: var(--gf-text-primary); }
            .danger { background-color: var(--gf-danger); color: #202124; }
            .icon-btn { background: none; border: none; cursor: pointer; color: var(--gf-text-secondary); }

            /* Form & List Styles */
            input[type="text"], input[type="search"] {
                width: 100%;
                padding: 8px 12px;
                background-color: var(--gf-bg-input);
                border: 1px solid var(--gf-border-color);
                color: var(--gf-text-primary);
                border-radius: 6px;
                box-sizing: border-box; /* Important */
                font-size: 14px;
            }
            .list-item {
                display: flex; align-items: center; gap: 10px;
                padding: 8px; border-radius: 6px; margin-bottom: 4px;
            }
            .list-item:hover { background-color: var(--gf-hover-bg); }
            .list-item .item-title {
                flex-grow: 1;
                cursor: pointer;
            }

            .list-item .item-controls {
                display: flex;
                align-items: center;
                gap: 8px;
                color: var(--gf-text-secondary);
            }
            
            .list-item .add-subfolder-btn {
                opacity: 0;
                transition: opacity 0.2s ease-in-out;
            }
            
            .list-item:hover .add-subfolder-btn {
                opacity: 1;
            }

            .icon-btn {
                background: none;
                border: none;
                cursor: pointer;
                color: var(--gf-text-secondary);
            }

            /* --- NEW: Bulk Delete Modal Specific Styles --- */
            #bulk-delete-list {
                margin-top: 16px;
                max-height: 400px;
                overflow-y: auto;
                padding-right: 10px; /* For scrollbar */
            }
            .bulk-delete-item {
                display: flex;
                align-items: center;
                padding: 8px;
                border-radius: 6px;
                margin-bottom: 4px;
            }
             .bulk-delete-item:hover {
                background-color: var(--gf-hover-bg);
            }
            .bulk-delete-item input[type="checkbox"] {
                margin-right: 12px;
                width: 18px;
                height: 18px;
            }
            .bulk-delete-item label {
                font-size: 14px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
             #bulk-delete-controls {
                padding-top: 16px;
                border-top: 1px solid var(--gf-border-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            #bulk-delete-select-all-container {
                display: flex;
                align-items: center;
            }
             #bulk-delete-status {
                font-size: 14px;
                color: var(--gf-text-secondary);
            }

            .light-theme {
                --gf-bg-primary: var(--gf-bg-primary-light);
                --gf-text-primary: var(--gf-text-primary-light);
                --gf-text-secondary: var(--gf-text-secondary-light);
                --gf-accent-primary: var(--gf-accent-primary-light);
                --gf-accent-danger: var(--gf-accent-danger-light);
                --gf-bg-input: var(--gf-bg-input-light);
            }
            .dark-theme {
                --gf-bg-primary: var(--gf-bg-primary-dark);
                --gf-bg-secondary: var(--gf-bg-secondary-dark);
                --gf-border-color: var(--gf-border-color-dark);
                --gf-text-primary: var(--gf-text-primary-dark);
                --gf-text-secondary: var(--gf-text-secondary-dark);
                --gf-accent-primary: var(--gf-accent-primary-dark);
                --gf-accent-danger: var(--gf-accent-danger-dark);
                --gf-bg-input: var(--gf-bg-input-dark);
            }
            .dark-theme .danger {
                background-color: var(--gf-accent-danger-dark);
                color: #202124;
            }
        `;
        shadow.appendChild(styleElement);
        applyThemeStyles();
    }

    function applyThemeStyles() {
        if (!hostElement) return;
        currentTheme = detectTheme();
        const isDark = currentTheme === 'dark';

        hostElement.style.setProperty('--gf-bg-primary', isDark ? 'var(--gf-bg-primary-dark)' : 'var(--gf-bg-primary-light)');
        hostElement.style.setProperty('--gf-text-primary', isDark ? 'var(--gf-text-primary-dark)' : 'var(--gf-text-primary-light)');
        hostElement.style.setProperty('--gf-danger', isDark ? 'var(--gf-danger-dark)' : 'var(--gf-danger-light)');
        hostElement.style.setProperty('--gf-border-color', isDark ? 'var(--gf-border-dark)' : 'var(--gf-border-light)');
        hostElement.style.setProperty('--gf-hover-bg', isDark ? 'var(--gf-hover-dark)' : 'var(--gf-hover-light)');
        hostElement.style.setProperty('--gf-blue-accent', isDark ? 'var(--gf-blue-dark)' : 'var(--gf-blue-light)');
        hostElement.style.setProperty('--gf-text-secondary', isDark ? 'var(--gf-text-secondary-dark)' : 'var(--gf-text-secondary-light)');
        hostElement.style.setProperty('--gf-accent-primary', isDark ? 'var(--gf-accent-primary-dark)' : 'var(--gf-accent-primary-light)');
        hostElement.style.setProperty('--gf-accent-danger', isDark ? 'var(--gf-accent-danger-dark)' : 'var(--gf-accent-danger-light)');
        hostElement.style.setProperty('--gf-bg-input', isDark ? 'var(--gf-bg-input-dark)' : 'var(--gf-bg-input-light)');
    }

    // --- NEW: UI COMPONENT GENERATION (HTML Templates) ---
    // These functions replicate the HTML structure from our target UI analysis.

    function getSidebarTabHTML() {
        return `
            <div id="gemini-toolbox-container" class="sidebar-tab">
                <div id="gemini-toolbox-btn" class="toolbox-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10 4H4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H20C21.1046 20 22 19.1046 22 18V8C22 6.89543 21.1046 6 20 6H12L10 4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                    <span>Gemini Toolbox</span>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="dropdown-arrow">
                        <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div id="gemini-toolbox-dropdown" class="toolbox-dropdown" style="display: none;">
                    <div id="manage-folders-link" class="dropdown-item">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M10 4H4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H20C21.1046 20 22 19.1046 22 18V8C22 6.89543 21.1046 6 20 6H12L10 4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Manage Folders</span>
                    </div>
                    <div id="bulk-delete-link" class="dropdown-item">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0v12m4-12v12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Bulk Delete</span>
                    </div>
                </div>
            </div>
        `;
    }

    function getManageFoldersModalHTML() {
        const folderTreeHTML = renderFolderTree(null, 0);

        function renderFolderTree(parentId, level) {
            let html = '';
            const children = state.folders.filter(f => f.parentId === parentId);
    
            children.forEach(folder => {
                html += `
                    <div class="list-item" data-folder-id="${folder.id}" style="margin-left: ${level * 20}px;">
                        <span class="folder-icon"></span>
                        <span class="item-title">${folder.name}</span>
                        <div class="item-controls">
                            <span>(${folder.chatIds?.length || 0})</span>
                             <button class="icon-btn add-chats-btn" data-folder-id="${folder.id}" title="Add Chats">+</button>
                             <button class="icon-btn add-subfolder-btn" data-parent-id="${folder.id}" title="Add Subfolder">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder-plus"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line></svg>
                            </button>
                             <button class="icon-btn delete-folder-btn" data-folder-id="${folder.id}" title="Delete Folder">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-trash-2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                        </div>
                    </div>
                `;
                // Recursive call for children
                html += renderFolderTree(folder.id, level + 1);
            });
            return html;
        }
    
        return `
            <div class="modal-header">
                <h2>Manage Folders</h2>
                <button class="icon-btn" id="close-modal-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="infi-chatgpt-manageTabs-content">
                    <div style="display: flex; gap: 8px;">
                        <button class="button primary" id="add-folder-btn">Add Folder</button>
                        <input type="search" id="search-folders-input" placeholder="Search folders..." style="flex-grow: 1;">
                </div>
                <div id="folder-list-container">
                        ${renderFolderTree(null, 0)}
                </div>
                    <div class="infi-chatgpt-manageTabs-buttonsContainer">
                         <div style="display: flex; align-items: center; justify-content: flex-end; gap: 8px;">
                            <label for="hide-foldered-toggle">Hide Foldered Chats</label>
                            <input type="checkbox" id="hide-foldered-toggle" ${state.settings.hideFolderedChats ? 'checked' : ''} />
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function getFolderItemHTML(folder) {
        const selected = state.selectedItems.includes(folder.id);
        return `
            <div class="list-item folder-item" data-id="${folder.id}">
                <input type="checkbox" class="item-checkbox" data-id="${folder.id}" ${selected ? 'checked' : ''}>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 4H4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H20C21.1046 20 22 19.1046 22 18V8C22 6.89543 21.1046 6 20 6H12L10 4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                <span class="item-title">${folder.name}</span>
                <span class="item-count" style="margin-left: auto; color: var(--gf-text-secondary);">(${folder.chatIds.length})</span>
                <button class="add-chats-btn icon-btn" data-folder-id="${folder.id}" title="Add chats to folder">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 5V19M5 12H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
            </div>
        `;
    }

    function getAddFolderModalHTML(isEdit = false, folderName = '') {
        const title = isEdit ? 'Edit Folder Name' : 'Add New Folder';
        const buttonText = isEdit ? 'Save Changes' : 'Create Folder';
        return `
            <form id="add-folder-form" style="display: flex; flex-direction: column; gap: 16px;">
                <input type="text" id="folder-name-input" value="${folderName}" placeholder="Enter folder name" required>
                <div style="display: flex; justify-content: flex-end; gap: 8px;">
                    <button type="button" id="cancel-folder-btn" class="button secondary">Cancel</button>
                    <button type="button" id="save-folder-btn" class="button primary">${buttonText}</button>
                </div>
            </form>
        `;
    }
    
    function getConfirmDeleteModalHTML() {
        return `<p>Are you sure you want to delete this folder and all its contents? This action cannot be undone.</p>`;
    }

    function getBulkDeleteModalHTML() {
        // Recursive function to render deletable tree
        function renderDeletableTree(parentId, level) {
            let html = '';
            const children = state.folders.filter(f => f.parentId === parentId);
            
            children.forEach(folder => {
                const chatCount = folder.chatIds?.length || 0;
                html += `
                    <div class="bulk-delete-item" style="margin-left: ${level * 20}px;">
                        <input type="checkbox" id="del-folder-${folder.id}" class="bulk-delete-checkbox" data-type="folder" data-id="${folder.id}">
                        <label for="del-folder-${folder.id}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 8px;">
                                <path d="M10 4H4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H20C21.1046 20 22 19.1046 22 18V8C22 6.89543 21.1046 6 20 6H12L10 4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            ${folder.name} (${chatCount} chats)
                        </label>
                    </div>
                `;
                
                // Recursively render subfolders
                html += renderDeletableTree(folder.id, level + 1);
            });
            
            return html;
        }

        // Render folder tree
        const folderTreeHTML = renderDeletableTree(null, 0);
        
        // Get unassigned chats
        const assignedChatIds = new Set();
        state.folders.forEach(folder => {
            folder.chatIds?.forEach(chatId => assignedChatIds.add(chatId));
        });
        
        const conversations = getAllConversationElements();
        const unassignedChatsHTML = conversations.map((conv, index) => {
            const titleElement = conv.querySelector('.conversation-title');
            const title = titleElement ? titleElement.textContent.trim() : `Conversation ${index + 1}`;
            const chatId = getChatIdFromElement(conv) || `chat-index-${index}`;
            
            // Only include unassigned chats
            if (chatId && assignedChatIds.has(chatId)) {
                return '';
            }
            
        return `
                <div class="bulk-delete-item">
                    <input type="checkbox" id="del-check-${chatId}" class="bulk-delete-checkbox" data-type="chat" data-chat-id="${chatId}">
                    <label for="del-check-${chatId}">${title}</label>
                </div>
            `;
        }).filter(html => html !== '').join('');

        const listHTML = folderTreeHTML + (unassignedChatsHTML ? `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--gf-border-color);">
                <h4 style="margin: 0 0 8px 0; color: var(--gf-text-secondary);">Unassigned Chats</h4>
                ${unassignedChatsHTML}
            </div>
        ` : '');

        return `
            <div id="bulk-delete-list">
                ${listHTML || '<p>No folders or conversations found.</p>'}
            </div>
            <div id="bulk-delete-controls">
                <div id="bulk-delete-select-all-container">
                    <input type="checkbox" id="bulk-delete-select-all">
                    <label for="bulk-delete-select-all" style="margin-left: 8px;">Select All</label>
                </div>
                <span id="bulk-delete-status"></span>
                <button id="start-bulk-delete-btn" class="button danger">Start Bulk Delete</button>
            </div>
        `;
    }

    // --- NEW: HTML Generator for the Add Chats Modal ---
    function getAddChatsModalHTML(folder, unassignedChats) {
        let chatListHTML = '';
        if (unassignedChats.length > 0) {
            chatListHTML = unassignedChats.map(chat => `
                <div class="list-item chat-item">
                    <input type="checkbox" class="chat-select-checkbox" data-chat-id="${chat.id}">
                    <span class="item-title">${chat.title}</span>
                </div>
            `).join('');
        } else {
            chatListHTML = '<p style="color: var(--gf-text-secondary); text-align: center; margin-top: 20px;">No available chats to add.</p>';
        }

        return `
            <div id="add-chats-list-container" style="max-height: 40vh; overflow-y: auto;">
                ${chatListHTML}
            </div>
            <div class="modal-buttons">
                <button type="button" id="cancel-add-chats" class="button secondary">Cancel</button>
                <button type="button" id="save-add-chats" class="button primary">Add Selected</button>
            </div>
        `;
    }

    // --- NEW: MODAL MANAGEMENT SYSTEM ---

    function openModal(id, title, contentHTML, width = 600) {
        if (isModalOpen) {
            closeModal();
        }

        hostElement = document.createElement('div');
        hostElement.id = INJECTOR_HOST_ID;
        document.body.appendChild(hostElement);
        shadow = hostElement.attachShadow({ mode: 'open' });
        
        const modalContainer = document.createElement('div');
        modalContainer.className = 'infi-chatgpt-modal';
        modalContainer.id = id;

        let finalHTML = contentHTML;

        // Check if the provided HTML already contains a header.
        // This is a simple check; could be made more robust.
        if (!contentHTML.includes('modal-header')) {
             finalHTML = `
                <div class="modal-header">
                    <h2>${title}</h2>
                    <button class="icon-btn" id="close-modal-btn">&times;</button>
                </div>
                <div class="modal-body">
                    ${contentHTML}
            </div>
        `;
        }
        
        modalContainer.innerHTML = `
            <div class="modal-content" style="width: ${width}px;">
               ${finalHTML}
            </div>
        `;

        shadow.appendChild(modalContainer);
        createGlobalStyles(); // Apply styles AFTER content is added
        
        const closeBtn = shadow.getElementById('close-modal-btn');
        if(closeBtn) {
            closeBtn.addEventListener('click', closeModal);
        }

        isModalOpen = true;
    }

    function closeModal() {
        const modal = shadow.querySelector('.infi-chatgpt-modal');
        if (modal) {
            modal.remove();
        }
        isModalOpen = false;
        state.modalType = null;
    }

    // --- NEW & REFACTORED: LOGIC CONTROLLERS ---

    async function renderFolderList() {
        const listContainer = shadow.getElementById('folder-list-container');
        if (!listContainer) return;
        
        listContainer.innerHTML = '';
        const folders = state.folders;
        
        if (folders.length === 0) {
            listContainer.innerHTML = `<p>No folders yet. Click "Add Folder" to create one.</p>`;
            return;
        }

        folders.forEach(folder => {
            const itemHTML = getFolderItemHTML(folder);
            listContainer.innerHTML += itemHTML;
        });

        // Attach event listeners to newly rendered items
        attachFolderItemListeners();
    }
    
    function attachFolderItemListeners() {
        shadow.querySelectorAll('.folder-item').forEach(item => {
            item.addEventListener('click', handleFolderItemClick);
        });
        shadow.querySelectorAll('.item-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', handleCheckboxChange);
        });
        // --- NEW: Attach listener for the new Add Chats button ---
        shadow.querySelectorAll('.add-chats-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent folder navigation click
                const folderId = e.currentTarget.dataset.folderId;
                showAddChatsModal(folderId);
            });
        });
    }
    
    function handleFolderItemClick(e) {
        if (e.target.type === 'checkbox') return; // Don't trigger if checkbox was clicked
        const folderId = e.currentTarget.dataset.id;
        // --- REPLACED CONSOLE.LOG WITH ACTUAL NAVIGATION ---
        showManageSingleFolderModal(folderId);
    }

    function handleCheckboxChange(e) {
        const folderId = e.target.dataset.folderId;
        if (e.target.checked) {
            if (!state.selectedItems.includes(folderId)) {
                state.selectedItems.push(folderId);
            }
        } else {
            state.selectedItems = state.selectedItems.filter(id => id !== folderId);
        }
        updateRemoveButtonState();
    }
    
    function updateRemoveButtonState() {
        const removeBtn = shadow.querySelector('#remove-selected-btn');
        if (removeBtn) {
            removeBtn.disabled = state.selectedItems.length === 0;
        }
    }
    

    async function handleManageFoldersLogic() {
        const modalContent = shadow.querySelector('.modal-content');
        if (!modalContent) return;

        // Using event delegation on the modal content
        modalContent.addEventListener('click', (e) => {
            const target = e.target;

            if (target.closest('#close-modal-btn')) {
                closeModal();
            } else if (target.closest('#add-folder-btn')) {
                showAddFolderModal();
            } else if (target.closest('.add-subfolder-btn')) {
                const parentId = target.closest('.add-subfolder-btn').dataset.parentId;
                showAddFolderModal(false, null, parentId);
            } else if (target.closest('.add-chats-btn')) {
                const folderId = target.closest('.add-chats-btn').dataset.folderId;
                showAddChatsModal(folderId);
            } else if (target.closest('.delete-folder-btn')) {
                const folderId = target.closest('.delete-folder-btn').dataset.folderId;
                showConfirmDeleteModal(folderId);
            } else if (target.closest('#remove-selected-btn')) {
                showConfirmDeleteModal();
            } else if (target.closest('.item-title')) {
                const folderId = target.closest('.list-item').dataset.folderId;
                showManageSingleFolderModal(folderId);
            }
        });

        modalContent.addEventListener('change', (e) => {
            if (e.target.classList.contains('folder-checkbox')) {
                handleCheckboxChange(e);
            } else if (e.target.matches('#hide-foldered-toggle')) {
                state.settings.hideFolderedChats = e.target.checked;
                saveData();
                updateChatVisibility();
            }
        });

        const searchInput = shadow.querySelector('#search-folders-input');
        if (searchInput) {
        searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const folderItems = shadow.querySelectorAll('.list-item');
                folderItems.forEach(item => {
                const title = item.querySelector('.item-title').textContent.toLowerCase();
                    item.style.display = title.includes(searchTerm) ? 'flex' : 'none';
            });
        });
        }
        updateRemoveButtonState();
    }


    function handleAddFolderLogic(isEdit = false, folderId = null, parentId = null) {
        const form = shadow.querySelector('#add-folder-form');
        const input = shadow.querySelector('#folder-name-input');
        const saveBtn = shadow.querySelector('#save-folder-btn');
        const cancelBtn = shadow.querySelector('#cancel-folder-btn');

        if (!form || !input || !saveBtn || !cancelBtn) return;

        const handleFormSubmit = (e) => {
            e.preventDefault(); // Prevent default form submission which violates CSP
            e.stopPropagation(); // Stop the event from bubbling up

            const folderName = input.value.trim();
            if (!folderName) return;

            if (isEdit) {
                const folder = state.folders.find(f => f.id === folderId);
                if (folder) {
                    folder.name = folderName;
                }
            } else {
                state.folders.push({
                    id: generateUUID(),
                    name: folderName,
                    chatIds: [],
                    parentId: parentId || null // Use the passed parentId
                });
            }
            saveData();
            closeModal();
            showManageFoldersModal(); // Refresh main modal
        };

        form.addEventListener('submit', handleFormSubmit);
        saveBtn.addEventListener('click', handleFormSubmit);
        cancelBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeModal();
        });
        input.focus();
    }
    

    function handleAddChatsLogic(folderId) {
        const saveBtn = shadow.getElementById('save-add-chats');
        const cancelBtn = shadow.getElementById('cancel-add-chats');

        saveBtn.addEventListener('click', async () => {
            const selectedCheckboxes = shadow.querySelectorAll('.chat-select-checkbox:checked');
            const chatIdsToAdd = Array.from(selectedCheckboxes).map(cb => cb.dataset.chatId);

            if (chatIdsToAdd.length > 0) {
                const folder = state.folders.find(f => f.id === folderId);
                if (folder) {
                    const newChatIds = chatIdsToAdd.filter(id => !folder.chatIds.includes(id));
                    folder.chatIds.push(...newChatIds);
                    await saveData();
                }
            }
            closeModal();
            showManageFoldersModal(); // Re-open the main modal to show updates
        });

        cancelBtn.addEventListener('click', () => {
            closeModal();
            showManageFoldersModal(); // Go back to the main modal
        });
    }

    // --- NEW: Utility to find chats not yet in a folder ---
    async function getUnassignedChats() {
        // This function will find all chats that are not currently in ANY folder.
        const allChatElements = getAllConversationElements();
        const allChatIdsAndTitles = allChatElements.map(el => ({
            id: getChatIdFromElement(el),
            title: el.textContent.trim()
        }));

        const assignedChatIds = new Set();
        state.folders.forEach(folder => {
            folder.chatIds.forEach(chatId => assignedChatIds.add(chatId));
        });

        return allChatIdsAndTitles.filter(chat => chat.id && !assignedChatIds.has(chat.id));
    }

    // --- NEW: Get all chat IDs in a folder and its subfolders ---
    function getAllChatIdsInFolder(folderId) {
        const result = [];
        const folder = state.folders.find(f => f.id === folderId);
        
        if (folder && folder.chatIds) {
            result.push(...folder.chatIds);
        }
        
        // Recursively get chat IDs from subfolders
        const subfolders = state.folders.filter(f => f.parentId === folderId);
        subfolders.forEach(subfolder => {
            result.push(...getAllChatIdsInFolder(subfolder.id));
        });
        
        return result;
    }

    // --- NEW: Remove folders and their descendants from state ---
    function removeFolders(folderIds) {
        const foldersToRemove = new Set(folderIds);
        
        // Recursively add all descendant folders
        function addDescendants(parentId) {
            const children = state.folders.filter(f => f.parentId === parentId);
            children.forEach(child => {
                foldersToRemove.add(child.id);
                addDescendants(child.id);
            });
        }
        
        folderIds.forEach(folderId => {
            addDescendants(folderId);
        });
        
        // Filter out all folders to be removed
        state.folders = state.folders.filter(f => !foldersToRemove.has(f.id));
    }

    // --- NEW: MODAL TRIGGER FUNCTIONS ---

    function showManageFoldersModal() {
        openModal('manage-folders-modal', 'Manage Folders', getManageFoldersModalHTML());
        handleManageFoldersLogic();
    }
    
    function showAddFolderModal(isEdit = false, folderId = null, parentId = null) {
        const folder = isEdit ? state.folders.find(f => f.id === folderId) : null;
        const modalTitle = isEdit ? 'Edit Folder' : (parentId ? 'Add Subfolder' : 'Add Folder');
        openModal(
            'add-folder-modal',
             modalTitle,
             getAddFolderModalHTML(isEdit, folder ? folder.name : ''),
             400
        );
        handleAddFolderLogic(isEdit, folderId, parentId);
    }
    
    // --- NEW: Trigger for the Add Chats Modal ---
    async function showAddChatsModal(folderId) {
        const folder = state.folders.find(f => f.id === folderId);
        if (!folder) return;

        const unassignedChats = await getUnassignedChats();

        openModal(
            'add-chats-modal',
            `Add Chats to "${folder.name}"`,
            getAddChatsModalHTML(folder, unassignedChats),
            500
        );
        handleAddChatsLogic(folderId);
    }
    
    // --- NEW: Trigger for Single Folder View ---
    function showManageSingleFolderModal(folderId) {
        const folder = state.folders.find(f => f.id === folderId);
        if (!folder) return;

        openModal(
            'manage-single-folder-modal',
            `Manage "${folder.name}"`,
            getManageSingleFolderModalHTML(folder),
            500
        );
        handleManageSingleFolderLogic(folderId);
    }

    function showConfirmDeleteModal(folderId) {
        openModal(
            'confirm-delete-modal',
            'Confirm Deletion',
            getConfirmDeleteModalHTML(),
            400
        );

        const confirmBtn = shadow.querySelector('#confirm-delete-btn');
        const cancelBtn = shadow.querySelector('#cancel-delete-btn');

        confirmBtn.addEventListener('click', () => {
            const foldersToDelete = new Set([folderId]);

            // Recursive function to find all children
            function getAllChildFolderIds(parentId) {
                const children = state.folders.filter(f => f.parentId === parentId);
                children.forEach(child => {
                    foldersToDelete.add(child.id);
                    getAllChildFolderIds(child.id);
                });
            }

            // Populate the set with all nested children
            getAllChildFolderIds(folderId);

            // Filter out the folders to be deleted
            state.folders = state.folders.filter(f => !foldersToDelete.has(f.id));
            
            saveData();
            closeModal();
            showManageFoldersModal();
        });

        cancelBtn.addEventListener('click', closeModal);
    }

    function showBulkDeleteModal() {
        openModal(
            'bulk-delete-modal',
            'Bulk Delete',
            getBulkDeleteModalHTML(),
            500
        );
        handleBulkDeleteLogic(); // Attach listeners after modal is created
    }

    // --- NEW: Core Bulk Deletion Logic ---
    async function deleteSingleConversation(conversationItem, abortSignal) {
        try {
            if (abortSignal?.aborted) throw new Error("Operation aborted by user.");

            // Following the original working logic from C/scripts/delete-conversations.js
            // The conversation item is the parent element, we need to find the next sibling
            // that contains the actions menu
            const actionsWrapper = conversationItem.nextElementSibling;
            if (!actionsWrapper) {
                throw new Error("Actions wrapper (sibling to conversation item) not found.");
            }

            // Look for the three-dot menu button in the actions wrapper
            let menuButton = findElement(ACTIONS_MENU_SELECTORS, actionsWrapper);
            if (!menuButton) {
                // Fallback: try to find any button in the wrapper
                menuButton = actionsWrapper.querySelector("button");
            }
            
            if (!menuButton) {
                throw new Error("Three-dot button not found in actions wrapper.");
            }
            
            menuButton.click();
            await delayMs(150); // Wait for menu to open
            if (abortSignal?.aborted) throw new Error("Operation aborted by user.");

            // The menu appears in a global overlay container
            const overlayContainer = findElement(OVERLAY_CONTAINER_SELECTORS);
            if (!overlayContainer) {
                throw new Error("Overlay container for delete menu not found.");
            }

            // Wait for and click the main delete button inside the menu
            const deleteButton = await waitForElement(DELETE_BUTTON_SELECTORS, overlayContainer, 7000);
            if (!deleteButton) {
                throw new Error("Delete button not found in menu");
            }
            deleteButton.click();
            await delayMs(150); // Wait for confirmation dialog
            if (abortSignal?.aborted) throw new Error("Operation aborted by user.");

            // Wait for and click the final confirmation button in the dialog
            const confirmButton = await waitForElement(CONFIRM_BUTTON_SELECTORS, overlayContainer, 7000);
            if (!confirmButton) {
                throw new Error("Confirm button not found in dialog");
            }
            confirmButton.click();

            // Wait for the conversation element to be removed from the DOM
            await waitForElementToDisappear(conversationItem, 15000);

            return { status: 'success' };
        } catch (error) {
            if (error.message.includes("aborted")) {
                console.log("Deletion cancelled by user.");
            } else {
                console.error("Error during single conversation deletion:", error, "on item:", conversationItem);
            }
            // Attempt to close any lingering modals by pressing Escape
            const escapeEvent = new KeyboardEvent('keydown', { key: 'Escape', code: 'Escape', keyCode: 27, bubbles: true, cancelable: true });
            document.body.dispatchEvent(escapeEvent);
            await delayMs(100);
            return { status: 'error', error: error.message };
        }
    }

    // Helper function to wait for element to disappear (similar to original)
    function waitForElementToDisappear(element, timeout = 15000) {
        return new Promise((resolve, reject) => {
            if (!element || !document.body.contains(element)) {
                return resolve();
            }
            
            let elapsedTime = 0;
            const interval = 100;
            const timer = setInterval(() => {
                elapsedTime += interval;
                if (!document.body.contains(element) || element.offsetParent === null) {
                    clearInterval(timer);
                    resolve();
                } else if (elapsedTime >= timeout) {
                    clearInterval(timer);
                    console.error("Element did not disappear within timeout:", element);
                    reject(new Error("Element did not disappear within timeout."));
                }
            }, interval);
        });
    }


    function updateChatVisibility() {
        const allChatElements = getAllConversationElements();
        const assignedChatIds = new Set();
        
        if (state.settings.hideFolderedChats) {
            state.folders.forEach(folder => {
                folder.chatIds.forEach(chatId => assignedChatIds.add(chatId));
            });
        }

        allChatElements.forEach(el => {
            const chatId = getChatIdFromElement(el);
            if (chatId && assignedChatIds.has(chatId)) {
                el.style.display = 'none';
            } else {
                el.style.display = '';
            }
        });
    }

    function getManageSingleFolderModalHTML(folder) {
        const chatListHTML = folder.chatIds.map(chatId => {
            const chatElement = getAllConversationElements().find(el => getChatIdFromElement(el) === chatId);
            const title = chatElement ? chatElement.textContent.trim() : 'Chat not found';
            return `
                <div class="list-item chat-item" data-chat-id="${chatId}">
                    <span class="item-title">${title}</span>
                    <button class="icon-btn remove-from-folder-btn" data-chat-id="${chatId}" title="Remove from folder">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x-circle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                    </button>
                </div>
            `;
        }).join('');

        return `
            <div class="modal-header">
                <button class="icon-btn" id="back-to-folders-btn">&larr; Back</button>
                <h2>${folder.name}</h2>
                <button class="icon-btn" id="close-modal-btn">&times;</button>
                </div>
            <div class="modal-body">
                ${chatListHTML || '<p>No chats in this folder yet.</p>'}
            </div>
        `;
    }


    function handleManageSingleFolderLogic(folderId) {
        const modalContent = shadow.querySelector('.modal-content');
        if (!modalContent) return;

        modalContent.addEventListener('click', (e) => {
            if (e.target.closest('#back-to-folders-btn')) {
                closeModal();
                showManageFoldersModal();
            } else if (e.target.closest('#close-modal-btn')) {
                closeModal();
            } else if (e.target.closest('.remove-from-folder-btn')) {
                const chatId = e.target.closest('.remove-from-folder-btn').dataset.chatId;
                const folder = state.folders.find(f => f.id === folderId);
                if (folder) {
                    folder.chatIds = folder.chatIds.filter(id => id !== chatId);
                    saveData();
                    updateChatVisibility(); // Update visibility after removing
                    // Refresh the modal
                    closeModal();
                    showManageSingleFolderModal(folderId);
                }
            } else if (e.target.closest('.chat-item')) {
                const chatId = e.target.closest('.chat-item').dataset.chatId;
                const chatElement = getAllConversationElements().find(el => getChatIdFromElement(el) === chatId);
                if (chatElement) {
                    chatElement.click();
                    closeModal();
                } else {
                    alert('Could not find the chat element to click.');
                }
            }
        });
    }

    // --- NEW: Bulk Delete Modal Event Handling ---
    function handleBulkDeleteLogic() {
        const modal = shadow.getElementById('bulk-delete-modal');
        if (!modal) return;

        const selectAllCheckbox = modal.querySelector('#bulk-delete-select-all');
        const allCheckboxes = modal.querySelectorAll('.bulk-delete-checkbox');
        const startButton = modal.querySelector('#start-bulk-delete-btn');
        const statusEl = modal.querySelector('#bulk-delete-status');

        if (!selectAllCheckbox || !startButton || !statusEl) {
            console.error("Bulk delete modal elements not found.");
            return;
        }

        // --- Event Listener for "Select All" ---
        selectAllCheckbox.addEventListener('change', () => {
            allCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
        });

        // --- Event Listener for "Start Bulk Delete" button ---
        startButton.addEventListener('click', async () => {
            const selectedCheckboxes = Array.from(allCheckboxes).filter(cb => cb.checked);
            
            if (selectedCheckboxes.length === 0) {
                statusEl.textContent = "No items selected.";
                return;
            }

            // --- NEW: Gather selections and create master chat ID list ---
            const selectedChatIds = [];
            const selectedFolderIds = [];
            
            selectedCheckboxes.forEach(checkbox => {
                if (checkbox.dataset.type === 'folder') {
                    selectedFolderIds.push(checkbox.dataset.id);
                } else if (checkbox.dataset.type === 'chat') {
                    selectedChatIds.push(checkbox.dataset.chatId);
                }
            });

            // Create master set of all chat IDs to delete
            const allChatIdsToDelete = new Set(selectedChatIds);
            
            // Add all chat IDs from selected folders and their subfolders
            selectedFolderIds.forEach(folderId => {
                const chatIds = getAllChatIdsInFolder(folderId);
                chatIds.forEach(chatId => allChatIdsToDelete.add(chatId));
            });

            const totalToDelete = allChatIdsToDelete.size;
            
            if (totalToDelete === 0) {
                statusEl.textContent = "No chats to delete.";
                return;
            }

            // --- NEW: Ensure all chats are visible before deletion ---
            const allConversations = getAllConversationElements();
            allChatIdsToDelete.forEach(chatId => {
                const chatElement = allConversations.find(el => getChatIdFromElement(el) === chatId);
                if (chatElement && chatElement.style.display === 'none') {
                    chatElement.style.display = '';
                }
            });

            // --- Set up and show the full-screen overlay ---
            closeModal(); // Close the small modal first
            createBulkDeleteOverlayStyles();
            const overlayWrapper = document.createElement('div');
            overlayWrapper.innerHTML = getBulkDeleteOverlayHTML();
            shadow.appendChild(overlayWrapper);
            
            const overlay = shadow.getElementById('gemini-delete-all-overlay');
            const overlayMessage = overlay.querySelector('.message');
            const progressStatus = overlay.querySelector('#progress-status');
            const progressCounter = overlay.querySelector('#progress-counter');
            const progressBarInner = overlay.querySelector('.progress-bar-inner');
            const cancelButton = overlay.querySelector('.cancel-button');
            const spinner = overlay.querySelector('.spinner');
            const completionTick = overlay.querySelector('.completion-tick');
            
            let wasCancelled = false;
            const cancellationController = new AbortController();

            cancelButton.addEventListener('click', () => {
                wasCancelled = true;
                cancellationController.abort();
                overlayMessage.textContent = 'Cancelling...';
            });

            // --- Execute deletion loop ---
            let deletedCount = 0;
            let errorCount = 0;
            const chatIdsArray = Array.from(allChatIdsToDelete);

            for (let i = 0; i < chatIdsArray.length; i++) {
                if (wasCancelled) break;

                const chatId = chatIdsArray[i];

                // Update overlay progress
                progressStatus.textContent = `Deleting chat ${i + 1} of ${totalToDelete}...`;
                progressCounter.textContent = `${i} / ${totalToDelete}`;
                progressBarInner.style.width = `${(i / totalToDelete) * 100}%`;
                
                const conversationElement = allConversations.find(el => getChatIdFromElement(el) === chatId);

                if (conversationElement) {
                    const result = await deleteSingleConversation(conversationElement, cancellationController.signal);
                    if (result.status === 'success') {
                        deletedCount++;
                    } else {
                        errorCount++;
                    }
                } else {
                    console.warn(`Could not find conversation element for chat ID: ${chatId}`);
                    errorCount++;
                }

                await delayMs(250);
            }

            // --- Remove selected folders from state ---
            if (selectedFolderIds.length > 0) {
                removeFolders(selectedFolderIds);
                await saveData();
            }
            
            // --- Finalize and hide overlay ---
            spinner.style.display = 'none';
            completionTick.style.display = 'block';
            progressBarInner.style.width = '100%';
            progressCounter.textContent = `${deletedCount} / ${totalToDelete}`;

            if (wasCancelled) {
                overlayMessage.textContent = 'Deletion cancelled.';
            } else if (errorCount > 0) {
                overlayMessage.textContent = `Finished. Deleted ${deletedCount}, failed ${errorCount}.`;
            } else {
                overlayMessage.textContent = 'All selected items deleted!';
            }
            
            setTimeout(() => {
                overlay.classList.add('hidden');
                overlay.addEventListener('transitionend', () => {
                    overlay.remove();
                }, { once: true });
            }, 3000);
        });
    }

    // --- NEW: Full-screen Loading Overlay Logic (from extension C) ---
    
    function getBulkDeleteOverlayHTML() {
        return `
            <div id="gemini-delete-all-overlay" class="visible">
                <div class="spinner"></div>
                <svg class="completion-tick" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
                    <circle class="tick-circle" cx="26" cy="26" r="25" fill="none"/>
                    <path class="tick-path" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
                </svg>
                <div class="message">Deleting...</div>
                <div class="progress-container">
                    <div class="progress-text">
                        <span id="progress-status">Starting...</span>
                        <span id="progress-counter">0 / 0</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-bar-inner"></div>
                    </div>
                </div>
                <button class="cancel-button">Cancel</button>
            </div>
        `;
    }

    function createBulkDeleteOverlayStyles() {
        if (shadow.getElementById("gemini-delete-all-overlay-styles")) return;

        const theme = {
            isDark: document.body.classList.contains('dark-theme'),
            // Simplified theme colors, can be expanded if needed
            backgroundColor: 'var(--gf-bg-primary)',
            textColor: 'var(--gf-text-primary)',
            secondaryTextColor: 'var(--gf-text-secondary)',
            accentColor: 'var(--gf-accent-primary)',
            progressTrackColor: 'rgba(128, 128, 128, 0.2)',
            successColor: '#34a853', // Standard green
        };

        const css = `
          #gemini-delete-all-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: var(--gf-bg-primary);
            z-index: 2147483647; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            font-family: 'Google Sans', Roboto, Arial, sans-serif; color: ${theme.textColor}; text-align: center;
            opacity: 1; transition: opacity 0.3s ease-in-out;
          }
          #gemini-delete-all-overlay.hidden { opacity: 0; pointer-events: none; }
          #gemini-delete-all-overlay .spinner {
            display: block;
            border: 3px solid ${theme.progressTrackColor}; border-top: 3px solid ${theme.accentColor};
            border-radius: 50%; width: 50px; height: 50px;
            animation: spin 0.8s linear infinite; margin-bottom: 25px;
          }
          @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
          
          #gemini-delete-all-overlay .completion-tick {
            display: none; width: 60px; height: 60px;
            border-radius: 50%;
            stroke-width: 5; stroke: ${theme.successColor};
            stroke-miterlimit: 10;
            animation: draw-tick-container 0.5s ease-out forwards;
            margin-bottom: 20px;
          }
          #gemini-delete-all-overlay .completion-tick .tick-path {
            stroke-dasharray: 100;
            stroke-dashoffset: 100;
            animation: draw-tick-path 0.5s 0.2s ease-out forwards;
          }
          @keyframes draw-tick-container {
            0% { opacity: 0; transform: scale(0.5); }
            100% { opacity: 1; transform: scale(1); }
          }
          @keyframes draw-tick-path {
            to { stroke-dashoffset: 0; }
          }
          #gemini-delete-all-overlay .message { font-size: 20px; font-weight: 500; margin-bottom: 8px; }
          
          #gemini-delete-all-overlay .progress-container {
            display: flex; flex-direction: column; align-items: center;
            width: 300px; margin: 10px 0;
          }
          #gemini-delete-all-overlay .progress-text { 
            font-size: 14px; color: ${theme.secondaryTextColor}; 
            margin-bottom: 8px; width: 100%;
            display: flex; justify-content: space-between;
          }
          
          #gemini-delete-all-overlay .progress-bar {
            width: 100%; height: 4px; background-color: ${theme.progressTrackColor};
            border-radius: 4px; overflow: hidden;
          }
          #gemini-delete-all-overlay .progress-bar-inner {
            height: 100%; width: 0%;
            background-color: ${theme.accentColor};
            transition: width 0.25s ease-out;
            border-radius: 4px;
          }
          
          #gemini-delete-all-overlay .cancel-button {
            margin-top: 16px; color: ${theme.secondaryTextColor};
            font-size: 14px; background: none; border: 1px solid ${theme.secondaryTextColor};
            padding: 8px 16px; cursor: pointer;
            font-family: 'Google Sans', Roboto, Arial, sans-serif;
            border-radius: 4px; transition: background-color 0.15s;
          }
          #gemini-delete-all-overlay .cancel-button:hover {
            background-color: rgba(128, 128, 128, 0.2);
          }
        `;
        const styleEl = document.createElement("style");
        styleEl.id = "gemini-delete-all-overlay-styles";
        styleEl.textContent = css;
        shadow.appendChild(styleEl);
    }

    // --- REFACTORED: INITIALIZATION ---

    async function init() {
        if (document.getElementById(INJECTOR_HOST_ID)) return;
        await delay(500);

        // Find a more stable insertion point, like the recent conversations list container.
        const recentConversationsList = document.querySelector('conversations-list');
        if (recentConversationsList && !document.getElementById(INJECTOR_HOST_ID)) {
            hostElement = document.createElement('div');
            hostElement.id = INJECTOR_HOST_ID;
            shadow = hostElement.attachShadow({ mode: 'open' });
            
            createGlobalStyles();
            
            // Inject the main "Folders" tab
            const sidebarTabHTML = getSidebarTabHTML();
            shadow.innerHTML += sidebarTabHTML;
            
            // Prepend our UI host to the conversation list
            recentConversationsList.prepend(hostElement);
            
            // Add event listeners for the new dropdown functionality
            const toolboxBtn = shadow.getElementById('gemini-toolbox-btn');
            const toolboxDropdown = shadow.getElementById('gemini-toolbox-dropdown');
            const manageFoldersLink = shadow.getElementById('manage-folders-link');
            const bulkDeleteLink = shadow.getElementById('bulk-delete-link');
            const dropdownArrow = shadow.querySelector('.dropdown-arrow');
            
            // Toggle dropdown on toolbox button click
            toolboxBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isVisible = toolboxDropdown.style.display !== 'none';
                toolboxDropdown.style.display = isVisible ? 'none' : 'block';
                dropdownArrow.classList.toggle('rotated', !isVisible);
            });
            
            // Handle manage folders link click
            manageFoldersLink.addEventListener('click', (e) => {
                e.stopPropagation();
                showManageFoldersModal();
                toolboxDropdown.style.display = 'none';
                dropdownArrow.classList.remove('rotated');
            });

            // Handle bulk delete link click
            bulkDeleteLink.addEventListener('click', (e) => {
                e.stopPropagation();
                showBulkDeleteModal();
                toolboxDropdown.style.display = 'none';
                dropdownArrow.classList.remove('rotated');
            });

            // Implement click outside to close functionality
            document.addEventListener('click', (e) => {
                const toolboxContainer = shadow.getElementById('gemini-toolbox-container');
                if (toolboxContainer && !toolboxContainer.contains(e.target)) {
                    toolboxDropdown.style.display = 'none';
                    dropdownArrow.classList.remove('rotated');
                }
            });

            await loadData();
        }
    }

    const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            if (mutation.type === 'childList') {
                if (document.querySelector('conversations-list') && !document.getElementById(INJECTOR_HOST_ID)) {
                    init();
                    // No need to break; let it run to catch theme changes etc.
                }
                 // Add theme change observation
                const newTheme = detectTheme();
                if (newTheme !== currentTheme) {
                    applyThemeStyles();
                }
            }
        }
    });

    observer.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] });
    
    // Initial check
    init();

})(); 

====================================================================
FILE: D/D/background.js
====================================================================


====================================================================
FILE: D/D/icons/icon16.png
====================================================================
âPNG

   IHDR         Ûˇa  µIDATx⁄•”ªjîa‡g˛≥+Iƒ¬Ä`lDPl≠º≠ºçÑêÉÖ¨Ab0*≈Nº	Ø¿.µ)cësv˜ã›òlíFú‚„;Ãº3Ô;ﬂOñq¸&"ΩÃ•Àˆ§J($(Ïöéo†ôÖπ®é dH,Vyo¿Ì^`•U[›≠¢.‹62CDvyIx`6¶OT>üwEgÑÚºR”∂-O§à¨!SIa)vL(]«Ñ©¯©tŒ@⁄FU>õã[d°∑Ù€∫é¬YïÜM˚ÊÛæY/Tæ+:ÀT;ö9“’!„$¿\¥myl∆òAwy„πõ¶‚£©⁄2≈™Aı˜‚XO∫‚≤ËµaÔ¥ÖöØr“R6Ñ3Z=ø ŸkÎ∂Pxj”¢öR«∏∫∑∆û<Ü⁄	
KŸ∞ÎÉ ¶m˜T6<äï√OTıÂ≠ù"bÀ†/µ¨yf,K∞¢s‹ΩvåB∫&å«'∞ú•5Ö´=∫ÕånßdØÆÒ8Ãrt`Ÿß]≠+[Ü¬/ïQØÚπ˝*•EˆU◊Phπ†Âw˜ü6LÖ+ˆ•é˛…+•∫êVM∆˙ﬂòˇµ?Îç¶¡W•‡    IENDÆB`Ç

====================================================================
FILE: D/D/icons/icon38.png
====================================================================
âPNG

   IHDR   &   &   ®=ÈÆ  ËIDATx⁄ÌòKlTU«ﬂπw¶•- ¶EÖ¿5]`¢ƒƒÂaàƒÑïÌ5ëhÏ¬ƒ∆ ÀLGÎtl1J"F@bÇ—÷Öí®ƒ BLêF|`b> â“B€i{ß˜ûœ≈‹ôÇPfngt≈óúd29˜ú˛ﬂÎˇ∏n—LäÓËUá„%Ïõ⁄,I±ïÖ≠*9'°¶rå©
"JZ∆ÿÂ¯∆†jØ¸Få˛£`¡ã\dƒyü§¸LØ:¥JP∞¸!]˛”‹ËÏ %9~“På⁄!FÕ*“OB]í‚ó˙˘ïvq?KÜ£å0eJ·Ω0≥˚“58tJ>måíEç°éº®KHäOB›È3ñwcóûé≤Q÷Fé´îˇ81g7„,ßÜ˜0ÃÊ|ˆ~:´~(Öπ"Ai!é™∞Cc®
	5¥®√Î⁄@Ø:® e+øœ"∏|~bà@ÜŸÒÉ$ÙÆRò3E=≠(" ôº{1ÙI@∆n·w‚ÙaË «0¿wÄà‚ JåZíÚX
å–¿^“≈!83M`ˇvº(IÒIeÔ•ﬁ¥„Û≠Íîà“D.Û‘Q‚p	≠„,ø2Ã¿£é}º:~;ËT‡¢KÈ"∂j7±ÿL`0ºÀ÷‡∫ÙnP!≠Û®ûÓÓ«≥µÙSÕ àqàq©°[µ9d˘™‹àU/>(„®9áÕzÇuL‘ˇàÍ^DN“©À0ˆ1å©√XÃ8√<Ñp '
!R∞çr
xôîÓ£é√dxíç“wI:Øª q>aá∆hì#¿ë+ŒÈ“œ¡6\Î*7rãÍ¿aì|KJ∑˚Û3∂iÌ‚ë“UT≥à	”Dóv–&ßÿ¶U0YÌg·0@Ä⁄xÆCL;+ß˛Ñf–…H£Gªx§ıV‚Ïƒ«‚Pè√ZCªxú@iFI–ÑOR|+ïc,oπ,º @èÆFÏvåôOTsÜÉtk;œÀ7ú}	IzÌ+"SAÅW2çT◊ÆCi≈∞kAÂ<0F@å%8¶Gø> Àn` J´çn¶6ã˛BÌ väFó+∞C('±¸ÜC6äå»òhx‡y`∞ã]Å∞ã8C÷îj&¯òÄÁ¬LûT-%ZÙ¨Ï√770ƒ=åÒÎÂ i} óØqôáÉÉ«Gº -°HtiF£h±Èee´±á◊

aÉ¸Å«∏≤úEy
U°Wí‚Gù±nmƒa5ñNbÃ•[?ﬁ √16À!“zÿœπ»Xi£ïb¨EòˆQ\Êíµäa5¬2™© i∏‡-îΩ·¨`ÀÉJgl?Üù“<HZ”ƒÕ3år'[‰tÆ]=g˜P›ËáÕYÀô_J÷ÑÜ£ú‚≤ù—`ê-Ói')πR∞æ)S©-ZåÂÉ∏Eœ∞‘yÉÑö®|FÙˇñ∑>	Ë#∏jù´ê~ù™Ÿñ9óôïäê2Êr˘–°a¡ç≤Êêf¬SÀq•A…ÜY6A[ŸÚC°ò[XG(ú±1Ó °7„1Añ¡iBö	å!ƒ©¬e!æ…ïô†ØT`Õ‰ﬂ!ﬁ§é∑ÅsÃ(®–íb‰™uFxc0‚o*ÔQ%•kpÌJ„Xô¶Pö||â··Ò)õÂÀ¬”H·ø≤"O\nQ˝U˛√›}7∫‚∏n◊≤ r5=¶¬    IENDÆB`Ç

====================================================================
FILE: D/D/icons/icon48.png
====================================================================
âPNG

   IHDR   0   0   W˘á  ≤IDATx⁄Ìôkà\g«œ{ŒÏÏÃl∂Mã¥M)§≠f)xkS
Jj>ıFE›µòÖVRmmäÑö¨›tÊl6ô$€(m@ÀjD±Xôÿ|∞î5IQPÒR?‘bb.Ñ“€lvfÁÃºÔ„ásv≤≥õtÁÛ!sòyÁúÁˆˇ?óÅ´rU⁄i¯§™∞√Tøyq‚.èôY5WÍ}¶
àí=”œ≤Î◊≤kA[àÑ†‡z©0[˙[”ˇ°†Cbªc@V vn#·^£ﬂ¨¢]üUÅ∞º«¨˝*œ˙?#´>ÅT[πùˇæﬂE@∆ÓaôY≈y¯ä N£Cp‡‚À(ªÁ]õ¯⁄0e5	>É«5ÙzØ∞≠*lïWÿ†	&§“¡Ã•éRíî∏°m‡Ì–ıÙÛ2Á‹ÒÕù¯@ëáë˝≠·7∆@∏9£†>ßV†ug–% ™®MìÙ }ëêiˆ°¸î—äÂ99–j$.Åy=Eﬁûº¿*ãŒ‘[¸yû"gÂıQ&TŸÆO0VÊEUˆhô— Á ÿ†âFµlíF	x}N˘q“≥èÅ(™≤ìçåÒÛúc=ÙêÒåUbB*5É;g¿EœjàÜ7„{#<•IrHÙ9CTÍårVÒäREUë]L€MÙ˙˚”˚	§⁄HùhŒÄ:ˇãHe∑?FÊCåàã(Q¥vN‰¬/çgqp7€ä7ë„&∂ïnFã?°Ë^¬«£óü≥SÔ"@TØ}ÍÂ‡feÕêÁY	ˆ^T¡7wbI‡Quøƒ”ó){áxVﬁaª~ √2∂o v≥
aä4	Œ/–ƒQ¬ê"yù-Ú¿RÖÆı*áÀ1ﬁà˘$.6J cnGº€p≥}†Ç«ßAÄ	6À[Ñ<Dôﬂ#Ó8 Iîì8NÅ{ÎéS¡70àküFYê:¢…#¿cÏ÷¿$}‹BâIf¯<ÅÃŒã‰gÅu Y–(ÁE&ÅI
⁄√oﬂä≤‡∫Ñp∂¢dnIs'¿yù´ój3Æ#¡”råù˙,òaÅÃÚÇ&YAï)¿É$YI^?Œ0G¿0®P¿!1ÜÍÔ+ı•º[,à„i¬ò)~Gâ	âj≈Yî!±$˘:Ω¨DQƒçÉ(o`bÂ5¬Y¸ ™Œ„Åu“e≠1ë£ƒ4	
ÍÒA<	Ÿ°kËaîKà%e÷±S∑÷™lV˝à’DAî—{
ƒhwShæ‰PDŒ‘*‘∏>à# ÖãÛaK/£Ï÷9û#êê îÊ”l:çE†3à(Éè5ÉkÄß∆EùGYc#RlF∏èq}Åê_ ÚN;ènœ U!áêf=∆}ã4°
ÃP<§ÆŒ‡1CÖ$∑”«ò&d‹˛ò≤	»q˙B©å[ÙŒb¿…¢NH$Íèä”ìX∑ë"/QÊ)¸ãj†XR$pTyè z0€©vÑÅÆF¿\bà%‡p8ÃÛ˙™|õ4˜S¬∆ë á%ÖGË˛Ñ3Ÿ"o÷„H•˚)§ö’(IvW†iüÂúÊq˘' ªÏwIõØQƒ‚ Rû◊9aæ¿^)GÌw\iÅ∏Òô©9]Ë£çD›®&øˆÀ<.ˆhäÇzlˆû†ƒ!íx$ Ó__bØî…™œêXÜƒ^îÅ.à#ez0<	§Ÿtz/õd¶÷
OP·oÙê"4õÿ,3⁄ÌR Ø◊”S˝ 0Ü[∏·∆CåWvp~ˆœ¿Yæ)«»ÎAJ‹…0ØQV”–ˆA7¢Öä¡f¯bÚd∏á*é
ñwc¸©æ;8J4ù Ó’8ULß’j£ïÉ¿AvÈ£x|0˘
œ»æ elÊW¯˛ëÊ–È.e’0Ä0$?$oÔìaXˆQPè)â◊/#ôS¿©ZÿaiƒÅ8
Í≈#ﬂ˜ÄYçñø¡¸	J£ÿ&€t∆Ä\Æ^s£ﬁÍ_ˇ÷Œyÿ-NπÓÌù;”Ã˜T˘?IsΩ–®ñ·äîÆ¥ét?
ÁõCåﬂî[VO)ŸπÂÆvñU&≤™Ù„ç6øaÂ»˘µm\∑dßfÒ±∆µiÄDkΩ@,y˚W˙Õ}Xí◊ø£NP:ÅπÈM˘˝Ùrñ7„y€#˙_ßÖ¨&Z}8ûaöè≤úµx¨≠AGtè“|7y±•5ÔÚ£Ò»ÍZ‹ç.⁄ë^K¶∫'◊RÅy„zgDQÄË€úÙ≥W µg∑-›˙õu©ÖA3÷RØÎä†·:„˘´rUñîˇl”yMê(    IENDÆB`Ç

====================================================================
FILE: D/D/icons/icon128.png
====================================================================
âPNG

   IHDR   Ä   Ä   √>aÀ  &IDATx⁄Ìùyê$uï«?ÔóôU’›√° ^J∏^† ‚±¬F†`(^ÿÕe¢B¿*Óà3√Q]8”s!∏*¨Î≤∫Évã«ÍzÖ∑¨≤éä·2ËÆ°ã®ã¿tWWWe˛ﬁ˛ëø¨ :˙Ó û.ÎELLWU÷Ø2Ô˚{◊ÔΩ˜É>ı©O}ÍSü˙‘ß>ı©O}ÍSü˙‘ß>ı©O}ÍSü˙‘À$´˙Î™íŸSjáß÷%Œà&◊âˆ!¥X*™°®~o<å
Eı)™ÈKÄÖ–∏zåHT}ÂÉá»£?ø>ƒΩˇpÀ˜jè¡¡–j;û¯ßê›èŸ?Î≥ı–≤Rp"sÎÃÒ‰ÃXs2÷<±ë‘≈j¬f≠´ôE\/D‹7}ñsa˜b¥M]O1∂ä·wﬂb*¸gJ˘ªQïµ¶$ÊJ(€ÌvﬁIŒxÑ@¥ ¶±àkñyu¸<„{ÄT©Ÿ›\È]MQ£(≤6@–}]<éaÀò›√¡Êl&±L"7ŸÇ∏)U +çUáÄçW°ZC˝⁄Ùw”c¥33ë"Òı±S„’«±∂w∫.="£Ã`÷ô´ÿQ;öMº>˛5e-Ä†ª HÙ‚u·fˆŒf?U @Q"§e•	Ä—f÷ôfÜ4ØFm˙øy˝∆ˇ«nCZELªcõÓ≤Æîn|É¢Ïß∆:ˇ\vXaìw.®Y Ë äjëà‚‘ë‰‰ D(Aù%xêRi∑L)¢Á˚ûvpˇÊ¥Ê¯Ì0^¸-¿ `äCÊ∂◊`≥¨	tS¿ö xù4î	›D)yÑ
ˇFƒ«∞·ÉT—xfór˚a˚K?≈,ﬂá0ú„{È/Ö…ù∆◊˙€6æ%wQ`=UlC<’ˇò§∆:ˇvDñMÚ˙]∑‘Nƒ÷ıgƒ 3ˆV6y¨I«yLˇàg9$≥h$Å9è±(bãú É†õ ∞1œÌ®ë∫T®¢ÑÊzTÖQÓ!bx0˛œÖÂNÖƒ àò¢∆O)|*D^]dﬁ¿ˆHŸ,p¨z†ˆ@s3à»•ÇdBƒ4’ÚC»êR‘ê	±L¨ UπX,cë6=ì!OçÛ®ÿkXgﬁ»$5 h®s>cQçyKlX Ë~”¶\+ƒ*¡‡⁄ç°€6„“Ggrlˆ.d“N0D ‘úzH$¡õŸ›ÃàDåcÅ±ø $Æï¶&≠Ã⁄%”‚Y®˘Xín6g3i?≈JÕ]É`–\¬òæ˜@Å…l…=B¶Âyò±.Ë%‹eŒf“ﬁﬁ&	¶®±é∑±-∫Ò@AvªXiﬂ=,Ø]8X€˛^‰ûl¬8ñªn?´MÅ†L»¡ÊÔãn8P@ê “è9∞¬ß’‹^÷q7ä0>É†L3ü)jd6∞=zw(√[Md  £mìµF‡∞z ﬁßöBtÅÉü˝å)x)î§ÇMú≈T &HÉ`ùycµÎ)I∏ö »¬ê+e˘t*QdO±FNœ‘hﬁ∂n®ÄN ®ò≥ò≤üMÅ 	á¨Û/gLw≠&≤P⁄¶ ÂbÖ(pòPTCI¬ÃfL“ ﬂÔ£(3Ã4ükÒ< ‘8à+ÿÌ\-dkÆÿX*îƒ≤Ìë« ú@¿„¨=Ua<VƒÛ4@Ò+Üô≤_JÅ@RÍ`#c—∂’ ÅYùü\ﬁê£n'ë¡◊í7«"Ÿ{" >≤K4]|àêﬂˇÍ5LÛÂ&uÉ dùŸ¬ˆh¥ÇûıÀqU8Â¢Ÿ@ÑR≈bÃyı(Fâ∫ö§©- ix#˜Là[Ω©NZﬁ˜‘*˜ˇÔkôÊk…©Gôê!Sd[xuÇl<õ"Å∂%`°∂d/@(0"O>~ÉÊÈ‘∞XîCÿ˜ª7C±h∫‰¥W1 ¯MI,√√8ª$ıœ≈˝KÔâﬁx‘4eŒ†bøŒPºŸÏFçApê˜.∂U/ß$a‚È¨m §ì1t´~\=ä*î§ v&Ôç∫›7É‡1Mƒ†9É]˙.JR*YäÍ/8	TUÊπ6û+1H∂BÑ‚±ïmïc‚M≠9∆Q˜(…øºˇïT¯:9∞NxTÆgGıELH‘mt_Ã4•a-"®*L∏Iëàó;¥3|;>7`≈–H“Ú(1¿’Ïå£l6RíIJƒ©i˚‹DóƒŒŒúIÄb8œ˝m®9ûÉÊ¬Òˆ^ûÉÖ®ëEú7…÷– ‘∞6Gh“ÈfBÑ Í]èÍÛE◊6 í§ ¥4†‚âãô^|`Ö√^Ü/o'g^H≈Â˘µßÇ&í‡ß≤3|°w;#Ú¿úëƒíX∆Ù˘PÉ-πÔ◊ﬂkè  |äi∆0‰P,CÕ%ÜÃ”RŸàsK<q#Ü-N≤`ò¡‚õÁ±£z<•¸]≥‹œ@Z‘≥<ø»øégêè÷ÉºÃ©‰y

L9q‹û,SD‰x*9Ô&f∏ñù—∑˝UªóﬂwÒ!¬‘ûº,∆ûáı ¿˜ÎÔµZÛqíÎ}ºKGy4;Ÿ_˜È„ƒ–⁄"Wkúç,û""á1ëw¢Öª:ﬁœZÄàQmÕÂ&b“DØ∆ìK0G"¿$`ÎY≈“—∂–∫Ìm®R#"`à«¢fÑiNFdÇß3îID≈Å ôÿ1&ÆI∫gFéH‰@∞ã1=íÉxUp¿.ZXKK®Lú˚Áû√Fˆ±›Êèü≈¬o{‡¡yE?\Õv`ª´Î±ﬁ∆úÀ O†X¨K«&]Q‡§B¸Ÿ ”‹Kô=ü·
~^|›ïi∞â•®á¢LS‘AJRéçπv¡àƒnÊπå±.rr%Åy:~ú6∫däÄ2ßlw—tÅ ≠õØ»Ìˆ2¶;–Ë≠o3Ü<°ctCîÇbÒ1(”ÃP>¿“®ﬂVèâT˝ﬁ‘Ñœ'ÔaÇ$‡Æ†%ö5∏É‡£ı_®ùH5x6:€‚Yµ£¥◊7‘*∆;öúySìQ£Ω M4˜A%±ı≤20lëˇJl≠~ÖBiÔDØI1_Ä?ÒJ6…ùH±Ø]BõòÒ˛=¢¯˙
åªø»º¯∆º≈ÜMPÓpˇñN≈ÍzÃõ∞Œø©–Ω&‘≤pcIî±ûV>Ñœ≈r'€fNßêªè!JBƒTÌLäπ;)jéµŸ7àT(I»@y%a2ÌÊUÔ›HâôY’@Z†¬0&ﬁù\=èâ9¥5f⁄±jÕ†©l	{±mP£xwé´Ú?eõn`q^Å•Äœ~ªÉbÓª1Û•:˜ä√£§ááß1ËÈ∆ÅGaè<‰s’ß4_≈ä(,Ω,|\ï∑Kƒ6ç:ôMΩ≥†©G[Œ^PÈYU∆’„*πÖi~HÉGô®ö]Æ:∑6Ô8˜∏0≠Á_“!xıéﬂø˚Ü¨eëﬁ*ÿñüúËg√çêCP{+%y0ÛFı∆’cÀ÷ÍzN•Çı è
ñúy1€kß‘ı|6úhNú—^Ä1+ü<ÍDÓ_`∆˛â®Ö{@eVæìËˆÇÎú◊`õ2<≥#”•∂X “+ hˆ“W*∫§å´Øxs5{?QÓø¿¥[˙ùVˇàDl’óQ‡enC…OŸ)"ÕÛÿ^Ï¸˛Ó€J~áëtﬂ»`7∞K±èdÔ˝€ˇ˚Ê÷ü7∂∞•¯ßÉ…Ÿõùœ›~b„x|ﬁ€Õuïßf≤56±_≥≤@≤®“vù∂9Å£DŒE˚
joôﬂh”8ûPÀ‡a¶`û‹T‚›¥ycímﬁÉ(‰?¡‡¥´â&~8K¯tÕªÅ6˛,t/`qn!líü?kè:Ò^ÖQ<J≤CK2Bô”·˘Í*VC<ó«€=lÙ^„⁄¬umgn÷≈”n`ˇW∞8pæDéDtó$dg∏ÖÆeöê$õ_Á∞[ƒeÈòWsΩ~í∑˝"Á¬¿+øpLa•-• ¶}íÀÉ+∏J§sG.uM'$bd_¿nΩôo",©n?-¶Wk +N⁄Ã3¬ìûÚUäzîÀŸ3+jÿpU
C≤M…Çb=m	Åê≠’ıºõ»s"e∑Ú”¨ÓîSêNË–
Ê≈d¿ŒpW mıﬂ;aÑï™˚◊Æ–ô@åv]®%Èc˚Pßü-[ıâÏîÀL‡òÔ∑à¯v h◊5¡4Åy,yˆ∞;:ü(⁄ &π#>ü{P&ñ ìjh'ŸŸ ŸÅ⁄í6∏Ç+˝Xëà$}lá>ü7¢\HﬁFò¡Ç€+l◊Ûs[›ö∫R®°Ñ(sbNcwÙU0‰˛˚øBI¶ö‚ √ÿÂ⁄PHLÕŒË> ¢Î%J√íï∞[è@x	p K»ì£L’EæibxgÅ;ßKIÑ8\î§¶òó/Âà#Óeó~j∑3Ïu€ƒKaE£î.Í`ZV€J–n¢Z=„=œ;k_B¡@(¢xıü.ö·ÅDº¬c Å9ö®‚gÏäæé⁄ØÖw3S¯ıºÆc∏j&˙¢¢T≈/OØß‡ÇÉΩ[9îsÃ·LSeö™ÀˆÎ´VWXòJ BçÂ∏„!Îx&áò∑‚˘∑!π+x¡"öTß6Ö∫œûlÛÃKî%±î ÑoS‘ı¿ÒLr&b_«Äy2JúWßN<KΩô[ªïø]ölÉx/a¿µè´Ò{ˆÛUl¯Yø√fÔœ ºo¡ú–,£xMf‘Jô˝BI*¿ù¿ù(·qñ1ˆtÚ∆c⁄ARÌdÖÄ¨.K…√#èOÖ25æÑo√˙_cì<‹‰°,®Ë§…Ii4§^˚¿¥KÅewmJ≈*…$p;p;€ı9`/√ò◊‡S!B1m˚Ìs3x.	Á!‡QÂèT¯aÂüÿ2À%{  °ﬂnöˆÑÿh∑æ∏¨‡ÖÄ†ûä•¬∏ãlñªÄ7≤UˇCâØ§
ÿzœÖÜa:/”<>U¶y¬çlî˚cf´«pùÈ—28!d^Ö  ªr∆M∫˛.I·ÆGÊ‰'¿´ÿæÅ¿ªÅÄ√ò!t≠Í{ E¨ÎÒ©r'µ⁄[Ÿú˚Q=¯◊FÀÍxÜÌÆ`œD”‚_Ã Ç∆wé§Å/åÈ˜ÏmöıÆkπø`†(Üà| ¸#e.£îãÎ˜Gâ\»y%Y°Y:iŸ5äl®ÑπïøK«=™I§ÅêdÛlë_rø9Ö˚eWìŒÍ⁄iìVÑà>eÆ·JπîQ"óçvΩ˚∑±Ω Ä#Pñ·÷„NóKÙZÒx3∏˝˛ŒÆcúÕÛnôb“úAÖ/0ÄÔ∫stŒ¡K‚‚ƒ~9ÂJŸZﬂÓˆÈ`BVN¿*ÇtYBZ¡T9DÁLùpı|£DLr3ˆ«‹±5Ü∑2 ˚ìˆ£lÒK\§%¢Ó≠˙A=õ≤<7@(ÒA∞¸ 	ıP&$ö3⁄VÀÜíî	Õ0πÌ!€¡`ç≈˛4wÛ˚_]¬∞z|∞©§ºªÎ?√ÃÄl∞”7Ó∂Êo…ô£(0»@t&¿¨j†Y¯lñ_3√eÆÆøı.≈πçï⁄ÖºÔi3ìÂiç;“^»
nc˛2mÄ§†”≤!Æ3Ôù\§«¢ÛˆÿK:pmëè1Õ∑(‡µú`ñks≈‹^äÍg|"hKÄƒ≤Yj$0Æ˘œgÄSò!"ƒ2»38ö´\ÛÂ`^[OªﬁHÑ≈∏ìÃ,ä¡cöI‘\ÁTäÕxÇ4À¨‡lÎdâ&¿∏zŒı™≤MO&Ô›Lµæ·c(ëÁZvË%©Rƒuù#Æ˚÷ŸK’~ô∆µgä( Ñˆ„\-øcÇÏ2Ä˝’aOvuãk√Í5π]#±#<ü_D$™˜◊™Qncóæ£¿Uu√pO07∫ä|©ßÇW√õ@Ö}´ù°ﬂõAmÄXXÉà§ƒkx‹„ƒ·ì˚N|Û2◊otI¥f‰ÊkÄw≥;:570≈óëÚ¨R@U·õú¿=¯ÉTÏ˜(ÂÔŒ4ˇ◊gvõAÈdÀ9m ﬁFé«Õº?81/Bx6æÅ∑≥'uÎ]R°€Xèóâ»õ†ºÄ!˚vEﬂ«Í◊òﬁ;•C›6≠≥ËGÒòêêt>[„xÄÓIÕ~ÜÂ·≥D&{B4ÌoÕ
÷8{†ß‚ùÑgN#‡Ÿ‰Äj›Ek‰Œ ,ˆsí	Ëô'aÃqà˜,84◊¡M¸ijV„S¿´_ .◊ƒât÷B/Â∞àöwIÚwˆÅçÏö˘kj˛πàπÄKŸµÑëñùª~è*˜QÂ√»Ã8Ô,¸º$Õ¡!TÿƒœŸ…Ø±∂¬5Éø©wÀ÷9í’V)∏ÄÌ¿$©bc˛ßlÙ6QÂ8f∏ô∆) mö0É%á°¬{é„
π.fæ´öÕ#(‚Å®Xˆ?XP@);{©áz-V∑%¡ó$ˇˇ*y ¯;vÑ?&Á}Ñ–Ÿ±‡∑xLGó∞≈ˇÄ˚^≤OoÁÏÛ„b¢·Eâl:Nê)Ö´bìØNØ‡≈‰$˘ˇç.a∑0¶èc[)ªÕúA<ˆ€˜pïˇ>®.xüﬁÕﬁıπ=$ág˘ã)ÁkoÅt–ˇK…Q.∆Öq£ÃO0x¶˘-Us√Í9Ê/~OåDÛvÈ™Jõ–{ùAÉKM	J+Jmwáµ›DI ÉàG¥/ ˛™‹˜ÍÅµeS"nŒX>œø£äR´~“yñµOôáfüÀL•à«Â2-jøCdˇ;v›`ı#w+¢»RdWêÙ
∆¨PZ∏äHÙ]T˜k√u{@hoÅi´ì¡2èv¢ÏÙÃÁ˝ZÂ˝≥ãö5D˛ÍÏØI|'Ü^iËæ‹ór◊0uàxΩ`¥2+iÿ®Î⁄’‘Ωl/HÄtiò¨SâdÿK#CNdò∂
´«¨\Zx/Qsó∞ÃJ√≤UÍ*@˙üUÙZiX'*˜˘›fÜ¥Ÿ ÙBiX"∆“È°Ù%¿\n`Ω5]/V)‡kﬂò]h£|Ωó
C˙4'¸)aΩËÙÖˇ¬ΩÄﬁ @ßüÏ3|ˆ8@Øùf˚^¿BUÄd/#≥ì È«Í{ÌTÖU81 É@Pü∑V´0Wƒ˙ X¨–S’¡"≠eL‹ôC˚∞hp<NgKz™JvÎ”Ôæ ∞Í Ï5ñy"ˇ	 øÂ—öcX√$õ	‚ÃÏ§ﬂ^ß˜[ﬂ#u=-ﬂOèë¶ŸæÀ<„Ãı∫”˚√≥åù~û} Lx$>q√ãd±x›ó›[ÖEı)I(€£èÎ†9ói"°ÄG’˛;WzØËØ|GóÎGÿ;Õq‘\±˙ >S—lÒoMÊrMJ ±—^s^˝Æ
Jﬁºúù˙M,∑Üøèõ¨áw®)(“⁄÷ØΩÕ_ªÁÈ+fâá0%øüDÊíøì{jΩøŸ>Kè”Èsﬂ„~ÙWx\äoéc<•bı˛s_˙ÄÄ∞’‡v l«#ÁdÄP≈íÁÑSà|hΩˆ€`æS€êE<Z∫u¨Ãv/˛õüí•¸nrΩÔ≈xÆ∫ûÍ˙OÛ]ÆíüwªOA˜ êúº="˜Q™]œa˛5Ïß
ö1T\Y◊\Ÿ/ãÒ ‚Cœ5^Î!Qù∆ÍÙ˛lcŒv<MÎ{µzÛ‰∏ÅIö]D∏ßª>Tó-q◊≈{8ﬁ~ÜCÃLbÎ-◊óí ∫‹P7 ∞¯¯`ˆGóŸk¸˜1¨^∑À’2p≈\”áûko$0ó 5ß$zycx!Ã7≥Åä˝›¿µ˛û˙)Ák÷hÛs]*˜÷ÍI¡Ö®}1jûÄ⁄|Ï¯®§qsø?ô#@"“Ú~ÍÑ’∆Á‚^œ&ID‹ÁÓÉ9%M„q◊ÃÚÖd‹N™Eƒ"L"Êàj_‡¡ÍGπ~›˝Y¨¸å‡SDÍÕ∞z√cò|(›∫9±L‚©öBB©ü˙Áî∞‚Æ´ Öln}¶˘‰EÅ∂˚LÓo~ãÀ›ø£ê∑>0‰°˙5≠¸’£¢öz˜è>πµ·∫òhˆ——U«:€`Ù/|ß`]≥%Ì}ÍSü˙‘ß>ı©O}ÍSü˙‘ß>ı©O}ÍSü˙‘ß>ıÈÄßˇîµé—˝ºR÷    IENDÆB`Ç

====================================================================
FILE: D/D/icons/icon64.png
====================================================================
âPNG

   IHDR   @   @   ™iqﬁ  	?IDATx⁄Ìõmå\U«œ9wfg∂X®Ö ’ê¢b´¢¿D‰-Å"%A .&Ç≈T	/EÈ∂ªÖùé–›•m¢U?H√À¬.÷`bh¥ÖB‘"Dm@"DILT¢tÅ∂ª3sÔ9èÓ›ŸŸÓÏÓÃtf∫ >…dfœÏ}9ˇÛ˛œÀ=∂`∂`ÔaìÜèÃ©LÓ—ì?ø`ã'ˇqΩ˙†*à(˜Ë9¿D,¬Ö“2$-FÑ4PªóıÚ95‰Qm& A›+!‚p€¯¡Ñ©È∞*sèM3;}(Üt+§áaµt´o&R«‰ÚqwÙ5é≥˜3ñå;∆Ãò·láèÎÄL9÷ƒ#‚„œãÛ?bΩΩ9Å¶Å‘ÕOkøé«£¸}ì¢{#Yº&≠JG¸ñ‚óXs
åsÉÍÈñ[õ…ÑP©P‚≈§0Ù√Ù•vµL¯›8Ú‚?JhN%À-:O∑‹3R›ëÇ‘©ÄRAÎ√jyD3≤·Âÿ°(i û£P∫Ö Û%ñê5k–ê>ÈiA√ °FËGn
;ög;ùr<˘ÏÎ‰u%ù˛	JÊ˝t≤é!ulêﬁ#¡4Æô5ŒyãûvDq\|HN9yÅ¢π·-J(60Ë»KD[fgk®Tv37‚958Ó:@MÃ∞úf∏C^búï£îP≤¶ó!∑yÑ÷†ì.‡gFºK-95d8ô◊“¡«‚U|™óõHäp‰4H Õ–//R‡JÑCD@∆Ù1§yÚ1¨∂=òm≈s∞úD¸::…`Ÿˇ}°'ß¡4ó–*ÙïƒﬂƒøèºD‰•@^
 ‹)ø#‰l‡oÑDdÈg@7&ödZ,ÇIrRÕb1ÙâÔØ≈r#£Ñtp5[tÄÈ´*R!`95ÒyÃªÑxåYÕÄ˛u˚âd‘§(œ“aNaúêNÓÊ}ñı≤á.µåàk]®sõÑ‘¶Oí·bî´∞úOò‹l	Oö^∂Íe(;âÿÕÈ¸æºbôËJzÉ_$Jn è∫˚Ïg0,%Cˇ¥4YÄ&Ä
ä˜ﬂ ˆ∞ºˆ∑9.† õ@¢”¡_Å·¸Ñ,æºfÒmûÖ·BÑ'˘CúX¨gk"îybP˙Çy«ıc•òL∂ÚULéNcR85'‘¢jf@@+E0¶∞èè±Mœ¿Ûc≤\¿8œ‡ã7∞>Û⁄dâ´Bñ3»p.ÖpËta»ãK™Œªÿ¨;Ë‡4∆£4&P|$ÀgÒ8¨πùåπÇ¢èZï
OÇ0[¯ÎRÀrÑ€ÂUn”ÀY∆≥√«Á5˛Õ*∂fê”ÄW&N(ÍVsåÅBÍêÁYû¢à“•ñçÚ&ÊiÛµÿ${l 5∫‘Ñ‰4M^∆“RÏ‚ w±U$„%TÖM€u1ÆÁ]√W‘A
ºS¬ëÑ	›∫™\ÔüúDƒÎ>›h)fÍpÚ©‘üç	yBPaúßyõ?a«ˆ$ìéKÁ‰≈3∆∑…r"EJd8∏ÉºxñU(ûà2"éÓ*Ø˝ƒÔÂ4≠ÄŸ5`:c4	ãL‘œXÁQDî{5≈	˘Æ~ö4Î)‡0§«ëf-õ√KX#!9M∑£€Vø‘íWÇ–ìz|JuçÑ‹•ßêe'êI"ÖAìOô‡Qı2zÂ≈rfWsƒ∑
Ä√WæF‚‰‘∞À?pÂ$iH/#˜cÃ)ï'Ç¡·1,%≈ì‹›H∑¸tJGÍîë*`HÀ–†UfÜ€JgCÍVÑÎQ√î…O åâ≥?”ab´ª1ﬂÁ {»Kt]†≤±gj®UÿNö"g!|e% ÁH0ŒDŒ`fPnÉC)†tòï8V≤à}l—›ˆRz˜∑Ù-ﬁ?ìF∑A˝"®qÊ∑ü,y`-ã∏8ô|4YLÃ*9Ç¢ÒX À'ÄÎ¡ØÇ≈KÀ6a:çÂ2á¯≈ﬂø‹	⁄œ.¡-Æ∆ E2K˝Æ8≤XBB"!‚^‡iFlúgÙïu·Hür4ê‘[#JèÏÊvYçrûÈú±è®Ä£K».îsX'◊±NûdD√j´ñŒì›&‘s˛Ì*úîL∂[û·f=èìŸA'_N\"®xV‡»PÙÙÿç SBa˜%Æ¥3öÕ&Vjr9]âp´ÂáîX'_°‡Bñ è´†}¿8CÙÿç´•Km9Îõ+ê∆pÕ Y¢¿(≈q!_BD≈ƒı?BNáÃ¸>:∞@âñqˆñ;Ω]¯Zõ} 6j@µ(∑ƒ“¨ëêÕz"ñ’§X≈†ûzXzk»K	gnB—$	äPn‡tJóh^•¬s'>%Ü}àÄaÑ„í´ÏdPØ¶W˛Zé•√jÈñg‘_≥ÑKŸÔFü›óåªÜf£-@Á AÖñltApûn«S¬£iŒ$≈Kl”ù8v2∆Øx*˜óÇøØ\&7‰ímKÑ™hÄÀN ˇÑ•ÂN›ƒ˜ 1¿bVº˜˝≈ÚFyç‚°ÁQÚ∏∆Ô©ù.0Ω%≥E?Ö)Vƒì˜Øô/“+úvûÁyã≥‹68ˆÌ)Udc%˙—rÅä7äaç¸ÅA]E¿> Õ¡‰3ØrØ¶XrX<«;ö”ò=⁄˝Äxbéú¶Èï7t?≥¥<˘52œ¨Òñÿl∂Ç§´k˜™¬Zª”KÀÇÜ0õãnﬂÆªâ¨I4¬1≠Ò˝µÿ≠RlÔt⁄í
◊{ïyÁ—Õ)Üj=¥=)mn€Ä6F∑˘h¶ÒCÃ{Ä	f{ô7≥ê∆kÅ†˛K˘$ﬁülì3mﬂ<]πÄ√jy›∑mõú"yÄ_D∑uG9æó pô§!"-@¥¸ƒVy'Ÿ∫r-·S›_ÄŸ∑ ñí˜tﬂïíœ•*cïÊláíÊLÑÀ)°L>F7µ™tPß^x<b98âT8ÑS√Oïku‹APe<ò·8l≤U=Ê·ÂéRK*Ë	∏ê17”ÆﬂåÃïóEæD—l`£|orìUÀZ*  @È\lÍ"ú?7[D0”„ç˜5∞‘ÄÒá˝Àa«X£˙&˚˝ÚÁz'ﬂ∏=’o˙=5À'ˆÕõá?¨Z∞[∞˚∞ˇ	°˝y π
∂    IENDÆB`Ç

====================================================================
FILE: D/D/icons/icon256.png
====================================================================
âPNG

   IHDR         \r®f  CJIDATx⁄ÌΩyúegUÔ˝]œﬁÁú™ÍÍtwH!"WÑ4` Ç»EíÑ^Ñ€%(˙"JÇÒÇ`Ç!©>Ië·""ﬁK‰™º Hó2(ÑA!Å(2â $äêH$È°∫™ŒŸ{?Î˝cgèß™ª´ªNù~~üOg⁄”Û<k˝÷z÷ ´ 9~o]≈ˇöN=uœ¿	Äcª‡˜`∏,]±n¯◊≥j √Vî¨N Ωâ∂aF¢¬˚|oäLµŸÑ˚Îü√>`SÕ{uÿ¥¬Î)ˇﬁ≥JddŸcÓ+Ω∑Ôp∆æC∏–∫Î<0∏No„…~„˝ÿ‡ªõ˜¬ø3ÁÑÖÔÔQèmXƒ	' V{‘À˛Â˜mbjÍlZﬁ≥¿ﬂJ=ò∆j¸íø5o%hf6h·Ò©
"JˆâÇ"—Ï3´…Î‹¡D@u˘Òë‰8
’≈ë\ªU¡†(Ç†u_!{˘Q∑…+CrâÔ]$>¢Ò≥ æ◊¯ær ù@JÁÕÓ"˜π/O~àFﬂ« ø!—«˘˙˝üÊ]ß¨åôÉ á«ˆUÿé–ÀÂ˜ˇ∏lûz9∆ü—∂y%ÍûÄÊÊ5•ˇÓS”¸¶n°6ù´¸y”˜ó;ØyÂ„È*ÃñÙx…øËŸoK`ﬂ©˜¯¬…òUCufÅ áG˘S˚~GˇïtºÌtÃ&z@Hîi t*j™˝¨†¶:aﬂ,çx—IÚ≈"à1
V¿ÄZ¿π–“ÁŸ+Ω/9Õûˇ∑ÒòÈÒL›Ò¥pÌı3B—íj◊ÏIÁL·˘$Á£ÖgS<∆‡óÒ∑‚#¯Z¿˜D◊qµˇ«ï±tp`≈ãˇ∑oﬂ"9ı/tcÎ9,ñ0ßs™⁄≥NÀWß,ïIÕñp$Z≤ndVzé&∂¢U∆æ"m=¯7˛ü4|;çá7£,`Òô ÊÌ{∏ıûóÚÆS:!‡¿ iøàÚ{˚O‚‰©è±¡{(~fÀ≤‰∏®±äOïÅø‡∞Õ]Ò2©ÍœÏJÜ–ˆ¡ßE≥"]¿⁄ ∆(i{iLUfêgí›#á,‚ﬂEl¿g>˙gÓ¯ﬁ/ÚøvøN ,7s‚-æœ›=¡â'íiÔI, ¥jÌOAõ ≠|dñÚB¢û@˚}ù84^è¬¨Œ¥ÍÆ!`öÛ—ÁπÛÓgÛ÷á‹ÎÑ¿—ÅãªÿÜaF"6üÙGúP≥¯ÀTXWDüãñ∞4íÏ‚ÔWvÏa4z†3•ñïπVé/9ˇ∆ L≠5=t≈ø[â)¢Cﬁ´{vÜÛlûƒè=Ë#¸Æn¶+6âpp ø¯’cN"f>G¶¸óp–Ü¸[…“¯4§·'†ŒﬁñÜ˜§§üÎÙ‰rRr?m‹r+Pı¢ÿ†ˆ{uÏFjØCK˜S'àÜqÀa¶ìT8Nã2Ì=ëG·∑˜nqB¿ô UÍØ¿ãÈìˆ´LôG–«;¸ñ”O6±_µñ¨6;˝¥`È6€Ày[\:ΩLÛÛ§ΩÍlÀ_I3±◊ä`´nfÊ≠πﬂJÂH˘sÓWJ,§¸~yØD≤ªÚÜ¯ñÛâÑL·3}ûÔ~Ô<Áp`ÄYıÈJh∂˜~Ÿnnˇ=B¥A˚&gÑ¡£ïMv›ˇ’õ~∏ûÅC›YXÓ∫¥∆j≤œá≈>‘ùßÓºÈÔ†?ÙﬁV‚	ô∆g>˙,_ù6ÔﬁÏÑ¿*¡_◊W[2ç|yqÖÍj√‚üƒcëà{¬g	ÇE"£ÿêdˇ>ﬁ«7v∞≠n»m±€‹πƒ®¨"jEå)˝Tçgc0j’4|DµItû©Ñê?V˙É¯öm∫o0Ò«Üd_ﬁ
j„s˙…˜¨ÏŸgÁ‘h¡≤ÄX…ÆE–Ïˇj≈ò¯ÀVå"VLr\ãg∞jiyOe <ìãbjÑÀÚbTô'` {2èùæëóˇËYteø«3H∑˝.˙ﬁIÊ·ß|”∂º-Ÿ´ x,Ò>Ù∑≥£ÛU7¸«Ç•ÖØ‰$ÔMÃ"+T8U!ûöe!Òôè˛âØÓ}6yí«-ò√ ßù¸SÍ{[]©5î“1Ö«o„ryYb>∆edtÁVàmX·éA1~°N$>ôÚ˛;èﬁ¸a.˘¡˘teﬁ	Å„Q ƒiΩò∂˘ImQFñ•Bñ[xÙ¯Oæ≈ÀKŸÅn“=ˇt%‰⁄p˘g,ÄAà˚Ö!˛¡gÅÄºßbw\ÚÉù8|¨{h#N”·>KÃRvnê íòácÉ»V˜3¥Ú'"‚^⁄,∂ô-1Ö¯-∞¡;õá<‡√ºËÆnã8 œ,∂b¿ˇ*ô„–·çèY.^BÒñ¬ﬂ¢«Õl¿ a%>!ç8ƒ!¥&4N‡π‡{Stç«ù ÈÊµK€`¨t/àr∫ «24˜0fh>∆o˚?‰^.‡†˝"ì¯(aÂHi‹ƒ¿<à#ßÕ”yÚÉﬁœyﬂË∞uB‡x e«ëRíkÒ⁄ÅÓ5ÄzZ–¸ynñ‹aû¿Â ˚Ãy,ÿa2q"ñ«∂xÖÑ	l2ÁÚ¥GÃÒ3ˇ‚;!p<	 Fíi-l#ızn¥◊ƒI!xH+B@P˚†¬ır/wögq–~ÅâZ&P6&bü¿<ÕÖ<Ôå˜23ó8]·◊Ò qé∫Xˆ¢Û…s‘M‡5&UñqÜDô’6oï{˘˛¸˘,D_.0ÅÊ¸Öò	Ã€êÕﬁ/Ò¯Áˇ]îÌàcc/ ≤ô˙ƒî¥ñüè”kbîvî∫Í@d\[âÿ¶o›t/w/úÀÇ˝RÊ–‹˜ãC–¯Ï'`⁄¸vÜôm:&0Œ> -'—÷√Y kJ–*π ˘≈_∆úƒB‡-'¸ê{Œg…~-«§¿ ™¨"ﬁ"‹‰øê]¡;! Nå© 0v-Ãπﬂw`M| œ}éôÂóoX/ﬁ∏Ò~dûIœ˛[≈'PW_ ›"<@¿¥ˇ"vFé8!0∂¿JR+ªLˇ©∂¢ÑÍ| kcüIÌ,+koÎK-ÿ£oêªŸgŒe…ﬁö	i`A‡sêêMÊ≈Ïﬁéàe„Ñ¿∏ô ≈#⁄T±G@$n‡◊d|–⁄ÄÎÅ¿.òg!∞[~¿Ωãœ`ëØ|uçı‚,¬M˛or]ôë»	Åq ∆§Ì:¥B¸Ûq‰ùQ_(c:)Û˚1MUâ`xVJ*ﬁ0}7˜qã	®ãlÚ	lÒ_¬µ¡€ù7`mqºk∑ôhè¯B”&˘öIuu”ˇá!+boêª9∞¯Lzˆ´µÉZ˚ø8N`ãˇõÏnpB`‹@:—h∞5G}iÕ~≠Õı∫i<ÄßÕ˚˜πÅ±+ÿ¶MÖ¿ÆÈª¯—‚πÙÏ≠µqeU 9¡);¢ˇ„Ñ¿ÿ¯ ¨ ∞RVi)âQ⁄Á1öŒ£û/Ω+ˇﬁ¯¯ ")ÏﬂÁeÍñQ¿˜Wñ õ7Ó2œd…~ô>6'@ÉoAÒ9@¿&s1◊osB`,ÅL≥7x•%¨◊
IM5˙Ûà<	T∆2UπX‰º∏LWVƒº^¸°‹≈ûEèØ2ï˘§‚™2ÅÄ-˛EÏ˛w&8>Ö¿80 ©M *”¡h„ ∂'-JUŒPﬂúÃÏ¬i±I0f·´≈≈^ü`Q§B‡çÔaësÈÒµBú¿–¶®⁄‚ !'¯/cGÙ'Ò±éO&0ëÄûh]«-Õ@Ø=Z< ≠ix≈ÅS@≈¬D˚g„o/∞\á"lxËã/]πõ}ú«í˝:À&•‡«L¿¸6;É∑ØL`≤≠(˘ˆîıìo‘≤Áíg?—zí∂Õ"@Ãy l={|v¨-ÚÄ∆¶ß˛·ïÛ ÉÚ=ÓÍ=Éû˝F)b∞m 9s‡ '¯óp]Ô≠8éÑ¿0 £öRÀ DÀ‚Ñu‰‚ ˚üvÎ\|‚˙˘p≥_k«~Ä1ôÑ∆‘eeÛ¿A≤V*˛hÍòg“Á[π8Å|´Ú∫Û˚,rb˚ÆﬁÃåDÃ‚/B`ÄMw–´›w09q0b†+!€¥z>!—2?A˚ëOÃöùéÖ˝oÎªósÃ∫jS!∞SæÀ˛}œ"‡;¥Òâà≤355dKw6˚Ø`G∫/B`,@6°Ü’%`è∆ìÎå‡gi{èHJö[Zûº∆(((ü≤˝ü—pªzã,õø≈AûEﬂ~ü	<4√œWﬁÏ_ u¡Îé!∞˛@DìÜ)nç\(∞("øñÙ0∂ÄOªu3ÿ±ˆJg€§’uUÖ@Wæ…Ω¡/⁄;Ë‡aâjœØ9—dÒô'‰ˇ’\◊€q<Åq®	®C?IÇ,å»6†™∞À¨ûÑoûOMÍ‚
!x º DŸé7ΩëW]Üi_Ä’d≥7˘º~‚,ôsâÏ›!På?êÃ è%B6∑Øbg∞}‹Ö¿xÿôBsπ®4‚¨3"π €ÒQ¸Ë:ÊDB¢Å£ J,ºKyπvbf∞Œ'û•¯ÉëÛWπIK˜úêYıπFæ¡|¯LBb!†%Œ(µä√cÅêiñk˚WÑÄ #/o_VSAF&0±\9*yeb˚{9{Ÿ`Ÿ`aN	.éõ]¨ÛâÁm™ò5-7‡yL≠˙πªÅnÁk,,B˚#⁄5Ê@YH"ñŸ‹⁄¡µ˝À≥c90j&(÷ *WüI_˜˙k≠∆£+ñÈ…]Lò∏ôÈ@"˙X€ÒÆev·°l'Z◊ëÅvˇ~ly£»#Qïl{t’ÖÄ¸˚¬gŸ{h◊0-\szeãÑlj]oÆ]∫tÖ¿¯ÏHi∞ —G¿∏H[\,›ﬁ6Èò≥@Ñ‡ÂxÀ`C,@ÈòMLv˛eÎ:.gÂ-ªˇbà@≈{6" ÉèB%ﬂt·ÓÍ|ôΩãÁcÌΩ&–<&âX"‘Mù7∞}·◊ËJ8N	[c	Hﬁ»k˛\ˆôíÂä≠ı˜πAf{g∞°˝5nd⁄‹œ»$6ËÛtvGobF¢ÿ!∏ÖÄÔ›Nç˝Åè>ë∂8õù˙ºXH&}˛tˇÄeV€Ïö˛˚£Û±v/x,∑ˇõF˚Dlò|;ó;«#_cz÷è_æ>Ä •´pë∂ËJ»ïΩ3d£ˇÑçXI¸ﬁıuIËÁ¥y%ªı∫ã∞mÎD˚lMû˜b˝8ÃyH$†≈óÌx◊Öø«ïÛß“ã¨‚üÆX∫€Å◊µø¿]¡œaÌÌ¥ µÀµ/3Ñ(m&≈Ûﬂ:N;Îﬂû—H%]›J]q»x!JˇX
;aè∆]ào ‡∫‡Ëò95ÊD˙	ı◊§öΩ6,ˇò≈¯,≤Å.◊GdÜﬂeN"f’g;—Q´"îj∑#i∑Ω-·f[_óêΩjÿú>©i*ƒ}õ'9¡{#≠…k∏6¸*6Í!íÙx“xI+@*Y¿TñO π*IMƒx'"J’ù*b<–yzjic¿Ë≤Í!nKÍî˜\◊ˇ^€˘KfoÚÈû:∞÷2†~¿rI ¢«§$ò™∞èÆÑÃHƒÀµ√i—ÔãÔÕjLumaÒSc{VÀf˘	¯~∆˛4ˇ≠˜;tÂﬂË&¶≈ms ‹ÃÍ÷8íÖ?ªƒ˝˘.ì±;˙,Û,â≤9Wø˝¶,bÒÃ&N‡©àWËr—ó∫◊5éà⁄d† Ë£ò!—$Uó•b¸KŸ∂ÁØÿ~vD◊1Ä5˜2âí-jQ‚-&Dé“.@¨-c3Æ?rñ˙ú˝æΩöé˜8]L<íxƒ•¶xï÷Lp…	ÅÉÑ¥ÕS9—ˇ˝1Ko¶+w¸`È¢áJ<´ÜÆÿ÷éﬁÅFSºvÍ3È{G`bZ	¬w*ÌÛ»o‘÷WqäqBîhòmnã÷´ j≥a®µlãÕHWYv◊a∞¡,z(msè˘≈' ÚTM2ÓN ¨	$ƒÀ7å™Fû)´ÿ I‘πIh∏Õ\ë≥•”~.∆˛&ﬁ„P»º˝≤e…]kπ»yjÙàÃS\Üô¯MvEMΩÉŸ÷gË ÄäÓQ/ŸN≥á∏x`CO∫¢Ì@·3πUuLÇU±€øÛ>~¸õt¯I˙D‰c¥—„ÂbJüõ˙˜hÚÕIç≥∏ë14àéT˙¥Ò•ﬂ˛EÖ/∞˝ûè ´ k—¡|™6èŒàBgïÄ(3…ˆQ∏j·aLzg·˚œEx:ìÊB†gmRÆÃî&zë‰„—Ûˆ±T4d‹‚4B9HÑ1[òÊ•ÙÃKπﬁ~æk?¬Wæ˘ef‰pËé$äDgb‰ ÆZ‘=íg•s_‚ZΩîáX-,“ÊΩê¡R≠≤;ÜöO’Á&ùâÍèßç¬A≤Xë'úùN å(ië¶Ü°á´˘e∑nÒÌ‚„B¸ü«3œ9S&ÕÖÿ XH|ﬁS` ÈîîÜVY˘xÄ≤∂*W:|,öÿ‘Û”x¸4=o;O|Ù◊ybÙiñÙ&ƒ˚ﬂ˝ó;∏·gÇ–°+ ÈK«ü8À4W8ëd’ãiwü˘;Ù-l6/gû>yßÃ0õæŸ\Ó“¬<Œ∞ÜÎ¸rúâƒÒõÚfoÚôë0õÎc$ıÉ9é|`[Ú¨¬EòºôìZ◊1Ì=c6Ë"=	à≤Ì=SFístIÕ’⁄“ïDFQTH.Å¸8 ëÄñ∞X&Ã£ÿb.‚dÔ=b¢œsÍc∫í‡ì<œü”6æ˙lbj‚±Ò">¬y2Éeèz\-Ø‡ sL”Çb¨FeeYMΩE†ÀR˙ïìºÔBà@#=Ö˚Œû:§Îr‡(@Ì@Ù êÅè∞&‡\íò.]Æ˜Öro¯Ï‡Sth—Jñ∑-hõ™áZ*é¿rCù±†Áf˙ÌÿÓo”bä	<=˛ì˚¯SˆÒBµﬁìÿ⁄˘àÆÿ–Ò>16¿ìˇp‰·π¢I§·£¸
˚Ì_0M+iŸñ»˙·U
>ZL≤Id(fÔ∫_?ÎﬂHò∂69xVÕH‰Ló{Äbˆ€ﬁƒÉûı€ˇ∆\HõG ¿R"L…Ÿ%ŸﬁÑ4^k˘ˇuE4ïÉGü πïæΩ¢øe±ıE∫≤tË;r—[¿”’ ÚÙƒ”±:€Ç™ D| ˚vÑˇJG∂≥¡la	í¨»?≤)#)FL`≠ƒÔ'ˇÆDÉKÖJ&JÏ"d√=à9»ÔŒƒ∑¬^ú XsÄÌõÔöhõU8ü
s….@Wñ"∏∏ôWÈï<0<œˇ-|.†Ö«bVÈŒ‘∫≥Úˆhìù*CAò¬câŸÉÜÔ‡K˛-ÃyÉXÄC›H∑˙rÊ√ÁÑœxø!tÂŒ#‹Å‘πZ˛àK>»)ùWaÃò‡î$07˛≥;<ìº6MÆ:*{BuÂ»«7≈ßúœbÆ€BT6;02Få°o¢≤jπ ±3, É€0úé–ïE‡É¿πÆˇTBÔ’¥ÃsÄ∏ﬁü$l@+ﬁ ≠X≠©3Ø}Ñê>ëUzºù•‡\3Òç‹"ˆπe{ÕE‚≠,/:õ∂)0a6∞©Û4–˜¿jmwâ“E«‡Ì¿+πbˇN¶€g!ùßŸ«`8	8	UØ–K† 
«õ$üZ¿(XAQ’XõÅSUUÉ¸>—ÙiîÜbN¿˜¶≥»≈º9¶π>GÎü 0v˘Õ% ]§Ô´o,*s9a«(Øï˛ëz!˛ê)~"YT~¡PÏò#%OAûÑL‚”„V˙—ÔpU˚Sô¶üK¸˘8ÄCG∫∞/ \k@å\†»ªŸ™´˚”Ñö≠3ÚC‡Øì?1^t◊z˜
úø>¯a˙·…ﬁÔ°cã] z˜≈œÆs¢“ªOËúòYàŸÎç˜	NT6a¬*KFà|èÖ~»£OºÇiÆ\&r:õ’	ÄµÜç≥}ö[Ñ≈gGŸ≠îãòU√mWÀﬂÒö}ü·ƒÈò2œc!'tG◊Ä—L–b¡~à˚Õã¯Éˆæ,Ío5⁄à≈[|ñ◊Ï{ û<%)O«ˆAÖgª˜ofFˆ—v`≠ﬂ!1)ÚfUj∂ºÎ‘É«^i$˜∑Ωø4tL≤˘uøc #°ÏãNöµG:±„B˜œgWÙßl2ø≈<!4à£Ú˛ø2Iã˚^^c~ƒ∆	(≤z	(qöqƒ∆ËÈLöÕ,f…Jqç¬)s2ö>Ù…v‡Í˜.,òU«Õ1∑ãÒACl`jÁ”zË4}òÙx¯ Ü∏◊§@\à¬∞G=ÆÙ^*¬ø»öX÷iñºs 1Åœ|xˇe~%NÆYÌÏ≥€í‹ëfæâ ïô$ÊŒ1ÑË1ˇsjÚ,LÌÍ–!ÇN ¨ù	‡’Ig≠HÌµjﬁÀ≠Ò‚’è¯/Â üKZW5U®≈“FXä~ƒ˝˝pÉÃÃôU…“ÀcVsq•ûä·Ùì
≈ÉÎËÜsπbˇ…ÃIt∑“ñ!aÀN ¨¢:Å\å°Éc]†*nC¯îÑ,Ú"‡!®≠∆¬•Æ?É°ß/„ıæœ¨˙´ûÚõˇÈ‡óô2”I)Ñ—FÑLöÕlòx˛¿dsòöÖÆ5÷⁄' FÄÿ™ò"Ñ÷∫;pZ»£+ˇIüÌL`¿DïH?ô¿c¡˛≥≠øI~stäNl'b€„˝zVØÍHçãi¯ﬁEl€ìÓ‘Îøp´©X4„ÂXˇ¿+µSÍ[QE#–d;€‘£˜ù?aûo“™©IßBk˝0∫8zŸf{í=ˆ3û˚T:ÊÒÙìD˙rU%≈£GƒÑy<è˝•Ûìz}˛8ÄLß”'$ë	qç)Eπã kÕ6˘ÀI3≈î–∞Ωˆí[D„†°á/°Ï ≤ÚˆÃÜ%˝x8€˛€‘[ï≠æZF ä◊zy≤dO)Ä/óUU„B+9ÉU3@∆√8&@>i¶ﬁQ3:Éï…†«{Yàn«œ`së˙ø ÿvîÆaVsXf˜üéœÖ,aìˆd5Ö6 )P1·ùE∑]±„TªFÿI%£PÎrMÔw`ÌÀh„2§	ÍË4Mz˛ue	+ÔLÆ+ m=æ…Ì˛Õ® Q”˛[ìÍô≠…+È–∆ î7áU†mf«ﬂ0§™ê8¿»ô Rî‘U¬&*#’<•–anzÙì<Å(é˜pÉGÕ€æG=f∞\Øèe¬üaëAI•jVB^x,1Âù√Œ‡πYﬁqÙhTvÃÚ	mûc:¿h‹A•Á|…0jËJ‹˙˚öŒ◊	ÏóÈ$eK˙(Ù?òhÈ£®iD±Ï§M´êRµsÀÇ ÆäÎôÎô’â¯≥1å— ‚/œ/Á%@}ﬁñ˙)äﬂ≠€éó‰ß} xxˆ?9yÍ+ GÖ˛ÔIúä◊œ`ísÌ…Ü{K$7_zX6òü¢\6ËX4f&Ä)L-i.;Ó| £uu…@Èø^{‘l∑ƒ>ƒ±>Ωôã%8*‘:’‘≥:Åoﬁ\	r©k±û¢ÉœKD2Ÿ∫íkó=($:n,Ä¢cπ\†EgåŒ2±4tŸE¿¿àn˛w‘~≈ÿè*„òëà∂ΩÜiszVûªÆõRìJÈpÍ1IªÛÁú•~º[1>¶ÄµCYPÍ(P« F©Ú1ı≈ø$±yG€ÒËû
|ÜE`_Ôs ‹∫ ˆˇçªΩ∂ˇÛLòÀÈeEøVÓ#…ó2#È[∏ÅüÂôv'3Ò6∆:8®™Tú`D≈À[k¶Û†;∞åŒ6`Õ⁄≤˙Y	¢˚ÿµ·nTeUì~f’∞ç8ﬂì˜N!,∏NÀì{PÙJá≤∆øœé‡˘\,¡∏DcœB)Föéõøc\rML˝‡C•◊ΩﬂG‡€hÈcjı‚’g**l%.r±y˙›tÃ√í˛ÑEÌ_ç°§¢„™K≈`âË¯∆eΩ3ËJ8V[É˘rd£P≠ÿ	Äz'Ä‰óæ‘»kQ¡ó—∫¥∫Œ’”wqEÎo
Ô≠∆‚ø)±˚wFofÉ9óÉÑ9Ø5≤≠‹õPk4üö∞¿„‰Ä+ÙîqàPï˙Ê-≈˜‘	ÄQ0©h,©–⁄∞≠£<„Vw—®p>ÁH»Æ26öW∞@ò9L ˝ ⁄≠π.~µ≠ô$…BmÛ0N¥7Ú;˚∞ﬁÖ@\Qî∫ﬁ9à:¿h SØ©Ú√'¬(˚ —’€˜Waè$`W¯
6xØßGòƒ˙WÛ%§¡¶“∆Ú*UF`@«<ÅﬂQ^ìÅıÍHä%¥bV∫m¿—0rˆZÛV‡ÒÄYç”yª≤;ºí)ÔÕÙâ∞π≈ø“g#5ëîBs∆ÄóüÙ~Üì¶oÊÍ•üJJ¢≠?! Y_ÑÊ>¬‹6‡»PËÇ‡xYÓÂ≈Ô”ÀŸ7{≤;∫ÅçﬁNzDÿ∏3bç-_m<Z˛N]W^-â…4üÉÑ¯Ê1ln}äÎ˙O…ÉÎà2[mp(Áú3FÜÆ	’∫˙eä€”Öü˙∫rï>å_<˚Ôu⁄ºîÉ	Ìo(ÛYiõ&4{∫Î|RKéc!∞DÑ1ß0—˙$;¬Kòë]ál†ÿ≈iUÀxo4Ÿ≤í≥ã«UÎãÑ@ƒŒpÜé}-Û¿BˇÅö&XI’·˙ÁW˜ˇ¶!ﬁ<,–a£˜V^ùÕ˝/ß+?»z&Ã•TÁ’5Ñ∫≥06€ÅcP`]À◊'ÏQTËJ»eÛ‚˙‡œŸ‡Ω1¨Èf#µiæEMÆC]ÜÌÅ≥í•G»§Ÿ∆âS_dWÔ◊Ëäe.Ÿ%Xæe˘⁄± Úì™Û°Ùd›ãÅq` ∂‡ ¨ıp´åDM¿#£9qÎ±mXD"P√ı·KºÎò‡TàPL%ªOKmBπwuÈjÉ ç∑øä_Øc	≈Û˙Ã—2a™˝ˇ±;˙˙—,3rK¬bFèÿl«Tjhzﬂ“uØX∆¢ HÉ ´&≈[ßÉ•*±Ìúlä(;ÉÁÒz˛ô)ÔÌßr0IÏ©ãÑêÜà>Ü0ß¶x ≠aS≤Ão‚YÊ¢qAs”≠OÛ—{∏∂f∆RìfùÖcÿh|Äµ†^]®jNœçh$‡r⁄àµ=!g©œy·Ö¯Ê˜hôß¢ê–})h˝‚éà4⁄ÎZaL]^Œ≠∞+-î—“ÔÍâµ äº§ıòa¬º ¯e^}kˇò◊¥>FWB∫©âÃ`◊ÿ|”°û¶˚ù -#%Z;h¿≠#X†∫Ëgì @]	≥F£;ûfºŒåıÏKòÉzD…BÙAgiç[´ÓByìKkÿVQ–êkuû]'t=çÅ1Lp°πÄ7D_†Ωã^Î}Ã»ùE«±fpøí=∑¶ﬁSN ¨Ì∫1y÷\‹j$} •EﬂM™Œ]§-∆ŸxˆEx\h;f!∞êµÔ*ñ¸rPu± u&¡2∆TÉûD¨ÏóxX4π'°mû»¥y"]Æè>BÏaÔÅO0#
¬‡÷õÖÌgG´⁄•∏f˘€∆ÁbÕUÇú 8÷.¿˙ÅHÔÿnGƒ0´&Æ K\ˆ+]Ù€ˆxú˘‹3ë÷sQ˚KtÃ£,ãÑ%™_§£Z´˜õlˇÂm⁄tõP®g¿Muò´«-≤é™)2∏ß>ñ>ä«f:ÊÖDù‚∑Ó`wp#æü;˜Üô†õ<«d≠∆œpıÇµ˜üπ•o« FÍ§6{k‘Ü)üÎ?´>ù‡Ò `ÃÛÕch°IÑ%vG˚•e%µãNK‚@W`Ÿ6iÙJ ∞PkR?ÓJ"Íäº;JÃã–2e“ºå»?ﬁæÉÎ£õâ¬è°¡M\-wq4îåô⁄$"ç2äÛÏ∏b ≤B+xpÂ¡”òhˇ,æ9ﬂ>i=ö	  ˙@DoÁ©1+≤•D√ÎßÛ°LQY¡yeŸT5^Ÿÿƒ[áÇbâíñeæy(¸:⁄˛uz˛˝\›B}¥ı?Dﬂ˘w∫èÈØ™	0∏j-≤¥u[÷2–8ïq“∆Èæ¶[K…π_ı›	≥ÂîÌt˚l¸dÜ@ÑeãfUzí]©”Øí-t©hÎ≤ÒìßﬂRâb”° •#VFù—QÂ\á¬¬§¡<»;l]h≥ÖIûC€<'–Ï}‘◊∏TüÃXH‘Ûä~õíRx.ö{ÌvF f˙K÷r+IT8·«z‚˜ﬁDdÔ¿ö≥Äá—".™◊R02dÈÂ,ı¶Ù'ÕêVëﬁ÷â—Â„*§¶T∂Ç;L·;ö≠HEi'"r…,öØÅ˝4ë~à;Êñêm¨é/¿‘{8 œ±∑◊EéòÓoe´¡Ô»ö
Å.¡ﬂÀÏèN†≥È)<„üGáá!&5“ñ·¶bïÀPß_ù›]ß˘WÊ‘eœS/«”⁄w‚EoÈ$}	§}^ïø%än‰™ˆ≠‡ÈQùW„ôE2f>Ä:y=äI€‘c0#˚ÅèÂ’?‹»âõüÅÒ±œb LΩ¨ï),d©ô†+Y≤ÇEZÁ≠ó!Ç°ÓÍMÜfﬂEqº!BÒi„·KÙY¥ˇåçﬁGœ~\ª_/sV}nCW5îÿ4<Á‚uùÕÍ¿ök´‰„a — ©	–ÎØ˝µŒI∑ÂŒE˙≈˚‹ÔﬁœÏ¬C—ˆÛÒ‰Wiô3i„±X¢¬¥,ÉzÕ^⁄æZØÛ¢Ë
t„°
†j∂°EQ⁄x¥ÒÈ°˝<}ùc1¸[∫ﬂ,¯s∂'ïª(]	èöV)QUaï:\¿Båñ™Uªπ†#VL4ãÙKÖ¡≠(]πx&vÎ/⁄ó"ÊB¶ÿ@/14)!ˆrùØáLœeì@@#h>r‘IÚˆ¯.=˛Â=¸æ˜Ö⁄E/bÅhéN°1àTΩ±IØâA6†€\Àµd•íP∑!6≤EAs¬ nÈJ»ÚI‡ìÏ÷üê{ë˙Ê%Ls2K§[ÖÉ™<U⁄Ω\N›Ç]âè@jÿ¬`ﬂAVdOk‚Áòƒ√Ç|^ÇË€˜ÊË ˛Ω?Fãæhòú2ë*;Pì(u&¿⁄√4€≈ŸÑ['‚9≤%¡)ºÜÛo∆nxp	ìúƒb≤ê4qê≥˜uàmæúÕ^˜~}ÿ±ΩétÎQ±L$6[¿ßâxΩ^.“Ú¢Ôä=:Ù˛P)@ùÉ¿9G»	òd
äj\∏íÌ¶‡Ø3íñ˙RVGæÕr•˛N∞Ø∆3ó–°ì’®nj¡u®:πﬁ°◊ÙõÊ]á:œÅÆ(¬«ßÖGœﬁ‚ÖvWteÎ£Ÿo˜®«k∑ËõïJ=¡◊áD9pttﬁ&ìTîpùÊo•¨ µÉªr{Ï÷w ÏdÇ_$ ,!‡Áq±[BUÎÀ[]Üö+aÈg÷*b,S¯ÙÌù,Ëkπ¬ˇã(µÌÁ0ÃHtT⁄°¡˙œ)g"0Å@¶öy^uÆˇ›‹8ò)Ã¡Ú‡vÑ/°-Øc¬<Ä•¨˘«r˙ãÜ‡†Ê≠@≠˝ñ‘TKD€x<ÈŸ?”˘Ö+Ënº'[¯q≠Éë´h¨≠&ƒÏrT¨J÷¿9◊“»fc9('∆®&`*“zzWÀüqïﬁƒ&ﬁ Á≥ÄM¢Áãókﬁ‰C©+Æµ~YXÑL‚ŸÔ≥d^°WxìŸ¯i!”—fñ%#H.∂∏ÑI	∏ˆP´öè®õä¢ÇﬂØòÆ4´0Óm‡ŸÏ
gô‚ñ£qD°W…Îì–zm`À0±àI|ñ¯${ó~ù]æ«ıízÜ·Ë?\S≥Œœ)1ÉÙ≥EWpÙ§vì=:í¬KÂàï‚Ó;ÜY5\ÈwY‡`òßÖól∑~¥`y+Uó"qõ∞à¯¥ 8ó]æ«¨˙Y=√ı7ßÚUé¥v∑√1ÄµıHΩïü≥Ze4õÉÆ÷ÇHŸ¿MÍsé¸›˛ùL{†cDèÉw~∞ò)µ∆ÜÊöÒ‚∑“¡gﬁ^´Wx≥±øBÕhxˆ…™,& £ÈÀÌë(Æ7‡àóÊß,%{5-e=JëÄ€í:wª√mfW`U∫ÈûìÙ‚õmé%sﬂa/	%Æêu¶A]ñ°V‹Ç≈x@èàûå^•ØÒfŸ£q|Bæ  zZëä≈ﬁSc“kf∫g.æfj&"Ù˚£sØß'¡§ûúß-Û´ ‹ j±ÅX\%_gqÒlBnc"1™‚±ZX)˛¿„Ø%—`È‡≥Ω ^ÈˇaB˘Ì∫uæ™HçG©∆¿\ˇπ c—Pó/<5Zÿû,F√Vƒ;çY›LWÏ™.IÖ¿kßngëgÿªiß±Ùˆ|S>Z£˙´TXDL—‚Ä}#È‚Ô±ûÎÊä‰€É6ÖPU}#N ¨ïüÜÊn≠ö¸Âç»0©J‹(s˛AjÕ£¥Õ·œ 0∑ä„ë	πù≈Ë`>qÊ]Qü◊?≥|‚è6Fƒ[}˚Ìª∏⁄ªl∞¯◊˜∂´±∂^ [™ç≈÷ÚX m¢a˘≠´Qqn'ÓÎ◊Ó<üMI•Ÿg&f¿Íí…T\”˛y1ì⁄F\Îj˘•Vˇ†B~”~˚Ø¸{1´&f6Î?Ê¬ñ9µ~qN¿—ÆeZ\â“ë˛‡[ì÷∆<ü∏
ÊŸlS/3V[\§-Æí»A{S¯HÓ<My˙}ﬂ‚˚ôüˇeﬁÙ–EnõìuπÕWoUV˝$U?ÅÛåà˙B˝s&¿H¨f$bVO Œ' B,-NÁ±¡∞gè∑ÍßΩAˆ®ßWy◊∞/∫ôI¸ß‡p^†%©€∆£] éMˇ¡¨˙ÃÕDåñm¸°éå∆@ï¶÷Ã=õÏ«w¢Ûô2$$,æ¸FLü∑ùsﬂä¢*D˝≥h˜‚#H)‰}π»¿∏aHƒæå>¿’˛€ìHƒpú÷æ5¶.®L•sÆÌ®,c«¢2"Å ±yÈqIn‚xÙP|3√ÏﬁŸÜ=*eÃªbŸé«kßnßØó”∆B(*œ≠°òç+ˆ/⁄yØHÆ”2n∞∂∏ËkMKã™¿cPê√öÎnõy≥eÌÎÏQ/.rú£æ˜4ñ∞Y¨~Hƒ§9ô…MøÉà&ÂØV]"ˆ®«’ﬁü2œgÒ
µ˚Mgb∂ÍN^+ﬂM“ì«O ‘˚Aä˛ èH 36w Y‰ﬂhL€ÏHZ{Ê{Ó˙X<^≈=∞Y∂ﬂ™BΩïÀ∞Zç,6ø»—¬p–~õ‡ox˝«≤B·‡¿HHl≠‘≤/Ã˚5¨
ú&√Ï“ﬂ`Éy
KIïﬂA¢Æ!¿“aoL¥Í—õâY¿UÚOÙtéI< ıˆ§Ã†¯=Ì“=mÅ≠åç◊øqYh≥Ã-õ’tª #A◊§j˚Á>_´8Äò˙áÃÍ#iÛ&˙πﬂ≈-8ü%B6BvÜøBWBﬁ¶≠£rM∑&Ÿ-÷\Cü>Ç)ÿªU'óM¥ˇpØ˜WÃ™aÜÒ§˛Ä±9V©Ö˘•9'†™;∞VãﬂJ(N‚µ®∞G=f$‚wÔﬂÃ4s¯l"Ã”î'è&¶¿Ñ˜6^€?ìã%‡¢£ ∫bŸÉ·*˘:=˚7Lb≤ÿÄb6‡ +ÆÖ`ııºEzÒºWÌ÷∑Mä%_…˘ Fû—öªêäÌÎcpSB˚{ÔN€¯a:<é%¢D€6’‚3	üfìw#WÎ„π!G√È§Çö7–œ:Âü‡†éá«ºΩã{ˆæ7)I6ﬁ∂ˇ‡Q4S|A«°3–Ïÿ·∫Híâ~¨Å∂©«6ı‚‘‹•GÚMü`“{
ãÑH‚›Ø#éÅ`à0ÊÅl≤ˇ¿u¡y‹ àÆJ pﬁ0ãpµ|â~Ù):(±Ä¥kOà¬∑Ûñìˆ≥o|mˇ2,gb⁄èÅ¿rÜïª:™a *q…+ı‚rﬁ±;|1”≠¶Õ„Y$Lzﬁ5lS–ç‡≈ZŸú»î#Ì‚U:ôUŒùUï∂°‚Ò¬?ŒŒ≠•
8Ç«"=ñÏ;2Fp|Aö√Ã]$‡0Ä‹¬iäa!)éµ∫ã~õzq#QfíÖﬂÌˇwÆè>∆î˜Á`Nd)ivIM|¬R]Ü Ÿ•ü4W`˚vÜ/Ä§¬é$å`V˝√ﬁ2ÏÅ
—]7≤ƒ%]xµt'˙—ßŸ9˘-f’åÌæˇp0ã§>';> åDò÷h“’GJ√g$b.°Ã/ˇfáS˙t1≠ﬂRﬂ¸m`1Î„Á’Z˚2‰_ÕÓ-~µHD«l•Õ{xóÖÔ‡@Ô}Ã»˜˜õˆœ€nÈvW∏HE„Pﬁá/±;z/msE¡0ò¯ë{⁄«(Ê™—L©80"„£IY¶æÄ´Y •·óﬁµÅìNz"÷\àœ¥Õ#’ K(Iî_]ÎH)ïÿhj≠=∏tº$v &8„ùâôËÚ˙Ëı„Ñ¡'˘6á◊?/^–Õ_‚€WÉÒ23¿√„`Ù#¢7q!ìÓq∞‡À-Áµñe™ £!ùEÎ4È™Sbo_z˜8Òyx˛”Ey*-Ûm–œÚÏÛZøxE˘Õ…ºpêòÈ1{i5!≥Ö6€h≥çûw@˛ ¸ú˘Á÷}{Ç›ø∂b∫ﬁõ|˜6vE_dí''ÁP⁄¯ÙıÔÈnŸ◊¯ìà„∂~ˆb#¨–€/µsŒ˘ é!tôŸ8PÈ¡6¿lrØ˝„Ç∑C6öˇWO0èP$"†Oıß√††µÕ5 ›|õ√PM2Gñ¡µÌ=CÑKl´˝h@∏Ìê¶•‘hÙ◊I_°AE‡–æTVΩX…z#ˇyÅêﬁªÓπ¿x‰Øs√Î˛0uìóØ{¿≠z•ˇ0›◊{£+	¢/aP¶h”6&ic±í¯∞&¶2‹1ªÉ«$-ƒˆàÏ?p0z%Ω˛„Ù≤k]€ôîπC“÷¿˙ˆCÙíˆbèE∞øˇ)ˇΩˇ‹î£Àéö†∞Ÿô #¡÷îj7õ¸ø¢≤™ª Wt˛¯W`7◊/=⁄ÃõÁ[„ΩÄ∂ŸädÊ¿pr®ç6ùpà&Ë=>m4¯+´—«∏bÚøäle÷¨‹	òpÒ∂‚7yù˝
ms& aÙ%ﬁ∏Òf5n«ROûçY
9hg˝wÚ«j‡ä˚Ï≈˝ÏU+
™íòÒv‹k&˛›¬Œ“Î9?|b˛'-s ˝§=W›Ê≥(
Å∏f,⁄9ÇË-\’æe`•¶ﬁ,]Ù∞∑È‚‘ﬁê›—'9Ñ·ﬂÁx÷q# Ï†5XU(èW/≠q 66Ω´ïZdê¡µöq ¢t—lAƒ{±0¯>ÏÌŒè:˛.6pÿ§ùTq…óõpñçÜ∏”é2ÅOü¢\¡UÌ[*ã>÷ÃG^ëgkÒ|JÇŒÔkÑ¢ˆÊ¬g«≥ı_2’‘	Ä—qà4TŒ;”¢£îk\Gb∏çÆñèr˝$∂W–6≥ƒﬂàS|uôâ&Ÿ‚|ÑÖh;ØÒÆÉ∂eèz‹äÆ⁄¢œc["–z˝œcZ(Ã¸7ÄqŒ¸kV*p<∏=«¬–e?P9˙…@¢Ã$é≤8∞lgß~ô	ﬁâ0MXìtì∂õL8ãK+º∆ˇ ≥jÿödµÀM∂$◊ﬂÍÎO>p‹Eˇ-gêÂ«m`∆j®ïŒ-ÃHb˚∂∏7K\Ä±ã•J@Eo@jH,$ÃB¯".ó6m—EèÍ‚/ÕÌü¿Ü∑åß’{®Ü@CŒÖqΩGWTl≤ı DπXÇD|äy˝-ZLCM~3°Éœ|pytMÎ}ÃjõãìL¿cÅ§∫Ø~ıÀóÎÌ˜Ω6ˇﬁqì–RØP\M¿ëì’í[H≈Ú`(«º@äT\„øõ˚V&r5˘ãNøà	<Füf∂˝∫§‹ˆ⁄‘1õ{ "7ú∂¿Òi ˙íœeéñÓW ¡µm‹[√Œ 2´Ü˚ÔªÇEæKìıË¯ §G˝O n[KSel˙_Ÿ¢»∑E´J@„% $74ícŸˆ⁄OÊ∏ÄÜ·ı' àÆ•](-wÿù¿£oﬂ√5ùØ∆ùv÷2Ó^túK~“ºjä◊ \AêQc⁄ÙûÄø∆˘õ]"f’Ôù≤hˇÉV≤è√£OèË‡ÎÕkqX;ÿ“,™Ì<Ú—å—h5∑râﬁÄ	xãÙ¥ºùVvÒÑ ∫ôkN¯wfë„x€mtfT~πÏ»&ñÛå∆-h≈@!ÎNF•3X"≠¬Ë›,⁄ÉxI¬Ë]…d3n	éåYYÂ˛öurPgå ‰;I!ˇ~¥¢π≤‹˚wÒ1⁄Ç«A{Ä}ÌèoYw#;•‘]~ç5&€ﬂj¡R”:>†k◊§û≤V?(h!D—gy£§YwŒ˘∂Ê⁄ﬂJu±ÁLÄÿK#pA÷R Ú˛ÍáCE€kÔ»ô¢ﬁÕ,ŸIπ–èèI6&>Äaµ~∆(O`<| Âñ÷Z“'@ñ{ﬂï;˝äDÄ◊ª©‡#pÂ¢µ
‚≠Âû∏ˆ‡ko00√*Ìé“ˆﬂ™_î≈(‡Óªæ˝ù≈_(+ƒàKçÅä§∂jkπø?Bb …Ø7Aˇ4¯8oyd/Æ+‡ÏˇëX∆‘HJπÅπöÄN ¨Òî#∂¥Nú˜GÁöìÃæ(z›Ï]ﬂ}~f8å
Ö[ e\U°≥…ï1 V≠µó:s¢t€tª∫=∑⁄F•≤‡uUõº!Ì‘8ñﬂMÄ¶Fﬁ®⁄◊«o“Õ:·ı;÷µamlex§,D°=™sÃŸ˝£ (áævπ £Â8Nj∏9ù]¶9ÀÿL∂Ò2ä≤∫‘≈≠Ôf∂√
IY2ß¥ÜU÷5wëÄkJ’§dÔÁ+‰∏m7±Õ˙ØÔŸêõW[ÍÕ' éÂ@≠Ñ≤O†ÁÄ√¨
-«*.`$ÄßÕvZNxmÁls8¥EQÓúw.+ÉP`« ÷6*¶n◊VR©‘„wphöRÈTIõ¥‘iy
<:w†√j∑I:XŒpX±(Î˝*≥te¡Gh¥öå Õ—µ»m:t»;©RIª;¿ﬂÇ4ÿlŸﬂ
ìŒ‡∞“UõñëŒßxY« FKZ[ni©2êµÊ†c(LU°¢KKµ˛Ñ k∂¯´6ZŸncîCÅF“ZjZÉ8`ç} ’r†•W
Qﬂô +úRY{˙ä@cƒ%«#H©ßl˘Í-.¿·»y@nûπ\Ä1lS—ÊÅ`∞*Œ p8NY7üäiÊ‚≤Gû)◊l´FÙù–·Pu∫Ö\Êcƒ%◊ø à¨TFkF”Q áïÆ˝AêOQ˚k√sª k|Rc˚óıΩrX±Ú˜lM p±Â\˛#∑∞∆> -P^d¶Çs:¨Tÿb–O∫Ãº@q}F¬–™/RHrkﬂ·I•Pﬂk"Øˆ”P`g¨%Çx∞ MAŸ€‚rÅçX£ˆB“hü8`n°ú˙_≠ÂÍÄ√j!Ÿ$—qË0ª IKç∫T†Å(˜‹6†√
ó∏≠£Â%£Æ »h‹A+≠¨/ıµ “n–·0Q^Êô}∞w¯Ûzái.hÉí¿±áC_&∑Ë´&Â`F9`†C´88ôÓ/4-Õ,∑8õ§)¿≈∞çb\@‰∏Ä√JÁTM®9ÂLPgåà†Av˜pù–a≈f•_◊¯K
å”’i55p»ıs7Ç◊q¿aeà¨Tñ}9Xå¬f' F‘r+ø6-K«Õláï@E ;J5Ÿ%:àt`MÔ¿jù∑?çT"ZLò£*luÓAáe@ã”j™J‰˘e}:ÈúÄkíÎ¢µl@ÒAœADπ’	 áfÉíŸõ|9ã [%◊rfÑ£Z∆È¿±2Ω]¬“0Û∂=ñPm˚øÃU˙ct%‰m⁄rs›!O˙y≥vËäE˛Ö:È˝$`™¶ÄQ< Ó‡œNöèùÅÎ∑<êøn«Ï∂xâ€@æ-!i`]M`!"bäò∂{x…œÂb9Ä™0áqå‡8«Vîâ¯]z\Ÿ{”ÚáDX¥≤¯”Ÿd1"˝OeN= r‡XcÊæ!S”˜´Ôm!lÍ„Ü«Ê…<ÍƒõπN_ç»'◊Û¿9¨".’úΩHå\ØûŸLÄÕ‘HçoI ±zãÎ]Å¨_ ¢lSè7…}ÏÏññw°µàÒj§6Ä«ìÊ	>!ª¢E˘	¢;k√∏%döbll YA`sµ·ÚﬂC¨6uöJƒŸ‰b≈à—|Çâ¡∆ø7&∂¡rZKZÈ8ig+´V±<ƒ`±ÒˇF≠Xµb`–.=g÷f«5õœbj≤^“À7ÿ‹gFå"V∞ÒÛ¿ò§ãQìœP£÷ÄâÔZ≠∆œâﬂâÔ8yrb4˚ΩZ±b‘Bz_È}ãQk≠1È=	Jdì\:?m#&>/+F$EcMvˇò¯yb¯∆X#èƒÿüc“{∏@‰ãVi\†ß=B{S·;∞8=YîÅæC‡|ïóÜÊò¿Rl€ÈÑy<èW1ŸÁ6«‚Öˇ6{_kF\¿*u≈£2iaKu‰Ï¿XâèïˇΩÑ÷‡|πcZ©y]ÛΩ∫n…∂È:áÃf[Æ≤§ﬂó‚5TûKMºÜm8N˛π€≤oGé%πÒ†Ù;)]c˛B`ë(°˝Õ]≠•c√œpMÁõÃ™°+N ¨∫D®ä›Œ9}ãIÔ'ËcërëÄ¬ƒÒPî>v®Ù÷e[@¶U±âÑ¨¯≈≥QÚd‘]Õ‡LR˚-2M98”‡ód⁄íäØ§*8Úg,_eÒ,Zø +BHÜgjüàîÓ¢˛◊Õï{Î|B≈´’,f‘+ñ⁄%ˇ6äﬁ -e´Æ{'˙˙wÄÌQèâ∏¶˜B∂¥ﬂMè0lÀMº¶¡ñÜ≈4l“6/Ó™@)˛¯Ë‘-2≠ùÏıìüÂ&ıêœXDÂ⁄ö<áª·†úå+5ﬂoøaåpÂ´ƒ2â/˚˚”k:Á±M=Êd›˚ê÷ˇ6‡åDÏQèk;ÔaowL‚£….Æ@m™p›Dêµî⁄i÷<qÍÇGõø!+« ≤TîÆµ8±•q1»
ûÕr˜ªΩozZÀ Í∑R{¸aœNÜ0ë∫ÔÆK√¢=†ˆTÖ”«#πl<∂¿TÖÌ˚˜mÊ§çˇ»îy4ãZÀÔÊEßC4Â·<µÂ~◊¸yô≤Æ\`¨‰~áô@√Ñ‘\ôñLòaÁ[…µhÕs◊éâÆ¬ò≈øµ‘¯x≤Ø?]€ôÀXÁ`<r$	ƒx”Ê˚∏w˛π≤›…-Hò@”ÇYnR‘kï√´[gÒØåäÀä4›r˜◊¥Hö©øTXBK*⁄“U¶±≤Á1‹<©3ÀV∆>éLÕ)!>è˚ñ.äÆÌÃ1´˛∏,˛Òa )RªÏïwˇÑúr“ªu⁄˚Y&©xòãæÈµ6⁄¨ZKØó[tu.Ci8Cﬁg?¿r#›tﬁaÇ®Ël≤ÕõÆ≥ËÔêö˚_ŒÔ ç~b®s6≥U@" æ,Ÿ{ı@p;&ﬁ«¨˙tì∏”1¡xeŒIƒ∂=¯†ˇ“è~˜lˆˆ_è°«~‚„B¿&9üÚ°Ò‡'ˇœﬁœΩß(®dù!‚◊y¶πÚüÂè¡‡oMΩÚi∫¯Ω¸∑D◊°•k£È¸ïÑË‰˜Z‘πZÿüå;¯ﬁ‡xÈ9Ûøœﬂ˘Îœ=À¯˛»^ãÊ¥}Ó>ÛoJÓ¸í>->3-p-\èÊÓ#ˇ8î‹Ωï«ã!F`è>ˆc˙£‡Á∆uÒèHëﬂüΩ∫˜Xo“º ˙Êy:a6eõQNChçe+µD}π')KX©ù‰Jå ©—lJqsØÈl≈öv+—º‘<âÍÎ:6RØ√•Å/î∑¸äﬂ‘<π¸5ÂG¢xïun—4›«K‘·Aâ’õMæ9öù¯;Äq≤˘èœa&∏ÀÔ{(””Á„{ÁÄyjLÉxŸú»¶Ö‰µ›ÄJ¢¸•Ù›¸\M_7‰Ë≤Ó‡XÈrê¡˘”ÔiÓ∑J_√≠+îøÜˇñÇeÍóùœóOµ¯, Ø+bÆt˘Ô/∑ïò~°|ﬂ*•ë“9
èYÄHÒº˝Dv?™_>≈¸‚çÏﬁ¯µÇsyù˚ß «∂"	~ñ˙<Ö-mz'˜˜O`EP?âô]LBâ[	1Ø•òD"Xëÿ∑òO(¿¯
–ÚD*Ó«‚w”„ßˇ,%Á»≥@∞≠¯‹≠VÚì`–Õ §Ì+£$¥)˝]ê¯>[-íﬂ§Ó–(wû®tŒÏ⁄íÎäÇ“‹Hè[so^Kã˜ï˚Bv˝e„≥°òFö¡1kçV…Æ’kivˇAP|¶A2&6ë*˘·äTÒ⁄B€ÿ0}7w}ûN[»	£8QlLµ˛Ò% ÚÇ Lñ˝Â‡P7?¿é≥∆?~@Ÿ<P`{Õ˝ﬂ67xÔÙm ms¬È€én–G˘˘k(£|MÈw”˜Îæ_wû¶˚JﬂvM◊u®˜ŸÙùa«[Ó€SﬂÄ∏™—áãˇ’}ÖCˇ‡k    IENDÆB`Ç

====================================================================
FILE: D/D/icons/icon19.png
====================================================================
âPNG

   IHDR         rP6Ã  IDATx⁄µ‘±oúEﬂÏ}éœ`@t© BîñR¶¢É⁄ˇB§Ñ"ä–ÂLd_C
‚4AtëÚ§A(—F4h@äî§‰˚˚v(lN∂Ô(`§’J≥⁄∑ÔΩŸGfd!cÊdq'{˛”dôïé	£àt=_ó∂§E‘B©≤Ü¢:Qñµnª_dcÌa∞\÷C´Z•˛`∑‹≤®±[v§˙ÖU∏ÅëQæ`-n∫ì=´—õx&’Ú¿GÒÛÅúìÜÒpræëè=∑¢oÀFÓXç/≤FÖiÌEﬂ‡aﬂ’\˜ä˚6s≈Õ\88Îºjù˙»¢€Fy∆0Í_NÉ•‰TE+ç±«ﬁ≥ôg-π®ıùRæó>WùôPòí	U∆.÷≠ÂgFÒƒµºãGŒ«YlÉ+äóßpTf¯µÏEÔ∏û‚¥p⁄V~´Înx÷ª´Xûæ:?ve;F{ÅHO»ﬂ—¢ø–Ã Ÿ‡%oËöﬂ\å◊ÚÅÍGkÒÓ° ˙{f)§Œ óU€zæ∂1~SzÀü‰“<)ÂX?§¢∏Ï)ÆË|‡yˇ'œ|eÕ7"“ˆÊÅ5Ê6Y‹;“ã	∂ÖÃpUwmV∆ƒQCÜQE§àt.ˆD§4˛f]!ﬁ6 ◊§F´≥ Ìç√¬“˛ﬁ,ıÑo	øÃüõyJÒ©¨˚S£Ã ûR#TOÖ.˘U""˝1ô¥ˇr@f∆·‘üŸó„)bìÊ≈    IENDÆB`Ç

====================================================================
FILE: D/D/icons/icon32.png
====================================================================
âPNG

   IHDR           szzÙ  $IDATx⁄ÕóMlTU«Áﬁ73Ìå6ÄDÑ11⁄òò≤®çâ‡FÉ—∏±5—ƒÑhlTtÅñj
éjøÑ‡F√√¬Ö°]®+cdÉâDqHã&¢ÑØZ;3ÌºwÔq1Øh˚:”÷ËYΩº˜Œ=ˇÛqœˇ¯èEøÊ’–º¿?7K;]:4UY¥n^Õ#†¢Ë}÷0¡GEêB∆˘ûÇL–ÆñaqıòVÏèvìµ{)£¶jZ2Äc«£tÀO‰5† Q bœè®Âg∆∞Ù1≈a,é∞$§»˙ï!Ö¢4`˘ö´pÑi• g9¢ñé˘#1w\Obi!sú›Ú{ÕπÔ◊[(≥ùîûÊ8ym°CŒ'Åò?±b@»ëW√:lÏmÜ´ï∏Ù÷!ºHDÜ{Qö	8K@MÚ]m|√
N–£õÈêQÚj(àøŸÃB’Í)àÁéN	˘ã“(HDßÑà(√‚(àÁä¯Ä(«NiE˝∑‹Êø‚=›¿;Ë\∑#π¥}T≠ë&V0§è{Hq˚Ù0>‡N–BYJt zö,—Ø?Çá)ìa5πÏ"v˘ŸW;96∆7I
√F`-’≥X…0Âe lBU∞t‡˘√‘\Œq’s@57ÇHéÄ∆Ê*\¢G
Ë<{xC∂Ã¸ì“Då!r^π·åﬁI¨˘∞æ[0[y5î˘ÇFÆÃTıÄæDñ;(≤ìn˝òA˘ì˝⁄»8éUWqXwk“¡µhF„k4|	¿†>çÂ D§Ÿƒj>£∑¯,ØÀo3Ì∏ û>uIm¨6 'Pa®∏…mûBxßi
Oö-§≥'ÿß#D|Jôc@	„µ	°≠E∂Bµr9`3‡pHÏ_ï.nG}ñıd/W≠:ª@nkëK(Ïíst…"÷S·çXîà·<![È≤mt…!J´ãUÂd>™5ƒ1††Qo…Q‡’êc;ì\¶Ã#ºP35œµÚ∂'ØM@&Ë•_W¢*îxçê2°{?6û¶ Q˘‘`:øÓ§â≤<L#íÚ#ÏÁn
2¡$1ÓÛ∏ÕFıŒ.µ5¢)~%‡9"F,°yÜ
W@•ü∆Ù8oŒ&ö•∏^v…º´›•ÈI]§]-à“√•‰(Z]éF‰PDé?ªôŸ1iU'à]Ü¸cDôÎ=ÀõΩéÆa»k}Ü¶uø ‚¡õb<≈,¶¿™:˝a)…L0oŒœômÙNú"»Uá“˙bkâäkZÒ”tΩÛ•=¶⁄>¢ÅΩhn/§ÉT“@âW8Ç°„FGíì^Ωükk[LÊXT2T¯Ö95ó˜ˇﬁjV«™∂¸ÀÈl"”π∆Òˇç¸«ß^
NQú    IENDÆB`Ç

====================================================================
FILE: D/D/scripts/delete-conversations.js
====================================================================
(function() {
    const e = !1,
        t = (...t) => {
            e
        },
        n = (...t) => {
            e
        },
        o = (...t) => {
            e
        };
    t();
    const r = ["div.cdk-overlay-container", '[role="dialog"]', ".modal-container", ".overlay-container"],
        a = ['button[data-test-id="delete-button"]', 'button[aria-label*="delete"]', 'button:contains("Delete")', "button.delete-btn"],
        i = ['button[data-test-id="confirm-button"]', 'button:contains("Delete")', 'button:contains("Confirm")', 'button[aria-label*="confirm"]', "button.confirm-btn"],
        s = ['button[data-test-id="actions-menu-button"]', 'button[aria-label*="actions"]', 'button[aria-label*="menu"]', "button.menu-button", "button.actions-button"];

    function l(e, t = document) {
        if (!t) return null;
        for (const n of e) try {
            const e = t.querySelector(n);
            if (e) return e
        } catch (e) {
            console.warn(`[GD] Invalid selector "${n}":`, e)
        }
        return null
    }

    function d(e, t = document, n = 7e3) {
        return new Promise((o, r) => {
            const a = l(e, t);
            if (a && null !== a.offsetParent && !a.disabled) return void o(a);
            let i = 0;
            const s = setInterval(() => {
                if (c && c.signal.aborted) return clearInterval(s), void r(new Error("Operation aborted"));
                i += 150;
                const a = l(e, t);
                a && null !== a.offsetParent && !a.disabled ? (clearInterval(s), o(a)) : i >= n && (clearInterval(s), console.error(`Elements not actionable within ${n}ms. Tried selectors:`, e), r(new Error(`Elements not actionable within ${n}ms`)))
            }, 150)
        })
    }
    let c = null,
        m = null,
        g = !1;
    let u = null,
        p = null,
        b = null,
        f = null,
        y = null,
        h = null,
        v = null,
        x = null;
    const w = [chrome.i18n.getMessage("deleteConversations_deleting")],
        C = [chrome.i18n.getMessage("deleteConversations_cleared"), chrome.i18n.getMessage("deleteConversations_done"), chrome.i18n.getMessage("deleteConversations_finished"), chrome.i18n.getMessage("deleteConversations_tidied"), chrome.i18n.getMessage("deleteConversations_taskComplete")],
        k = chrome.i18n.getMessage("deleteConversations_cancelled");

    function E(e) {
        return e[Math.floor(Math.random() * e.length)]
    }

    function T() {
        if (document.getElementById("gemini-delete-all-overlay-styles")) return;
        const e = function() {
            const e = getComputedStyle(document.documentElement),
                t = document.body.classList.contains("dark-theme") || document.body.classList.contains("dark_mode_toggled") || "dark" === document.documentElement.getAttribute("data-theme"),
                n = t ? "#202124" : "#ffffff",
                o = t ? "#e8eaed" : "#202124",
                r = t ? "#9aa0a6" : "#5f6368";
            try {
                return {
                    isDark: t,
                    backgroundColor: (t ? e.getPropertyValue("--google-grey-900") || n : e.getPropertyValue("--google-grey-100") || n) || n,
                    textColor: t ? e.getPropertyValue("--google-grey-200") || o : e.getPropertyValue("--google-grey-900") || o,
                    secondaryTextColor: t ? e.getPropertyValue("--google-grey-500") || r : e.getPropertyValue("--google-grey-700") || r,
                    accentColor: t ? "#8ab4f8" : "#1a73e8",
                    progressTrackColor: t ? "rgba(255, 255, 255, 0.12)" : "rgba(0, 0, 0, 0.08)",
                    successColor: t ? "#81c995" : "#34a853"
                }
            } catch (e) {
                return console.warn("Could not read Gemini theme variables, using defaults"), {
                    isDark: t,
                    backgroundColor: n,
                    textColor: o,
                    secondaryTextColor: r,
                    accentColor: t ? "#8ab4f8" : "#1a73e8",
                    progressTrackColor: t ? "rgba(255, 255, 255, 0.12)" : "rgba(0, 0, 0, 0.08)",
                    successColor: t ? "#81c995" : "#34a853"
                }
            }
        }(),
            t = `
      #gemini-delete-all-overlay {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background-color: ${e.backgroundColor}; /* Theme-synced */
        z-index: 2147483647; display: flex; flex-direction: column;
        justify-content: center; align-items: center;
        font-family: 'Google Sans', Roboto, Arial, sans-serif; color: ${e.textColor}; text-align: center;
        opacity: 0; transition: opacity 0.3s ease-in-out;
      }
      #gemini-delete-all-overlay.visible { opacity: 1; }
      #gemini-delete-all-overlay .spinner {
        display: block; /* Default state */
        border: 3px solid ${e.progressTrackColor}; border-top: 3px solid ${e.accentColor}; /* Themed */
        border-radius: 50%; width: 50px; height: 50px;
        animation: spin 0.8s linear infinite; margin-bottom: 25px;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      
      /* Completion Tick Styles */
      #gemini-delete-all-overlay .completion-tick {
        display: none; /* Hidden by default */
        width: 60px; height: 60px;
        border-radius: 50%;
        stroke-width: 5; stroke: ${e.successColor}; /* Themed */
        stroke-miterlimit: 10;
        animation: draw-tick-container 0.5s ease-out forwards;
        margin-bottom: 20px;
      }
      #gemini-delete-all-overlay .completion-tick .tick-path {
        stroke-dasharray: 100;
        stroke-dashoffset: 100;
        animation: draw-tick-path 0.5s 0.2s ease-out forwards;
      }
      @keyframes draw-tick-container {
        0% { opacity: 0; transform: scale(0.5); }
        100% { opacity: 1; transform: scale(1); }
      }
      @keyframes draw-tick-path {
        to { stroke-dashoffset: 0; }
      }

      #gemini-delete-all-overlay .message { 
        font-size: 20px; font-weight: 500; margin-bottom: 8px; 
      }
      
      /* Progress Container and Text */
      #gemini-delete-all-overlay .progress-container {
        display: flex; flex-direction: column; align-items: center;
        width: 300px; /* Fixed width for the progress bar */
        margin: 10px 0;
      }
      #gemini-delete-all-overlay .progress-text { 
        font-size: 14px; color: ${e.secondaryTextColor}; 
        margin-bottom: 8px; width: 100%;
        display: flex; justify-content: space-between;
      }
      
      /* Progress Bar Styles */
      #gemini-delete-all-overlay .progress-bar {
        width: 100%; height: 4px; background-color: ${e.progressTrackColor};
        border-radius: 4px; overflow: hidden;
      }
      #gemini-delete-all-overlay .progress-bar-inner {
        height: 100%; width: 0%; /* Initial width */
        background-color: ${e.accentColor};
        /* Smooth animation when the width changes */
        transition: width 0.25s ease-out;
        border-radius: 4px;
      }
      
      /* Cancel Button */
      #gemini-delete-all-overlay .cancel-button {
        margin-top: 16px;
        color: ${e.secondaryTextColor};
        font-size: 14px;
        background: none;
        border: none;
        padding: 8px 16px;
        cursor: pointer;
        font-family: 'Google Sans', Roboto, Arial, sans-serif;
        border-radius: 4px;
        transition: background-color 0.15s;
      }
      #gemini-delete-all-overlay .cancel-button:hover {
        background-color: rgba(128, 128, 128, 0.1);
      }
      #gemini-delete-all-overlay .cancel-button:focus {
        outline: none;
        box-shadow: 0 0 0 2px ${e.accentColor};
      }
    `,
            n = document.createElement("style");
        n.id = "gemini-delete-all-overlay-styles", n.innerText = t, document.head.appendChild(n)
    }

    function S(e, t, n) {
        if (!p || !f) return;
        const o = e + t;
        p.textContent = chrome.i18n.getMessage("deleteConversations_progress", [String(o), String(n), String(e), String(t)]), o > 0 && f.style.animation && (f.style.animation = "", f.classList.remove("indeterminate"));
        const r = n > 0 ? o / n * 100 : 0;
        f.style.width = `${r}%`
    }

    function M(e, t, n, o = !1) {
        h && (h.style.display = "none"), b && (b.style.display = "none"), p && (p.style.display = "none"), x && (x.style.display = "none");
        let r = !1;
        if (y)
            if (o) y.textContent = k;
            else if (g) {
                y.textContent = chrome.i18n.getMessage("deleteConversations_workspaceMessage"), y.style.fontSize = "14px";
                try {
                    localStorage.removeItem("gemini_bulk_delete_workspace_warning_dismissed")
                } catch (e) {
                    console.warn("Could not reset workspace warning state:", e)
                }
            } else n > 0 && e === n && 0 === t ? (y.textContent = E(C), r = !0) : n > 0 && e > 0 && t > 0 ? (y.textContent = chrome.i18n.getMessage("deleteConversations_partialSuccess", [String(e), String(n)]), e >= t && (r = !0)) : n > 0 && t === n ? y.textContent = chrome.i18n.getMessage("deleteConversations_allFailed") : n > 0 && 0 === e && 0 === t ? y.textContent = chrome.i18n.getMessage("deleteConversations_noItemsProcessed") : 0 === n ? y.textContent = chrome.i18n.getMessage("deleteConversations_noItems") : (y.textContent = E(C), r = !0);
        r && v && n > 0 && (e > 0 || o) && (v.style.display = "block")
    }

    function A() {
        clearTimeout(m);
        const e = document.getElementById("gemini-delete-all-overlay");
        e ? (e.classList.remove("visible"), e.addEventListener("transitionend", () => {
            e && e.remove(), u = null, p = null, y = null, h = null, v = null, b = null, f = null, x = null
        }, {
            once: !0
        })) : (u = null, p = null, y = null, h = null, v = null, b = null, f = null, x = null)
    }

    function _() {
        document.querySelectorAll(".conversation-checkbox:checked").forEach(e => {
            e.checked = !1
        });
        try {
            const e = new Event("change", {
                bubbles: !0
            });
            document.querySelector(".conversation-checkbox") && document.querySelector(".conversation-checkbox").dispatchEvent(e);
        } catch (e) {
            n()
        }
    }

    function L(e) {
        return new Promise(t => setTimeout(t, e))
    }
    async function P(e) {
        if (c && c.signal.aborted) throw new Error("Operation aborted");
        const t = e.parentElement;
        if (!t) throw new Error("Checkbox parentElement is null.");
        if (t.classList.contains("conversations-container") || t.id && t.id.startsWith("conversations-list")) throw new Error("conversationItem incorrectly identified as main list container.");
        const n = t.nextElementSibling;
        if (!n) throw new Error("Actions wrapper (sibling to conversation item) not found.");
        let o = l(s, n);
        if (o || (o = n.querySelector("button")), !o) throw new Error("Three-dot button not found in actions wrapper.");
        o.click();
        const m = l(r);
        if (!m) throw new Error("Overlay container not found.");
        const g = await d(a, m, 7e3);
        if (!g) throw new Error("Delete button not found in menu");
        g.click();
        const u = await d(i, m, 7e3);
        if (!u) throw new Error("Confirm button not found in dialog");
        u.click(), await
            function(e, t = 15e3) {
                return new Promise((n, o) => {
                    if (!e || !document.body.contains(e)) return void n();
                    let r = 0;
                    const a = setInterval(() => {
                        if (c && c.signal.aborted) return clearInterval(a), void o(new Error("Operation aborted"));
                        r += 100, document.body.contains(e) && null !== e.offsetParent ? r >= t && (clearInterval(a), console.error("Element did not disappear within timeout:", e), o(new Error("Element did not disappear within timeout."))) : (clearInterval(a), n())
                    }, 100)
                })
            }(t)
    }(async function() {
        let e = Array.from(document.querySelectorAll(".conversation-checkbox:checked"));
        const r = e.length;
        if (0 === r) {
            return;
        }
        const a = function(e) {
            const t = document.getElementById("gemini-delete-all-overlay");
            t && t.remove(), c = new AbortController, clearTimeout(m), m = setTimeout(() => {
                if (c && !c.signal.aborted) {
                    console.error("Bulk deletion watchdog triggered - operation taking too long"), c.abort("timeout");
                    const e = document.createElement("div");
                    e.textContent = chrome.i18n.getMessage("deleteConversations_timeout"), e.style.cssText = "color: #f28b82; font-size: 14px; margin-top: 8px;", y && y.parentNode && y.parentNode.insertBefore(e, y.nextSibling), setTimeout(() => {
                        A(), _()
                    }, 3e3)
                }
            }, 3e4), T(), u = document.createElement("div"), u.id = "gemini-delete-all-overlay", u.setAttribute("role", "dialog"), u.setAttribute("aria-modal", "true"), u.setAttribute("aria-labelledby", "gemini-delete-message"), h = document.createElement("div"), h.className = "spinner", v = document.createElementNS("http://www.w3.org/2000/svg", "svg"), v.setAttribute("class", "completion-tick"), v.setAttribute("viewBox", "0 0 52 52");
            const n = document.createElementNS("http://www.w3.org/2000/svg", "path");
            n.setAttribute("class", "tick-path"), n.setAttribute("fill", "none"), n.setAttribute("d", "M14.1 27.2l7.1 7.2 16.7-16.8"), v.appendChild(n), y = document.createElement("div"), y.className = "message", y.id = "gemini-delete-message", y.setAttribute("role", "status"), y.setAttribute("aria-live", "polite"), y.textContent = E(w);
            const o = document.createElement("div");
            o.className = "progress-container", p = document.createElement("div"), p.className = "progress-text", p.textContent = chrome.i18n.getMessage("deleteConversations_preparing", String(e)), o.appendChild(p), b = document.createElement("div"), b.className = "progress-bar", f = document.createElement("div"), f.className = "progress-bar-inner", f.id = "gbd-progress", f.style.width = "30%", f.style.animation = "progress-indeterminate 1.5s ease-in-out infinite", b.appendChild(f), o.appendChild(b), x = document.createElement("button"), x.className = "cancel-button", x.textContent = chrome.i18n.getMessage("deleteConversations_cancel"), x.addEventListener("click", () => {
                c && !c.signal.aborted && (c.abort(), y.textContent = k, M(0, 0, e, !0), setTimeout(() => {
                    A(), _()
                }, 1500))
            }), u.appendChild(h), u.appendChild(v), u.appendChild(y), u.appendChild(o), u.appendChild(x), document.body.appendChild(u), requestAnimationFrame(() => {
                u && u.classList.add("visible")
            });
            const r = document.getElementById("gemini-delete-all-overlay-styles");
            return r && (r.innerText += "\n        @keyframes progress-indeterminate {\n          0% { left: -30%; width: 30% }\n          50% { left: 100%; width: 30% }\n          100% { left: 100%; width: 0 }\n        }\n        #gemini-delete-all-overlay .progress-bar-inner.indeterminate {\n          position: relative;\n          animation: progress-indeterminate 1.5s ease-in-out infinite;\n        }\n      "), c
        }(r);
        if (!a) return void console.error("Failed to initialize abort controller");
        const i = setTimeout(() => {
            if (c && !c.signal.aborted) {
                console.error("Bulk deletion watchdog triggered - operation taking too long"), c.abort("timeout"), y && (y.textContent = chrome.i18n.getMessage("deleteConversations_longOperation")), b && (b.style.display = "none"), p && (p.textContent = chrome.i18n.getMessage("deleteConversations_longOperationSuggestion"), p.style.display = "block", p.style.textAlign = "center", p.style.width = "100%", p.style.marginTop = "10px"), h && (h.style.borderTopColor = "#f28b82");
                const e = document.createElement("button");
                if (e.textContent = chrome.i18n.getMessage("deleteConversations_tryAgain"), e.style.cssText = "\n          background-color: var(--gd-bg-primary);\n          color: var(--gd-focus-ring, #1a73e8);\n          border: 1px solid var(--gd-focus-ring, #1a73e8);\n          border-radius: 4px;\n          padding: 8px 16px;\n          margin-top: 16px;\n          font-family: 'Google Sans', Roboto, Arial, sans-serif;\n          font-size: 14px;\n          cursor: pointer;\n        ", e.addEventListener("click", () => {
                    A(), _()
                }), y && y.parentNode) {
                    const t = y.parentNode;
                    x && (x.style.display = "none"), t.appendChild(e)
                }
                setTimeout(() => {
                    A(), _()
                }, 3e4)
            }
        }, 3e4);
        try {
            if (await L(500), a.signal.aborted) return A(), void _();
            let n = 0,
                o = 0;
            for (const [a, i] of Array.from(e).entries()) {
                if (c && c.signal.aborted) {
                    console.log("Deletion aborted by user or timeout");
                    break
                }
                if (document.body.contains(i)) {
                    try {
                        await P(i), n++;
                        try {
                            const e = await chrome.storage.sync.get(["remainingDeletes", "isUnlocked"]),
                                n = e.remainingDeletes || 0;
                            if (e.isUnlocked || !1) t();
                            else if (n > 0) {
                                const e = n - 1;
                                await chrome.storage.sync.set({
                                    remainingDeletes: e
                                }), t(), e <= 0 && t()
                            }
                        } catch (e) {
                            console.error("Error updating quota:", e)
                        }
                    } catch (e) {
                        if (o++, "Operation aborted" === e.message) break;
                        console.error(`Failed to delete conversation for checkbox (original index: ${i.dataset.index||"N/A"}):`, e.message), document.body.dispatchEvent(new KeyboardEvent("keydown", {
                            key: "Escape",
                            code: "Escape",
                            keyCode: 27,
                            bubbles: !0,
                            cancelable: !0
                        })), await L(100)
                    }
                    S(n, o, r), (a + 1) % 20 == 0 && await new Promise(e => {
                        window.requestIdleCallback ? requestIdleCallback(e) : setTimeout(e, 10)
                    })
                } else S(n, o, r)
            }
            c && c.signal.aborted || (M(n, o, r), await L(2200))
        } finally {
            clearTimeout(i), A(), _()
        }
        console.log(`Bulk delete process finished. Total Selected: ${r}, Deleted: ${n}, Errors: ${o}`)
    })()
})();

====================================================================
FILE: D/D/manifest.json
====================================================================
{
  "manifest_version": 3,
  "name": "Gemini Folders (Replicated)",
  "version": "1.0",
  "description": "Organize your Gemini chats into collapsible folders.",
  "permissions": [
    "storage",
    "activeTab",
    "scripting"
  ],
  "content_scripts": [
    {
      "matches": ["*://gemini.google.com/*"],
      "js": ["injector.js"]
    }
  ],
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
} 

====================================================================
FILE: D/chat_exporter.css
====================================================================
/* Gemini Toolbox - chat_exporter.css */

/* Generic Modal Styles */
.gemini-modal-backdrop {
    position: fixed;
    z-index: 2000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
}

.gemini-modal-content {
    background-color: var(--gf-bg-primary, #1f1f1f);
    color: var(--gf-text-primary, #e8eaed);
    border: 1px solid var(--gf-border-color, #5f6368);
    width: 90%;
    max-width: 600px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    display: flex;
    flex-direction: column;
    max-height: 80vh;
}

.gemini-modal-header {
    padding: 16px 24px;
    border-bottom: 1px solid var(--gf-border-color, #5f6368);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}

.gemini-modal-header h2 {
    margin: 0;
    font-size: 20px;
    font-weight: 500;
}

.gemini-modal-close-btn {
    background: none;
    border: none;
    color: var(--gf-text-secondary, #9aa0a6);
    font-size: 28px;
    font-weight: 300;
    cursor: pointer;
    line-height: 1;
    padding: 4px;
    border-radius: 50%;
}
.gemini-modal-close-btn:hover {
    background-color: var(--gf-hover-bg, #3c4043);
    color: var(--gf-text-primary, #e8eaed);
}

.gemini-modal-body {
    padding: 16px 24px;
    overflow-y: auto;
    flex-grow: 1;
}

.gemini-modal-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.gemini-modal-list-item {
    padding: 12px 16px;
    background-color: var(--gf-bg-secondary, #2d2d2f);
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    font-size: 14px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.gemini-modal-list-item:hover {
    background-color: var(--gf-hover-bg, #3c4043);
}

.gemini-modal-empty-state, .gemini-modal-loader {
    text-align: center;
    padding: 40px;
    color: var(--gf-text-secondary, #9aa0a6);
    font-style: italic;
}

/* Format Selector */
.format-selector {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 12px;
}

.format-btn {
    padding: 12px;
    font-size: 14px;
    font-weight: 500;
    border-radius: 8px;
    cursor: pointer;
    background-color: var(--gf-bg-secondary, #2d2d2f);
    color: var(--gf-text-primary, #e8eaed);
    border: 1px solid var(--gf-border-color, #5f6368);
    transition: all 0.2s;
}
.format-btn:hover {
    background-color: var(--gf-accent-primary-dark, #8ab4f8);
    color: #131314;
    border-color: var(--gf-accent-primary-dark, #8ab4f8);
}

/* Exporter Overlay */
#exporter-overlay {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background-color: rgba(0,0,0,0.75);
    z-index: 2147483647;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #fff;
    font-family: 'Google Sans', sans-serif;
}
.exporter-overlay-content {
    text-align: center;
}
.exporter-spinner {
    border: 4px solid rgba(255, 255, 255, 0.2);
    border-top: 4px solid #fff;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 0 auto 20px auto;
}
.exporter-message {
    font-size: 18px;
    font-weight: 500;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Light theme support */
:root {
    --gf-bg-primary: #1f1f1f;
    --gf-bg-secondary: #2d2d2f;
    --gf-text-primary: #e8eaed;
    --gf-text-secondary: #9aa0a6;
    --gf-border-color: #5f6368;
    --gf-hover-bg: #3c4043;
    --gf-accent-primary-dark: #8ab4f8;
}

/* Light theme overrides */
body.light-theme {
    --gf-bg-primary: #ffffff;
    --gf-bg-secondary: #f8f9fa;
    --gf-text-primary: #202124;
    --gf-text-secondary: #5f6368;
    --gf-border-color: #dadce0;
    --gf-hover-bg: #f1f3f4;
    --gf-accent-primary-dark: #1a73e8;
}

/* Responsive design */
@media (max-width: 768px) {
    .gemini-modal-content {
        width: 95%;
        max-width: none;
        margin: 10px;
    }
    
    .format-selector {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .gemini-modal-header {
        padding: 12px 16px;
    }
    
    .gemini-modal-body {
        padding: 12px 16px;
    }
}

@media (max-width: 480px) {
    .format-selector {
        grid-template-columns: 1fr;
    }
    
    .format-btn {
        padding: 16px;
        font-size: 16px;
    }
}

