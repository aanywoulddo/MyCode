# Manual: Leveraging Claude.ai via Playwright Automation Bridge

This document provides a comprehensive guide for an AI agent to use the provided Python script (`start_chrome.py`) to interact with `claude.ai`. The primary goal of this system is to bridge the capabilities of a local AI agent with the powerful, live intelligence of Claude, enabling the agent to offload complex reasoning, code generation, or analysis tasks.

## 1. System Architecture

The system consists of three main components:

1.  **User's Chrome Browser**: A standard Google Chrome browser instance, launched with a special remote debugging flag. This is the vehicle for our automation.
2.  **Playwright Python Script (`start_chrome.py`)**: The core of the bridge. This script connects to the user's browser, navigates `claude.ai`, sends messages, and extracts responses.
3.  **Virtual Environment (`../venv/`)**: A Python virtual environment located in the parent directory. It contains all the necessary libraries (`playwright`, etc.) required to run the script.

The fundamental workflow is: **Agent -> Modifies Script -> Executes Script -> Reads Output -> Acts on Information**.

## 2. One-Time User Setup

The user must perform a one-time action to launch Chrome correctly. The AI agent must instruct the user to run the following command in their terminal and leave it running.

**Command for macOS:**
```bash
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222
```

**Command for Windows:**
```bash
"C:\Program Files\Google\Chrome\Application\chrome.exe" --remote-debugging-port=9222
```

**Key Points for the Agent to Relay to the User:**
*   This command opens a special instance of Chrome.
*   The user should log in to `claude.ai` in this browser window.
*   This terminal window must remain open while the agent is working. If it's closed, the connection will be lost.
*   If the connection fails, the first troubleshooting step is to have the user close all Chrome windows and re-run this command.

## 3. Agent Workflow: Communicating with Claude

As an AI agent, you cannot talk to Claude directly. Instead, you will use the provided script as a messenger. The script is currently hardcoded with a sample conversation. Your primary task is to **modify this script** to ask your own questions.

### Step-by-Step Guide for the Agent:

**1. Formulate Prompts:**
   - Based on the user's request, decide what you need to ask Claude. This could be a single complex question or a series of questions for a multi-turn conversation.

**2. Modify the Script:**
   - Use the `edit_file` tool to modify `FINAL WORK/start_chrome.py`.
   - Locate the `conversations` list within the `main` function.
   - **Replace the existing strings in the list with your new prompts.**

   **Example:**
   If the user asks you to refactor a function, you would modify the list like this:
   ```python
   # ... inside async def main():
   conversations = [
       f"Please refactor the following Python function for clarity and efficiency. Return only the code in a code block:\n\n{function_code_from_user_file}"
   ]
   # ...
   ```

**3. Execute the Script:**
   - Run the following command in the terminal. This command uses the Python executable from the shared virtual environment to run the script.

    ```bash
   "../venv/bin/python" "FINAL WORK/start_chrome.py"
   ```

**4. Retrieve Claude's Response:**
   - The script will save Claude's answers into the `FINAL WORK/` directory.
   - For each turn of the conversation, two files may be generated:
     - `turn_[N]_response.txt`: Contains the full text of Claude's response.
     - `turn_[N]_artifact_code.py`: If Claude generates code in its "Code Canvas," this file will contain that extracted code.
   - Use the `read_file` tool to get the contents of these files.

**5. Act on the Information:**
   - Use the response from Claude (whether text or code) to fulfill the user's original request. This might involve writing code, answering a question, or analyzing a file.

## 4. Understanding the Script's Internals

A brief overview of how `start_chrome.py` works:

- **`connect_over_cdp`**: Connects to the browser instance the user started with the debugging port.
- **`send_message_and_wait`**: This is the core interaction loop. It types a message, clicks send, and then reliably waits for the response to be fully generated by polling for the "Copy" button to become visible.
- **`extract_artifact_code`**: This function is crucial for retrieving code.
  - It looks for the "artifact" button that indicates a Code Canvas is available.
  - It clicks the button.
  - It uses a **highly specific CSS selector** to find and extract the code content. **This selector is brittle.** If the script fails to extract code, this selector is the most likely cause.
  - It reloads the page after closing the canvas to ensure the chat input is ready for the next turn, avoiding stale element errors.

## 5. Troubleshooting Guide for Agents

- **Problem:** Script fails with a "Connection could not be established" error.
  - **Solution:** Instruct the user to re-run the Chrome launch command. Ensure no other Chrome instances are running first.

- **Problem:** The script fails to extract code from the Code Canvas.
  - **Reason:** The CSS selector for the code is likely outdated due to a website UI change.
  - **Solution:** This requires a manual inspection process. You will need to guide the user to find the new selector and then update it in the `extract_artifact_code` function in the script.

- **Problem:** The script fails to find the chat box or send a message.
  - **Reason:** General UI changes on `claude.ai`.
  - **Solution:** Like the code extraction problem, this requires manually inspecting the page to find new selectors for the chat input box and send button, and then updating the script. 